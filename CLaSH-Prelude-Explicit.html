<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CLaSH.Prelude.Explicit</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_CLaSH-Prelude-Explicit.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/CLaSH-Prelude-Explicit.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">clash-prelude-0.5: CAES Language for Synchronous Hardware - Prelude library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">CLaSH.Prelude.Explicit</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Creating synchronous sequential circuits</a></li><li><a href="#g:2"><code>Arrow</code> interface for synchronous sequential circuits</a></li><li><a href="#g:3">BlockRAM primitives</a></li><li><a href="#g:4">Utility functions</a></li><li><a href="#g:5">Testbench functions</a></li><li><a href="#g:6">Exported modules</a><ul><li><a href="#g:7">Explicitly clocked synchronous signals</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module defines the explicitly clocked counterparts of the functions
  defined in <a href="CLaSH-Prelude.html">CLaSH.Prelude</a>.</p><p>This module uses the explicitly clocked <code><a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a></code>s synchronous signals, as
  opposed to the implicitly clocked <code>Signal</code>s used in <a href="CLaSH-Prelude.html">CLaSH.Prelude</a>. Take a
  look at <a href="CLaSH-Signal-Explicit.html">CLaSH.Signal.Explicit</a> to see how you can make multi-clock designs
  using explicitly clocked signals.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:sync">sync</a> :: (<a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> i, <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> o) =&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; (s -&gt; i -&gt; (s, o)) -&gt; s -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignalP">CSignalP</a> clk i -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignalP">CSignalP</a> clk o</li><li class="src short"><a href="#v:cregisterP">cregisterP</a> :: <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a =&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignalP">CSignalP</a> clk a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignalP">CSignalP</a> clk a</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:CComp">CComp</a> t a b = <a href="#v:CC">CC</a> {<ul class="subs"><li><a href="#v:asCFunction">asCFunction</a> :: <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t b</li></ul>}</li><li class="src short"><a href="#v:syncA">syncA</a> ::  <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; (s -&gt; i -&gt; (s, o)) -&gt; s -&gt; <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk i o</li><li class="src short"><a href="#v:cregisterC">cregisterC</a> ::  <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; a -&gt; <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk a a</li><li class="src short"><a href="#v:csimulateC">csimulateC</a> ::  <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk a b -&gt; [a] -&gt; [b]</li><li class="src short"><a href="#v:cblockRam">cblockRam</a> :: <span class="keyword">forall</span> n m a clk. (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> n, <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> m, <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a, <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a) =&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; <a href="CLaSH-Promoted-Nat.html#t:SNat">SNat</a> n -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> m) -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> m) -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</li><li class="src short"><a href="#v:cblockRamPow2">cblockRamPow2</a> :: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> n, <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> (2 <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-94-">^</a> n), <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a, <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a) =&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; <a href="CLaSH-Promoted-Nat.html#t:SNat">SNat</a> (2 <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-94-">^</a> n) -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> n) -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> n) -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</li><li class="src short"><a href="#v:blockRamCC">blockRamCC</a> :: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> n, <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> m, <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a, <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a) =&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; <a href="CLaSH-Promoted-Nat.html#t:SNat">SNat</a> n -&gt; <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> m, <a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> m, <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>, a) a</li><li class="src short"><a href="#v:blockRamPow2CC">blockRamPow2CC</a> :: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> n, <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> (2 <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-94-">^</a> n), <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a, <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a) =&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; <a href="CLaSH-Promoted-Nat.html#t:SNat">SNat</a> (2 <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-94-">^</a> n) -&gt; <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> n, <a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> n, <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>, a) a</li><li class="src short"><a href="#v:cwindow">cwindow</a> :: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> (n <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1), <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a) =&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a -&gt; <a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a> ((n <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1) <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1) (<a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a)</li><li class="src short"><a href="#v:cwindowD">cwindowD</a> :: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> (n <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1), <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a) =&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a -&gt; <a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a> (n <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1) (<a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a)</li><li class="src short"><a href="#v:csassert">csassert</a> :: (<a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/package/base/docs/Text-Show.html#t:Show">Show</a> a) =&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t b -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t b</li><li class="src short"><a href="#v:cstimuliGenerator">cstimuliGenerator</a> :: <span class="keyword">forall</span> l clk a. <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> l =&gt; <a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a> l a -&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</li><li class="src short"><a href="#v:coutputVerifier">coutputVerifier</a> :: <span class="keyword">forall</span> l clk a. (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> l, <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/package/base/docs/Text-Show.html#t:Show">Show</a> a) =&gt; <a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a> l a -&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short">module <a href="CLaSH-Signal-Explicit.html">CLaSH.Signal.Explicit</a></li></ul></div><div id="interface"><h1 id="g:1">Creating synchronous sequential circuits</h1><div class="top"><p class="src"><a name="v:sync" class="def">sync</a> <a href="src/CLaSH-Prelude-Explicit.html#sync" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> i, <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> o)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p><code><a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a></code> to synchronize to</p></td></tr><tr><td class="src">-&gt; (s -&gt; i -&gt; (s, o))</td><td class="doc"><p>Transfer function in mealy machine form: <code>state -&gt; input -&gt; (newstate,output)</code></p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>Initial state</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignalP">CSignalP</a> clk i -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignalP">CSignalP</a> clk o</td><td class="doc"><p>Synchronous sequential function with input and output matching that of the mealy machine</p></td></tr></table></div><div class="doc"><p>Create a synchronous function from a combinational function describing
 a mealy machine</p><pre>mac :: Int        -- Current state
    -&gt; (Int,Int)  -- Input
    -&gt; (Int,Int)  -- (Updated state, output)
mac s (x,y) = (s',s)
  where
    s' = x * y + s

clk100 = Clock d100

topEntity :: (CSignal 100 Int, CSignal 100 Int) -&gt; CSignal 100 Int
topEntity = sync clk100 mac 0</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>csimulateP clk100 clk100 topEntity [(1,1),(2,2),(3,3),(4,4),...
</code></strong>[0,1,5,14,30,...
</pre><p>Synchronous sequential functions can be composed just like their combinational counterpart:</p><pre>dualMac :: (CSignal 100 Int, CSignal 100 Int)
        -&gt; (CSignal 100 Int, CSignal 100 Int)
        -&gt; CSignal 100 Int
dualMac (a,b) (x,y) = s1 + s2
  where
    s1 = sync clk100 mac 0 (a,b)
    s2 = sync clk100 mac 0 (x,y)</pre></div></div><div class="top"><p class="src"><a name="v:cregisterP" class="def">cregisterP</a> :: <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a =&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignalP">CSignalP</a> clk a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignalP">CSignalP</a> clk a <a href="src/CLaSH-Prelude-Explicit.html#cregisterP" class="link">Source</a></p><div class="doc"><p>Create a <code>register</code> function for product-type like signals (e.g. '(Signal a, Signal b)')</p><pre>clk100 = Clock d100

rP :: (CSignal 100 Int, CSignal 100 Int) -&gt; (CSignal 100 Int, CSignal 100 Int)
rP = cregisterP d100 (8,8)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>csimulateP clk100 clk100 rP [(1,1),(2,2),(3,3),...
</code></strong>[(8,8),(1,1),(2,2),(3,3),...
</pre></div></div><h1 id="g:2"><code><a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:Arrow">Arrow</a></code> interface for synchronous sequential circuits</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:CComp" class="def">CComp</a> t a b <a href="src/CLaSH-Prelude-Explicit.html#CComp" class="link">Source</a></p><div class="doc"><p><code><a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a></code>onent: an <code><a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:Arrow">Arrow</a></code> interface to explicitly clocked synchronous
 sequential functions</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:CC" class="def">CC</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:asCFunction" class="def">asCFunction</a> :: <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t a -&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t b</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:CComp" class="caption collapser" onclick="toggleSection('i:CComp')">Instances</p><div id="section.i:CComp" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/package/base/docs/Control-Category.html#t:Category">Category</a> * (<a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> t =&gt; <a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:Arrow">Arrow</a> (<a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> t =&gt; <a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:ArrowLoop">ArrowLoop</a> (<a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> t)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:syncA" class="def">syncA</a> <a href="src/CLaSH-Prelude-Explicit.html#syncA" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p><code><a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a></code> to synchronize to</p></td></tr><tr><td class="src">-&gt; (s -&gt; i -&gt; (s, o))</td><td class="doc"><p>Transfer function in mealy machine form: <code>state -&gt; input -&gt; (newstate,output)</code></p></td></tr><tr><td class="src">-&gt; s</td><td class="doc"><p>Initial state</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk i o</td><td class="doc"><p>Synchronous sequential <code>Comp</code>onent with input and output matching that of the mealy machine</p></td></tr></table></div><div class="doc"><p>Create a synchronous <code><a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a></code>onent from a combinational function describing
 a mealy machine</p><pre>mac :: Int        -- Current state
    -&gt; (Int,Int)  -- Input
    -&gt; (Int,Int)  -- (Updated state, output)
mac s (x,y) = (s',s)
  where
    s' = x * y + s

clk100 = Clock d100

topEntity :: CComp 100 (Int,Int) Int
topEntity = syncA clk100 mac 0</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>simulateC topEntity [(1,1),(2,2),(3,3),(4,4),...
</code></strong>[0,1,5,14,30,...
</pre><p>Synchronous sequential must be composed using the <code><a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#t:Arrow">Arrow</a></code> syntax</p><pre>dualMac :: CComp 100 (Int,Int,Int,Int) Int
dualMac = proc (a,b,x,y) -&gt; do
  rec s1 &lt;- syncA clk100 mac 0 -&lt; (a,b)
      s2 &lt;- syncA clk100 mac 0 -&lt; (x,y)
  returnA -&lt; (s1 + s2)</pre></div></div><div class="top"><p class="src"><a name="v:cregisterC" class="def">cregisterC</a> ::  <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk -&gt; a -&gt; <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk a a <a href="src/CLaSH-Prelude-Explicit.html#cregisterC" class="link">Source</a></p><div class="doc"><p>Create a <code><a href="CLaSH-Signal-Explicit.html#v:cregister">cregister</a></code> <code><a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a></code>onent</p><pre>clk100 = Clock d100

rC :: CComp 100 (Int,Int) (Int,Int)
rC = cregisterC clk100 (8,8)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>simulateC rP [(1,1),(2,2),(3,3),...
</code></strong>[(8,8),(1,1),(2,2),(3,3),...
</pre></div></div><div class="top"><p class="src"><a name="v:csimulateC" class="def">csimulateC</a> ::  <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk a b -&gt; [a] -&gt; [b] <a href="src/CLaSH-Prelude-Explicit.html#csimulateC" class="link">Source</a></p><div class="doc"><p>Simulate a <code>Comp</code>onent given a list of samples</p><pre> clk100 = Clock d100
&gt;&gt; csimulateC (cregisterC clk100 8) [1, 2, 3, ...</pre><p>[8, 1, 2, 3, ...</p></div></div><h1 id="g:3">BlockRAM primitives</h1><div class="top"><p class="src"><a name="v:cblockRam" class="def">cblockRam</a> <a href="src/CLaSH-Prelude-Explicit.html#cblockRam" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> n m a clk . (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> n, <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> m, <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a, <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p><code><a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a></code> to synchronize to</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Promoted-Nat.html#t:SNat">SNat</a> n</td><td class="doc"><p>Size <code>n</code> of the blockram</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> m)</td><td class="doc"><p>Write address <code>w</code></p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> m)</td><td class="doc"><p>Read address <code>r</code></p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a></td><td class="doc"><p>Write enable</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</td><td class="doc"><p>Value to write (at address <code>w</code>)</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</td><td class="doc"><p>Value of the <code>blockRAM</code> at address <code>r</code> from the previous clock cycle</p></td></tr></table></div><div class="doc"><p>Create a blockRAM with space for <code>n</code> elements</p><pre>clk100 = Clock d100

bram40 :: CSignal 100 (Unsigned 6) -&gt; CSignal 100 (Unsigned 6)
       -&gt; CSignal 100 Bool -&gt; CSignal 100 a -&gt; 100 CSignal a
bram40 = cblockRam clk100 d50</pre></div></div><div class="top"><p class="src"><a name="v:cblockRamPow2" class="def">cblockRamPow2</a> <a href="src/CLaSH-Prelude-Explicit.html#cblockRamPow2" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> n, <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> (2 <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-94-">^</a> n), <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a, <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p><code><a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a></code> to synchronize to</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Promoted-Nat.html#t:SNat">SNat</a> (2 <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-94-">^</a> n)</td><td class="doc"><p>Size <code>2^n</code> of the blockram</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> n)</td><td class="doc"><p>Write address <code>w</code></p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> n)</td><td class="doc"><p>Read address <code>r</code></p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a></td><td class="doc"><p>Write enable</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</td><td class="doc"><p>Value to write (at address <code>w</code>)</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</td><td class="doc"><p>Value of the <code>blockRAM</code> at address <code>r</code> from the previous clock cycle</p></td></tr></table></div><div class="doc"><p>Create a blockRAM with space for 2^<code>n</code> elements</p><pre>bram32 :: Signal (Unsigned 5) -&gt; Signal (Unsigned 5) -&gt; Signal Bool -&gt; Signal a -&gt; Signal a
bram32 = cblockRamPow2 d32</pre></div></div><div class="top"><p class="src"><a name="v:blockRamCC" class="def">blockRamCC</a> <a href="src/CLaSH-Prelude-Explicit.html#blockRamCC" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> n, <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> m, <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a, <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p><code><a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a></code> to synchronize to</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Promoted-Nat.html#t:SNat">SNat</a> n</td><td class="doc"><p>Size <code>n</code> of the blockram</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> m, <a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> m, <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>, a) a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Create a blockRAM with space for <code>n</code> elements</p><pre>clk100 = Clock 100

bramC40 :: CComp 100 (Unsigned 6, Unsigned 6, Bool, a) a
bramC40 = blockRamCC clk100 d50</pre></div></div><div class="top"><p class="src"><a name="v:blockRamPow2CC" class="def">blockRamPow2CC</a> <a href="src/CLaSH-Prelude-Explicit.html#blockRamPow2CC" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> n, <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> (2 <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-94-">^</a> n), <a href="CLaSH-Signal-Explicit.html#t:CPack">CPack</a> a, <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p><code><a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a></code> to synchronize to</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Promoted-Nat.html#t:SNat">SNat</a> (2 <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-94-">^</a> n)</td><td class="doc"><p>Size <code>2^n</code> of the blockram</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Prelude-Explicit.html#t:CComp">CComp</a> clk (<a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> n, <a href="CLaSH-Sized-Unsigned.html#t:Unsigned">Unsigned</a> n, <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a>, a) a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Create a blockRAM with space for 2^<code>n</code> elements</p><pre>clk100 = Clock d100

bramC32 :: CComp 100 (Unsigned 5, Unsigned 5, Bool, a) a
bramC32 = blockRamPow2CC clk100 d32</pre></div></div><h1 id="g:4">Utility functions</h1><div class="top"><p class="src"><a name="v:cwindow" class="def">cwindow</a> <a href="src/CLaSH-Prelude-Explicit.html#cwindow" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> (n <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1), <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p>Clock to which the incoming signal is synchronized</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</td><td class="doc"><p>Signal to create a window over</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a> ((n <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1) <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1) (<a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a)</td><td class="doc"><p>Window of at least size 2</p></td></tr></table></div><div class="doc"><p>Give a window over a <code><a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a></code></p><pre>window4 :: Signal Int -&gt; Vec 4 (Signal Int)
window4 = window</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>csimulateP window4 [1,2,3,4,5,...
</code></strong>[&lt;1,0,0,0&gt;, &lt;2,1,0,0&gt;, &lt;3,2,1,0&gt;, &lt;4,3,2,1&gt;, &lt;5,4,3,2&gt;,...
</pre></div></div><div class="top"><p class="src"><a name="v:cwindowD" class="def">cwindowD</a> <a href="src/CLaSH-Prelude-Explicit.html#cwindowD" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> (n <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1), <a href="http://hackage.haskell.org/package/data-default/docs/Data-Default.html#t:Default">Default</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p>Clock to which the incoming signal is synchronized</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</td><td class="doc"><p>Signal to create a window over</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a> (n <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:-43-">+</a> 1) (<a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a)</td><td class="doc"><p>Window of at least size 1</p></td></tr></table></div><div class="doc"><p>Give a delayed window over a <code><a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a></code></p><pre>windowD3 :: Signal Int -&gt; Vec 3 (Signal Int)
windowD3 = windowD</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>csimulateP windowD3 [1,2,3,4,...
</code></strong>[&lt;0,0,0&gt;, &lt;1,0,0&gt;, &lt;2,1,0&gt;, &lt;3,2,1&gt;, &lt;4,3,2&gt;,...
</pre></div></div><h1 id="g:5">Testbench functions</h1><div class="top"><p class="src"><a name="v:csassert" class="def">csassert</a> <a href="src/CLaSH-Prelude-Explicit.html#csassert" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/package/base/docs/Text-Show.html#t:Show">Show</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t a</td><td class="doc"><p>Checked value</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t a</td><td class="doc"><p>Expected value</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t b</td><td class="doc"><p>Return valued</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> t b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Compares the first two arguments for equality and logs a warning when they
 are not equal. The second argument is considered the expected value. This
 function simply returns the third argument unaltered as its result. This
 function is used by <code><a href="CLaSH-Prelude-Explicit.html#v:coutputVerifier">coutputVerifier</a></code>.</p><p>This function is translated to the following VHDL:</p><pre>csassert_block : block
begin
  -- pragma translate_off
  process(clk_t,reset_t,arg0,arg1) is
  begin
    if (rising_edge(clk_t) or rising_edge(reset_t)) then
      assert (arg0 = arg1) report (&quot;expected: &quot; &amp; to_string (arg1) &amp; \&quot;, actual: \&quot; &amp; to_string (arg0)) severity error;
    end if;
  end process;
  -- pragma translate_on
  result &lt;= arg2;
end block;</pre><p>And can, due to the pragmas, be used in synthesizable designs</p></div></div><div class="top"><p class="src"><a name="v:cstimuliGenerator" class="def">cstimuliGenerator</a> <a href="src/CLaSH-Prelude-Explicit.html#cstimuliGenerator" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> l clk a . <a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> l</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a> l a</td><td class="doc"><p>Samples to generate</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p>Clock to synchronize the output signal to</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</td><td class="doc"><p>Signal of given samples</p></td></tr></table></div><div class="doc"><p>To be used as a one of the functions to create the &quot;magical&quot; <code>testInput</code>
 value, which the C&#955;aSH compilers looks for to create the stimulus generator
 for the generated VHDL testbench.</p><p>Example:</p><pre>clk2 = Clock d2

testInput :: CSignal 2 Int
testInput = cstimuliGenerator $(v [(1::Int),3..21]) clk2</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>csample testInput
</code></strong>[1,3,5,7,9,11,13,15,17,19,21,21,21,...
</pre></div></div><div class="top"><p class="src"><a name="v:coutputVerifier" class="def">coutputVerifier</a> <a href="src/CLaSH-Prelude-Explicit.html#coutputVerifier" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> l clk a . (<a href="http://hackage.haskell.org/package/base/docs/GHC-TypeLits.html#t:KnownNat">KnownNat</a> l, <a href="http://hackage.haskell.org/package/base/docs/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/package/base/docs/Text-Show.html#t:Show">Show</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a> l a</td><td class="doc"><p>Samples to compare with</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:Clock">Clock</a> clk</td><td class="doc"><p>Clock the input signal is synchronized to</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk a</td><td class="doc"><p>Signal to verify</p></td></tr><tr><td class="src">-&gt; <a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a> clk <a href="http://hackage.haskell.org/package/base/docs/Data-Bool.html#t:Bool">Bool</a></td><td class="doc"><p>Indicator that all samples are verified</p></td></tr></table></div><div class="doc"><p>To be used as a functions to generate the &quot;magical&quot; <code>expectedOutput</code>
 function, which the C&#955;aSH compilers looks for to create the signal verifier
 for the generated VHDL testbench.</p><p>Example:</p><pre>clk7 = Clock d7

expectedOutput :: CSignal 7 Int -&gt; CSignal 7 Bool
expectedOutput = coutputVerifier $(v ([70,99,2,3,4,5,7,8,9,10]::[Int])) clk7</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>csample (expectedOutput (cfromList ([0..10] ++ [10,10,10])))
</code></strong>[
expected value: 70, not equal to actual value: 0
False,
expected value: 99, not equal to actual value: 1
False,False,False,False,False,
expected value: 7, not equal to actual value: 6
False,
expected value: 8, not equal to actual value: 7
False,
expected value: 9, not equal to actual value: 8
False,
expected value: 10, not equal to actual value: 9
False,True,True,...
</pre></div></div><h1 id="g:6">Exported modules</h1><h2 id="g:7">Explicitly clocked synchronous signals</h2><div class="top"><p class="src">module <a href="CLaSH-Signal-Explicit.html">CLaSH.Signal.Explicit</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.0</p></div></body></html>