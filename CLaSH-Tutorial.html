<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CLaSH.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_CLaSH-Tutorial.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/CLaSH-Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">clash-prelude-0.5: CAES Language for Synchronous Hardware - Prelude library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">CLaSH.Tutorial</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Introduction</a></li><li><a href="#g:2">MAC Example</a></li><li><a href="#g:3">Conclusion</a></li><li><a href="#g:4">Errors and their solutions</a></li><li><a href="#g:5">Haskell stuff that the C&#955;aSH compiler does not support</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A little tutorial to C&#955;aSH</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"></ul></div><div id="interface"><h1 id="g:1">Introduction</h1><div class="doc empty">&nbsp;</div><h1 id="g:2">MAC Example</h1><div class="doc empty">&nbsp;</div><h1 id="g:3">Conclusion</h1><div class="doc empty">&nbsp;</div><h1 id="g:4">Errors and their solutions</h1><div class="doc"><ul><li><strong>Type error: Couldn't match expected type &#8216;Signal (a,b)&#8217; with actual type</strong>
  <strong>&#8216;(Signal a, Signal b)&#8217;</strong>:<p>Signals of product types and product types (to which tuples belong) of
signals are <strong>isomorphic</strong>, but not (structurally) equal. Use the
<code><a href="CLaSH-Signal-Implicit.html#v:pack">pack</a></code> function to convert from a product type to the
signal type. So if your code which gives the error looks like:</p><pre>... = f a b (c,d)
</pre><p>add the <code><a href="CLaSH-Signal-Implicit.html#v:pack">pack</a></code> function like so:</p><pre>... = f a b (pack (c,d))
</pre><p>Product types supported by <code><a href="CLaSH-Signal-Implicit.html#v:pack">pack</a></code> are:</p><ul><li>All tuples until and including 8-tuples</li><li>The <code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor type</li></ul><p>NB: Use <code><a href="CLaSH-Signal-Explicit.html#v:cpack">cpack</a></code> when you are using explicitly
clocked <code><a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a></code>s</p></li><li><strong>Type error: Couldn't match expected type &#8216;(Signal a, Signal b)&#8217; with</strong>
  <strong> actual type &#8216;Signal (a,b)&#8217;</strong>:<p>Product types (to which tuples belong) of signals and signals of product
types are <strong>isomorphic</strong>, but not (structurally) equal. Use the
<code><a href="CLaSH-Signal-Implicit.html#v:unpack">unpack</a></code> function to convert from a signal type to the
product type. So if your code which gives the error looks like:</p><pre>(c,d) = f a b
</pre><p>add the <code><a href="CLaSH-Signal-Implicit.html#v:unpack">unpack</a></code> function like so:</p><pre>(c,d) = unpack (f a b)
</pre><p>Product types supported by <code><a href="CLaSH-Signal-Implicit.html#v:unpack">unpack</a></code> are:</p><ul><li>All tuples until and including 8-tuples</li><li>The <code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor type</li></ul><p>NB: Use <code><a href="CLaSH-Signal-Explicit.html#v:cunpack">cunpack</a></code> when you are using explicitly
clocked <code><a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a></code>s</p></li><li><strong>CLaSH.Normalize(94): Expr belonging to bndr: &lt;FUNCTION&gt; remains</strong>
  <strong>recursive after normalization</strong>:<ul><li>If you actually wrote a recursive function, rewrite it to a non-recursive
  one :-)</li><li>You defined a recursively defined value, but left it polymorphic:</li></ul><pre>topEntity x y = acc
where
  acc = register 3 (x*y + acc)
</pre><p>The above function, works for any number-like type. This means that <code>acc</code> is
a recursively defined <strong>polymorphic</strong> value. Adding a monomorphic type
annotation makes the error go away.</p><pre>topEntity :: Signal (Signed 8) -&gt; Signal (Signed 8) -&gt; Signal (Signed 8)
topEntity x y = acc
where
  acc = register 3 (x*y + acc)
</pre></li><li><strong>CLaSH.Normalize.Transformations(155): InlineNonRep: &lt;FUNCTION&gt; already</strong>
  <strong>inlined 100 times in:&lt;FUNCTION&gt;, &lt;TYPE&gt;</strong>:<p>You left the <code>topEntity</code> function polymorphic or higher-order: use
<code>:t topEntity</code> to check if the type is indeed polymorphic or higher-order.
If it is, add a monomorphic type signature, and / or supply higher-order
arguments.</p></li><li><strong>Can't make testbench for: &lt;LONG_VERBATIM_COMPONENT_DESCRIPTION&gt;</strong>:<ul><li>Don't worry, it's actually only a warning.</li><li>The <code>topEntity</code> function does <strong>not</strong> have exactly 1 argument. If your
  <code>topEntity</code> has no arguments, you're out of luck for now. If it has
  multiple arguments, consider bundling them in a tuple.</li></ul></li></ul></div><h1 id="g:5">Haskell stuff that the C&#955;aSH compiler does not support</h1><div class="doc"><p>Here is a list of Haskell features which the C&#955;aSH compiler cannot synthesize
to VHDL (for now):</p><dl><dt><code>Recursive functions</code></dt><dd><p>Although it seems rather bad that a compiler for a
functional language does not support recursion, this bug/feature of the
C&#955;aSH compiler is amortized by the builtin knowledge of all the functions
listed in <a href="CLaSH-Sized-Vector.html">CLaSH.Sized.Vector</a>. And as you saw in this tutorial, the
higher-order functions of <a href="CLaSH-Sized-Vector.html">CLaSH.Sized.Vector</a> can cope with many of the
recursive design patterns found in circuit design.</p><p>Also note that although recursive functions are not supported, recursively
(tying-the-knot) defined values are supported (as long as these values do
not have a function type). An example that uses recursively defined values
is the following function that performs one iteration of bubble sort:</p><pre>sortVL xs = vmap fst sorted &lt;: (snd (vlast sorted))
 where
   lefts  = vhead xs :&gt; vmap snd (vinit sorted)
   rights = vtail xs
   sorted = vzipWith compareSwapL (lazyV lefts) rights
</pre><p>Where we can clearly see that <code>lefts</code> and <code>sorted</code> are defined in terms of
each other.</p></dd><dt><code>Recursive datatypes</code></dt><dd><p>The C&#955;aSH compiler needs to be able to determine a bit-size for any value
that will be represented in the eventual circuit. More specifically, we need
to know the maximum number of bits needed to represent a value. While this
is trivial for values of the elementary types, sum types, and product types,
putting a fixed upper bound on recursive types is not (always) feasible.
The only recursive type that is currently supported by the C&#955;aSH compiler
is the <code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor type, for which the compiler has
hard-coded knowledge.</p></dd><dt><code>GADT pattern matching</code></dt><dd><p>While pattern matching for regular ADTs is supported, pattern matching for
GADTs is <strong>not</strong>. The <code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor type, which is also a
GADT, is <strong>no</strong> exception! You can use the extraction and indexing functions
of <a href="CLaSH-Sized-Vector.html">CLaSH.Sized.Vector</a> to get access to individual ranges / elements of a
<code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor.</p></dd></dl></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.2</p></div></body></html>