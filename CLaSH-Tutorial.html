<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>CLaSH.Tutorial</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_CLaSH-Tutorial.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/CLaSH-Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">clash-prelude-0.5: CAES Language for Synchronous Hardware - Prelude library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">CLaSH.Tutorial</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Introduction</a></li><li><a href="#g:2">Installation</a></li><li><a href="#g:3">MAC Example</a></li><li><a href="#g:4">Conclusion</a></li><li><a href="#g:5">Errors and their solutions</a></li><li><a href="#g:6">Haskell stuff that the C&#955;aSH compiler does not support</a></li></ul></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"></ul></div><div id="interface"><h1 id="g:1">Introduction</h1><div class="doc"><p>C&#955;aSH (pronounced &#8216;clash&#8217;) is a functional hardware description language that
borrows both its syntax and semantics from the functional programming language
Haskell. The merits of using a functional language to describe hardware comes
from the fact that combinational circuits can be directly modeled as
mathematical functions and that functional languages lend themselves very well
at describing and (de-)composing mathematical functions.</p></div><h1 id="g:2">Installation</h1><div class="doc"><p>The C&#955;aSH compiler and Prelude library for circuit design only work with the
<a href="http://haskell.org/ghc">GHC</a> Haskell compiler version 7.8.1 and up.</p><ol><li>Install <strong>GHC (version 7.8.1 or higher)</strong><ul><li>Download and install <a href="http://www.haskell.org/ghc/download">GHC for your platform</a>.
  Unix user can use <code>./configure prefix=&lt;LOCATION&gt;</code> to set the installation
  location.</li><li>Make sure that the <code>bin</code> directory of <strong>GHC</strong> is in your <code>PATH</code>.</li></ul></li><li>Install <strong>Cabal</strong><ul><li>Windows:<ul><li>Download the binary for <a href="http://www.haskell.org/cabal/download.html">cabal-install</a></li><li>Put the binary in a location mentioned in your <code>PATH</code></li></ul></li><li>Unix:<ul><li>Download the sources for <a href="http://hackage.haskell.org/package/cabal-install">cabal-install</a></li><li>Unpack (<code>tar xf</code>) the archive and <code>cd</code> to the directory</li><li>Run <code>sh bootstrap.sh</code></li><li>Follow the instructions to add <code>cabal</code> to your <code>PATH</code></li></ul></li><li>Run <code>cabal update</code></li></ul></li><li>Install update <strong>RepLib</strong> library<ul><li>Download the sources for the modified <a href="https://www.dropbox.com/s/k1nfbqpzwbub0c1/RepLib-0.5.3.2.tar.gz">RepLib-0.5.3.2.tar.gz</a> library</li><li>Run <code>cabal install RepLib-0.5.3.2.tar.gz</code></li></ul></li><li>Install <strong>C&#955;aSH</strong><ul><li>Run <code>cabal install clash-ghc</code></li></ul></li><li>Verify that everything is working by:<ul><li>Downloading the <a href="https://raw.github.com/christiaanb/clash2/master/examples/FIR.hs">Fir.hs</a> example</li><li>Run <code>clash --interactive FIR.hs</code></li><li>Execute, in the interpreter, the <code>:vhdl</code> command.</li><li>Exit the interpreter using <code>:q</code></li><li>Examin the VHDL code in the <code>vhdl</code> directory</li></ul></li></ol></div><h1 id="g:3">MAC Example</h1><div class="doc empty">&nbsp;</div><h1 id="g:4">Conclusion</h1><div class="doc empty">&nbsp;</div><h1 id="g:5">Errors and their solutions</h1><div class="doc"><ul><li><strong>Type error: Couldn't match expected type &#8216;Signal (a,b)&#8217; with actual type</strong>
  <strong>&#8216;(Signal a, Signal b)&#8217;</strong>:<p>Signals of product types and product types (to which tuples belong) of
signals are <strong>isomorphic</strong>, but not (structurally) equal. Use the
<code><a href="CLaSH-Signal-Implicit.html#v:pack">pack</a></code> function to convert from a product type to the
signal type. So if your code which gives the error looks like:</p><pre>... = f a b (c,d)
</pre><p>add the <code><a href="CLaSH-Signal-Implicit.html#v:pack">pack</a></code> function like so:</p><pre>... = f a b (pack (c,d))
</pre><p>Product types supported by <code><a href="CLaSH-Signal-Implicit.html#v:pack">pack</a></code> are:</p><ul><li>All tuples until and including 8-tuples</li><li>The <code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor type</li></ul><p>NB: Use <code><a href="CLaSH-Signal-Explicit.html#v:cpack">cpack</a></code> when you are using explicitly
clocked <code><a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a></code>s</p></li><li><strong>Type error: Couldn't match expected type &#8216;(Signal a, Signal b)&#8217; with</strong>
  <strong> actual type &#8216;Signal (a,b)&#8217;</strong>:<p>Product types (to which tuples belong) of signals and signals of product
types are <strong>isomorphic</strong>, but not (structurally) equal. Use the
<code><a href="CLaSH-Signal-Implicit.html#v:unpack">unpack</a></code> function to convert from a signal type to the
product type. So if your code which gives the error looks like:</p><pre>(c,d) = f a b
</pre><p>add the <code><a href="CLaSH-Signal-Implicit.html#v:unpack">unpack</a></code> function like so:</p><pre>(c,d) = unpack (f a b)
</pre><p>Product types supported by <code><a href="CLaSH-Signal-Implicit.html#v:unpack">unpack</a></code> are:</p><ul><li>All tuples until and including 8-tuples</li><li>The <code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor type</li></ul><p>NB: Use <code><a href="CLaSH-Signal-Explicit.html#v:cunpack">cunpack</a></code> when you are using explicitly
clocked <code><a href="CLaSH-Signal-Explicit.html#t:CSignal">CSignal</a></code>s</p></li><li><strong>CLaSH.Normalize(94): Expr belonging to bndr: &lt;FUNCTION&gt; remains</strong>
  <strong>recursive after normalization</strong>:<ul><li>If you actually wrote a recursive function, rewrite it to a non-recursive
  one :-)</li><li>You defined a recursively defined value, but left it polymorphic:</li></ul><pre>topEntity x y = acc
where
  acc = register 3 (x*y + acc)
</pre><p>The above function, works for any number-like type. This means that <code>acc</code> is
a recursively defined <strong>polymorphic</strong> value. Adding a monomorphic type
annotation makes the error go away.</p><pre>topEntity :: Signal (Signed 8) -&gt; Signal (Signed 8) -&gt; Signal (Signed 8)
topEntity x y = acc
where
  acc = register 3 (x*y + acc)
</pre></li><li><strong>CLaSH.Normalize.Transformations(155): InlineNonRep: &lt;FUNCTION&gt; already</strong>
  <strong>inlined 100 times in:&lt;FUNCTION&gt;, &lt;TYPE&gt;</strong>:<p>You left the <code>topEntity</code> function polymorphic or higher-order: use
<code>:t topEntity</code> to check if the type is indeed polymorphic or higher-order.
If it is, add a monomorphic type signature, and / or supply higher-order
arguments.</p></li><li><strong>Can't make testbench for: &lt;LONG_VERBATIM_COMPONENT_DESCRIPTION&gt;</strong>:<ul><li>Don't worry, it's actually only a warning.</li><li>The <code>topEntity</code> function does <strong>not</strong> have exactly 1 argument. If your
  <code>topEntity</code> has no arguments, you're out of luck for now. If it has
  multiple arguments, consider bundling them in a tuple.</li></ul></li></ul></div><h1 id="g:6">Haskell stuff that the C&#955;aSH compiler does not support</h1><div class="doc"><p><a name="unsupported"></a>
Here is a list of Haskell features which the C&#955;aSH compiler cannot synthesize
to VHDL (for now):</p><dl><dt><code>Recursive functions</code></dt><dd><p>Although it seems rather bad that a compiler for a
functional language does not support recursion, this bug/feature of the
C&#955;aSH compiler is amortized by the builtin knowledge of all the functions
listed in <a href="CLaSH-Sized-Vector.html">CLaSH.Sized.Vector</a>. And as you saw in this tutorial, the
higher-order functions of <a href="CLaSH-Sized-Vector.html">CLaSH.Sized.Vector</a> can cope with many of the
recursive design patterns found in circuit design.</p><p>Also note that although recursive functions are not supported, recursively
(tying-the-knot) defined values are supported (as long as these values do
not have a function type). An example that uses recursively defined values
is the following function that performs one iteration of bubble sort:</p><pre>sortVL xs = vmap fst sorted &lt;: (snd (vlast sorted))
 where
   lefts  = vhead xs :&gt; vmap snd (vinit sorted)
   rights = vtail xs
   sorted = vzipWith compareSwapL (lazyV lefts) rights
</pre><p>Where we can clearly see that <code>lefts</code> and <code>sorted</code> are defined in terms of
each other.</p></dd><dt><code>Recursive datatypes</code></dt><dd><p>The C&#955;aSH compiler needs to be able to determine a bit-size for any value
that will be represented in the eventual circuit. More specifically, we need
to know the maximum number of bits needed to represent a value. While this
is trivial for values of the elementary types, sum types, and product types,
putting a fixed upper bound on recursive types is not (always) feasible.
The only recursive type that is currently supported by the C&#955;aSH compiler
is the <code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor type, for which the compiler has
hard-coded knowledge.</p></dd><dt><code>GADT pattern matching</code></dt><dd><p>While pattern matching for regular ADTs is supported, pattern matching for
GADTs is <strong>not</strong>. The <code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor type, which is also a
GADT, is <strong>no</strong> exception! You can use the extraction and indexing functions
of <a href="CLaSH-Sized-Vector.html">CLaSH.Sized.Vector</a> to get access to individual ranges / elements of a
<code><a href="CLaSH-Sized-Vector.html#t:Vec">Vec</a></code>tor.</p></dd></dl></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.2</p></div></body></html>