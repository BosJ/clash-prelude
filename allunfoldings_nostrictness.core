Building clash-prelude-0.5...
Preprocessing library clash-prelude-0.5...
[ 1 of 16] Compiling CLaSH.Promoted.Ord ( src/CLaSH/Promoted/Ord.hs, dist/build/CLaSH/Promoted/Ord.o )
[ 2 of 16] Compiling CLaSH.Promoted.Nat ( src/CLaSH/Promoted/Nat.hs, dist/build/CLaSH/Promoted/Nat.o )
[ 3 of 16] Compiling CLaSH.Promoted.Nat.TH ( src/CLaSH/Promoted/Nat/TH.hs, dist/build/CLaSH/Promoted/Nat/TH.o )
[ 4 of 16] Compiling CLaSH.Promoted.Nat.Literals ( src/CLaSH/Promoted/Nat/Literals.hs, dist/build/CLaSH/Promoted/Nat/Literals.o )
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
Loading package array-0.5.0.0 ... linking ... done.
Loading package deepseq-1.3.0.2 ... linking ... done.
Loading package containers-0.5.4.0 ... linking ... done.
Loading package pretty-1.1.1.1 ... linking ... done.
Loading package template-haskell ... linking ... done.
Loading package th-lift-0.6.1 ... linking ... done.
Loading package data-default-class-0.0.1 ... linking ... done.
Loading package data-default-instances-base-0.0.1 ... linking ... done.
Loading package data-default-instances-containers-0.0.1 ... linking ... done.
Loading package dlist-0.6.0.1 ... linking ... done.
Loading package data-default-instances-dlist-0.0.1 ... linking ... done.
Loading package old-locale-1.0.0.6 ... linking ... done.
Loading package data-default-instances-old-locale-0.0.1 ... linking ... done.
Loading package data-default-0.5.3 ... linking ... done.
[ 5 of 16] Compiling CLaSH.Signal.Types ( src/CLaSH/Signal/Types.hs, dist/build/CLaSH/Signal/Types.o )
[ 6 of 16] Compiling CLaSH.Class.Num  ( src/CLaSH/Class/Num.hs, dist/build/CLaSH/Class/Num.o )
[ 7 of 16] Compiling CLaSH.Sized.Vector ( src/CLaSH/Sized/Vector.hs, dist/build/CLaSH/Sized/Vector.o )
[ 8 of 16] Compiling CLaSH.Bit        ( src/CLaSH/Bit.hs, dist/build/CLaSH/Bit.o )
[ 9 of 16] Compiling CLaSH.Class.BitVector ( src/CLaSH/Class/BitVector.hs, dist/build/CLaSH/Class/BitVector.o )
[10 of 16] Compiling CLaSH.Sized.Signed ( src/CLaSH/Sized/Signed.hs, dist/build/CLaSH/Sized/Signed.o )
[11 of 16] Compiling CLaSH.Sized.Unsigned ( src/CLaSH/Sized/Unsigned.hs, dist/build/CLaSH/Sized/Unsigned.o )
[12 of 16] Compiling CLaSH.Signal.Implicit ( src/CLaSH/Signal/Implicit.hs, dist/build/CLaSH/Signal/Implicit.o )
compile: input file src/CLaSH/Sized/Fixed.hs
*** Checking old interface for clash-prelude-0.5:CLaSH.Sized.Fixed:
[13 of 16] Compiling CLaSH.Sized.Fixed ( src/CLaSH/Sized/Fixed.hs, dist/build/CLaSH/Sized/Fixed.o )
*** Parser:
*** Renamer/typechecker:
*** Desugar:

==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 2,082, types: 11,982, coercions: 377}

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.fLit =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      truncated_auGG :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      truncated_auGG =
        GHC.Real.truncate
          @ GHC.Types.Double
          GHC.Float.$fRealFracDouble
          @ GHC.Integer.Type.Integer
          GHC.Real.$fIntegralInteger
          (GHC.Num.*
             @ GHC.Types.Double
             GHC.Float.$fNumDouble
             a_auGC
             (GHC.Real.^
                @ GHC.Types.Double
                @ GHC.Integer.Type.Integer
                GHC.Float.$fNumDouble
                GHC.Real.$fIntegralInteger
                (GHC.Types.D# 2.0)
                (GHC.TypeLits.natVal
                   @ frac_avhM
                   @ Data.Proxy.Proxy
                   $dKnownNat_avlM
                   (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avhM)))) } in
    let {
      rMin_auGE :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      rMin_auGE =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    let {
      rMax_auGD :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      rMax_auGD =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    Language.Haskell.TH.Syntax.unsafeTExpCoerce
      @ (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)
      (Language.Haskell.TH.Lib.appE
         (Language.Haskell.TH.Lib.conE
            (Language.Haskell.TH.Syntax.mkNameG_d
               (GHC.CString.unpackCString# "clash-prelude-0.5"#)
               (GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#)
               (GHC.CString.unpackCString# "Fixed"#)))
         (Language.Haskell.TH.Lib.appE
            (Language.Haskell.TH.Lib.varE
               (Language.Haskell.TH.Syntax.mkNameG_v
                  (GHC.CString.unpackCString# "base"#)
                  (GHC.CString.unpackCString# "GHC.Num"#)
                  (GHC.CString.unpackCString# "fromInteger"#)))
            (Language.Haskell.TH.Syntax.lift
               @ GHC.Integer.Type.Integer
               Language.Haskell.TH.Syntax.$fLiftInteger
               (case GHC.Classes.>
                       @ GHC.Integer.Type.Integer
                       GHC.Integer.Type.$fOrdInteger
                       truncated_auGG
                       rMax_auGD
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Classes.<
                           @ GHC.Integer.Type.Integer
                           GHC.Integer.Type.$fOrdInteger
                           truncated_auGG
                           rMin_auGE
                    of _ [Occ=Dead] {
                      GHC.Types.False -> truncated_auGG;
                      GHC.Types.True -> rMin_auGE
                    };
                  GHC.Types.True -> rMax_auGD
                }))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz) ->
    let {
      $dBounded_avIX :: GHC.Enum.Bounded (rep_aviy n_aviz)
      [LclId, Str=DmdType]
      $dBounded_avIX =
        case tup_avmQ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B9, _ [Occ=Dead]) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_avIV :: GHC.TypeLits.KnownNat n_aviz
      [LclId, Str=DmdType]
      $dKnownNat_avIV =
        case tup_avmQ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B7, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B7
        } } in
    let {
      cobox_avIU
        :: CLaSH.Class.BitVector.BitSize
             (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avIU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B6
        } } in
    let {
      cobox_avIT
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId, Str=DmdType]
      cobox_avIT =
        case tup_avmQ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B5
        } } in
    let {
      $dBitVector_avIR
        :: CLaSH.Class.BitVector.BitVector (rep_aviy n_aviz)
      [LclId, Str=DmdType]
      $dBitVector_avIR =
        case tup_avmQ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      cobox_avIQ
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avIQ =
        case tup_avmQ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B2
        } } in
    let {
      cobox_avnI
        :: n_aviz ~ CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)
      [LclId, Str=DmdType]
      cobox_avnI =
        case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ n_aviz
          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
          @~ (Sym cobox_dw7c)
        } } in
    let {
      $dKnownNat_avnH
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
      [LclId, Str=DmdType]
      $dKnownNat_avnH =
        case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
        $dKnownNat_avIV
        `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                :: GHC.TypeLits.KnownNat n_aviz
                     ~#
                   GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
        } } in
    let {
      cobox_avnx
        :: n_aviz ~ CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)
      [LclId, Str=DmdType]
      cobox_avnx =
        case case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7m ->
             GHC.Types.Eq#
               @ GHC.TypeLits.Nat
               @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
               @ n_aviz
               @~ cobox_dw7m
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ n_aviz
          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
          @~ (Sym cobox_dw7a)
        } } in
    let {
      $dKnownNat_avnw
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
      [LclId, Str=DmdType]
      $dKnownNat_avnw =
        case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
        $dKnownNat_avIV
        `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                :: GHC.TypeLits.KnownNat n_aviz
                     ~#
                   GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
        } } in
    let {
      $dBits_avnl :: Data.Bits.Bits (rep_aviy (n_aviz GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBits_avnl =
        case tup_avmQ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba) ->
        tpl_Ba
        } } in
    let {
      cobox_avnj :: (1 GHC.TypeLits.<=? n_aviz) ~ 'GHC.Types.True
      [LclId, Str=DmdType]
      cobox_avnj =
        case case tup_avmQ
             of _ [Occ=Dead]
             { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B1
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw77 ->
        GHC.Types.Eq#
          @ GHC.Types.Bool
          @ (1 GHC.TypeLits.<=? n_aviz)
          @ 'GHC.Types.True
          @~ cobox_dw77
        } } in
    let {
      cobox_avnf
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
           ~ CLaSH.Sized.Vector.Vec
               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      cobox_avnf =
        case case case cobox_avIQ
                  of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7e ->
                  GHC.Types.Eq#
                    @ GHC.TypeLits.Nat
                    @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                    @ (n_aviz GHC.TypeLits.+ 2)
                    @~ cobox_dw7e
                  }
             of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
             GHC.Types.Eq#
               @ GHC.TypeLits.Nat
               @ (n_aviz GHC.TypeLits.+ 2)
               @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
               @~ (Sym cobox_dw7d)
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw75 ->
        GHC.Types.Eq#
          @ *
          @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
          @ (CLaSH.Sized.Vector.Vec
               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
          @~ (CLaSH.Sized.Vector.Vec cobox_dw75 <CLaSH.Bit.Bit>_N)_N
        } } in
    let {
      cobox_avn8
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
           ~ CLaSH.Sized.Vector.Vec
               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      cobox_avn8 =
        case case case cobox_avIQ
                  of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7h ->
                  GHC.Types.Eq#
                    @ GHC.TypeLits.Nat
                    @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                    @ (n_aviz GHC.TypeLits.+ 2)
                    @~ cobox_dw7h
                  }
             of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7g ->
             GHC.Types.Eq#
               @ GHC.TypeLits.Nat
               @ (n_aviz GHC.TypeLits.+ 2)
               @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
               @~ (Sym cobox_dw7g)
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw73 ->
        GHC.Types.Eq#
          @ *
          @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
          @ (CLaSH.Sized.Vector.Vec
               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
          @~ (CLaSH.Sized.Vector.Vec cobox_dw73 <CLaSH.Bit.Bit>_N)_N
        } } in
    let {
      cobox_avn1
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
           ~ CLaSH.Sized.Vector.Vec
               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      cobox_avn1 =
        case case case cobox_avIQ
                  of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7k ->
                  GHC.Types.Eq#
                    @ GHC.TypeLits.Nat
                    @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                    @ (n_aviz GHC.TypeLits.+ 2)
                    @~ cobox_dw7k
                  }
             of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
             GHC.Types.Eq#
               @ GHC.TypeLits.Nat
               @ (n_aviz GHC.TypeLits.+ 2)
               @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
               @~ (Sym cobox_dw7j)
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw71 ->
        GHC.Types.Eq#
          @ *
          @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
          @ (CLaSH.Sized.Vector.Vec
               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
          @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
        } } in
    let {
      cobox_avmW
        :: CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize
                (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
             CLaSH.Bit.Bit
           ~ CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      cobox_avmW =
        case case cobox_avIU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7o ->
             GHC.Types.Eq#
               @ GHC.TypeLits.Nat
               @ (CLaSH.Class.BitVector.BitSize
                    (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
               @ (n_aviz GHC.TypeLits.+ 2)
               @~ cobox_dw7o
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
        GHC.Types.Eq#
          @ *
          @ (CLaSH.Sized.Vector.Vec
               (CLaSH.Class.BitVector.BitSize
                  (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
               CLaSH.Bit.Bit)
          @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
          @~ (CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_N)_N
        } } in
    let {
      $dKnownNat_avmV
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize
                (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
      [LclId, Str=DmdType]
      $dKnownNat_avmV =
        case cobox_avIU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Y ->
        (case tup_avmQ
         of _ [Occ=Dead]
         { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead]) ->
         tpl_B8
         })
        `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Y))_R
                :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                     ~#
                   GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2))))
        } } in
    let {
      $dBitVector_avmU
        :: CLaSH.Class.BitVector.BitVector
             (rep_aviy (n_aviz GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBitVector_avmU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    \ (rep_auGw :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
      let {
        repBV_auGx
          :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
        [LclId, Str=DmdType]
        repBV_auGx =
          case cobox_avmW of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6X ->
          (CLaSH.Class.BitVector.toBV
             @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
             $dBitVector_avmU
             $dKnownNat_avmV
             rep_auGw)
          `cast` (Sub cobox_dw6X
                  :: CLaSH.Sized.Vector.Vec
                       (CLaSH.Class.BitVector.BitSize
                          (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                       CLaSH.Bit.Bit
                       ~#
                     CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
          } } in
      let {
        cS_auGy :: CLaSH.Bit.Bit
        [LclId, Str=DmdType]
        cS_auGy =
          CLaSH.Sized.Vector.vhead
            @ (n_aviz GHC.TypeLits.+ 1)
            @ CLaSH.Bit.Bit
            (case cobox_avn1 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6W ->
             repBV_auGx
             `cast` (Sub cobox_dw6W
                     :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
             }) } in
      let {
        s_auGA :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
        [LclId, Str=DmdType]
        s_auGA =
          CLaSH.Sized.Vector.vtail
            @ n_aviz
            @ CLaSH.Bit.Bit
            (CLaSH.Sized.Vector.vtail
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case cobox_avnf of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvY9 ->
                repBV_auGx
                `cast` (Sub cobox_dvY9
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })) } in
      case Data.Bits.isSigned
             @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) $dBits_avnl rep_auGw
      of _ [Occ=Dead] {
        GHC.Types.False ->
          let {
            fail_dvY5 :: GHC.Prim.Void# -> rep_aviy n_aviz
            [LclId, Str=DmdType]
            fail_dvY5 =
              \ _ [Occ=Dead, OS=OneShot] ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  $dBitVector_avIR
                  $dKnownNat_avnH
                  (case cobox_avnI of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6T ->
                   s_auGA
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   }) } in
          let {
            ds_dvY4 :: CLaSH.Bit.Bit
            [LclId, Str=DmdType]
            ds_dvY4 =
              CLaSH.Sized.Vector.vhead
                @ n_aviz
                @ CLaSH.Bit.Bit
                (CLaSH.Sized.Vector.vtail
                   @ (n_aviz GHC.TypeLits.+ 1)
                   @ CLaSH.Bit.Bit
                   (case cobox_avn8 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvYc ->
                    repBV_auGx
                    `cast` (Sub cobox_dvYc
                            :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                    })) } in
          case cS_auGy of _ [Occ=Dead] {
            CLaSH.Bit.H ->
              case ds_dvY4 of _ [Occ=Dead] {
                __DEFAULT -> fail_dvY5 GHC.Prim.void#;
                CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) $dBounded_avIX
              };
            CLaSH.Bit.L ->
              case ds_dvY4 of _ [Occ=Dead] {
                __DEFAULT -> fail_dvY5 GHC.Prim.void#;
                CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) $dBounded_avIX
              }
          };
        GHC.Types.True ->
          let {
            fail_dvXZ :: GHC.Prim.Void# -> rep_aviy n_aviz
            [LclId, Str=DmdType]
            fail_dvXZ =
              \ _ [Occ=Dead, OS=OneShot] ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  $dBitVector_avIR
                  $dKnownNat_avnw
                  (case cobox_avnx of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6S ->
                   s_auGA
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   }) } in
          let {
            ds_dvXY :: CLaSH.Bit.Bit
            [LclId, Str=DmdType]
            ds_dvXY =
              CLaSH.Sized.Vector.vhead'
                @ n_aviz @ CLaSH.Bit.Bit cobox_avnj s_auGA } in
          case cS_auGy of _ [Occ=Dead] {
            CLaSH.Bit.H ->
              case ds_dvXY of _ [Occ=Dead] {
                __DEFAULT -> fail_dvXZ GHC.Prim.void#;
                CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) $dBounded_avIX
              };
            CLaSH.Bit.L ->
              case ds_dvXY of _ [Occ=Dead] {
                __DEFAULT -> fail_dvXZ GHC.Prim.void#;
                CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) $dBounded_avIX
              }
          }
      }

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju) ->
    let {
      $dBits_avJC :: Data.Bits.Bits (rep_avjs size2_avju)
      [LclId, Str=DmdType]
      $dBits_avJC =
        case tup_avnK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B9, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_avJB :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_avJB =
        case tup_avnK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dKnownNat_avJA :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat_avJA =
        case tup_avnK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B7, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B7
        } } in
    let {
      $dResize_avJz :: CLaSH.Class.Num.Resize rep_avjs
      [LclId, Str=DmdType]
      $dResize_avJz =
        case tup_avnK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B6
        } } in
    let {
      $dBits_avJy :: Data.Bits.Bits (rep_avjs size1_avjt)
      [LclId, Str=DmdType]
      $dBits_avJy =
        case tup_avnK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B5
        } } in
    let {
      $dEq_avJH :: GHC.Classes.Eq (rep_avjs size1_avjt)
      [LclId, Str=DmdType]
      $dEq_avJH =
        Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_avJy } in
    let {
      $dNum_avJx :: GHC.Num.Num (rep_avjs size1_avjt)
      [LclId, Str=DmdType]
      $dNum_avJx =
        case tup_avnK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      $dOrd_avJw :: GHC.Classes.Ord (rep_avjs size1_avjt)
      [LclId, Str=DmdType]
      $dOrd_avJw =
        case tup_avnK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dBounded_avJu :: GHC.Enum.Bounded (rep_avjs size2_avju)
      [LclId, Str=DmdType]
      $dBounded_avJu =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dKnownNat_avo2 :: GHC.TypeLits.KnownNat frac1_avjq
      [LclId, Str=DmdType]
      $dKnownNat_avo2 =
        case tup_avnK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bb, _ [Occ=Dead]) ->
        tpl_Bb
        } } in
    let {
      $dKnownNat_avnR :: GHC.TypeLits.KnownNat frac2_avjr
      [LclId, Str=DmdType]
      $dKnownNat_avnR =
        case tup_avnK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_Ba
        } } in
    \ (ds_dvYW
         :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
      let {
        resFracSZ_auGl :: GHC.Types.Int
        [LclId, Str=DmdType]
        resFracSZ_auGl =
          GHC.Num.fromInteger
            @ GHC.Types.Int
            GHC.Num.$fNumInt
            (GHC.TypeLits.natVal
               @ frac2_avjr
               @ Data.Proxy.Proxy
               $dKnownNat_avnR
               (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac2_avjr)) } in
      let {
        argFracSZ_auGk :: GHC.Types.Int
        [LclId, Str=DmdType]
        argFracSZ_auGk =
          GHC.Num.fromInteger
            @ GHC.Types.Int
            GHC.Num.$fNumInt
            (GHC.TypeLits.natVal
               @ frac1_avjq
               @ Data.Proxy.Proxy
               $dKnownNat_avo2
               (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac1_avjq)) } in
      CLaSH.Sized.Fixed.Fixed
        @ frac2_avjr
        @ rep_avjs
        @ size2_avju
        (case GHC.Classes.<=
                @ GHC.Integer.Type.Integer
                GHC.Integer.Type.$fOrdInteger
                (GHC.TypeLits.natVal
                   @ size1_avjt
                   @ Data.Proxy.Proxy
                   $dKnownNat_avJB
                   (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size1_avjt))
                (GHC.TypeLits.natVal
                   @ size2_avju
                   @ Data.Proxy.Proxy
                   $dKnownNat_avJA
                   (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size2_avju))
         of _ [Occ=Dead] {
           GHC.Types.False ->
             let {
               fMin_auGo :: rep_avjs size2_avju
               [LclId, Str=DmdType]
               fMin_auGo =
                 GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_avJu } in
             let {
               fMax_auGn :: rep_avjs size2_avju
               [LclId, Str=DmdType]
               fMax_auGn =
                 GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_avJu } in
             let {
               mask_auGp :: rep_avjs size1_avjt
               [LclId, Str=DmdType]
               mask_auGp =
                 Data.Bits.complement
                   @ (rep_avjs size1_avjt)
                   $dBits_avJy
                   (CLaSH.Class.Num.resize
                      @ rep_avjs
                      $dResize_avJz
                      @ size2_avju
                      @ size1_avjt
                      $dKnownNat_avJA
                      $dKnownNat_avJB
                      fMax_auGn) } in
             case GHC.Classes.<=
                    @ GHC.Types.Int GHC.Classes.$fOrdInt argFracSZ_auGk resFracSZ_auGl
             of _ [Occ=Dead] {
               GHC.Types.False ->
                 let {
                   shiftedR_auGt :: rep_avjs size1_avjt
                   [LclId, Str=DmdType]
                   shiftedR_auGt =
                     Data.Bits.shiftR
                       @ (rep_avjs size1_avjt)
                       $dBits_avJy
                       (ds_dvYW
                        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                  <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                                :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                     ~#
                                   rep_avjs size1_avjt))
                       (GHC.Num.-
                          @ GHC.Types.Int
                          GHC.Num.$fNumInt
                          argFracSZ_auGk
                          resFracSZ_auGl) } in
                 let {
                   shiftedR_masked_auGu :: rep_avjs size1_avjt
                   [LclId, Str=DmdType]
                   shiftedR_masked_auGu =
                     Data.Bits..&.
                       @ (rep_avjs size1_avjt) $dBits_avJy shiftedR_auGt mask_auGp } in
                 let {
                   shiftedR_resized_auGv :: rep_avjs size2_avju
                   [LclId, Str=DmdType]
                   shiftedR_resized_auGv =
                     CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_avJz
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_avJB
                       $dKnownNat_avJA
                       shiftedR_auGt } in
                 case GHC.Classes.>=
                        @ (rep_avjs size1_avjt)
                        $dOrd_avJw
                        (ds_dvYW
                         `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                   <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                                 :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                      ~#
                                    rep_avjs size1_avjt))
                        (GHC.Num.fromInteger
                           @ (rep_avjs size1_avjt) $dNum_avJx (__integer 0))
                 of _ [Occ=Dead] {
                   GHC.Types.False ->
                     case GHC.Classes.==
                            @ (rep_avjs size1_avjt) $dEq_avJH shiftedR_masked_auGu mask_auGp
                     of _ [Occ=Dead] {
                       GHC.Types.False -> fMin_auGo;
                       GHC.Types.True -> shiftedR_resized_auGv
                     };
                   GHC.Types.True ->
                     case GHC.Classes.==
                            @ (rep_avjs size1_avjt)
                            $dEq_avJH
                            shiftedR_masked_auGu
                            (GHC.Num.fromInteger
                               @ (rep_avjs size1_avjt) $dNum_avJx (__integer 0))
                     of _ [Occ=Dead] {
                       GHC.Types.False -> fMax_auGn;
                       GHC.Types.True -> shiftedR_resized_auGv
                     }
                 };
               GHC.Types.True ->
                 let {
                   shiftedL_auGq :: rep_avjs size1_avjt
                   [LclId, Str=DmdType]
                   shiftedL_auGq =
                     Data.Bits.shiftL
                       @ (rep_avjs size1_avjt)
                       $dBits_avJy
                       (ds_dvYW
                        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                  <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                                :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                     ~#
                                   rep_avjs size1_avjt))
                       (GHC.Num.-
                          @ GHC.Types.Int
                          GHC.Num.$fNumInt
                          resFracSZ_auGl
                          argFracSZ_auGk) } in
                 let {
                   shiftedL_masked_auGr :: rep_avjs size1_avjt
                   [LclId, Str=DmdType]
                   shiftedL_masked_auGr =
                     Data.Bits..&.
                       @ (rep_avjs size1_avjt) $dBits_avJy shiftedL_auGq mask_auGp } in
                 let {
                   shiftedL_resized_auGs :: rep_avjs size2_avju
                   [LclId, Str=DmdType]
                   shiftedL_resized_auGs =
                     CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_avJz
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_avJB
                       $dKnownNat_avJA
                       shiftedL_auGq } in
                 case GHC.Classes.>=
                        @ (rep_avjs size1_avjt)
                        $dOrd_avJw
                        (ds_dvYW
                         `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                   <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                                 :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                      ~#
                                    rep_avjs size1_avjt))
                        (GHC.Num.fromInteger
                           @ (rep_avjs size1_avjt) $dNum_avJx (__integer 0))
                 of _ [Occ=Dead] {
                   GHC.Types.False ->
                     case GHC.Classes.==
                            @ (rep_avjs size1_avjt) $dEq_avJH shiftedL_masked_auGr mask_auGp
                     of _ [Occ=Dead] {
                       GHC.Types.False -> fMin_auGo;
                       GHC.Types.True -> shiftedL_resized_auGs
                     };
                   GHC.Types.True ->
                     case GHC.Classes.==
                            @ (rep_avjs size1_avjt)
                            $dEq_avJH
                            shiftedL_masked_auGr
                            (GHC.Num.fromInteger
                               @ (rep_avjs size1_avjt) $dNum_avJx (__integer 0))
                     of _ [Occ=Dead] {
                       GHC.Types.False -> fMax_auGn;
                       GHC.Types.True -> shiftedL_resized_auGs
                     }
                 }
             };
           GHC.Types.True ->
             case GHC.Classes.<=
                    @ GHC.Types.Int GHC.Classes.$fOrdInt argFracSZ_auGk resFracSZ_auGl
             of _ [Occ=Dead] {
               GHC.Types.False ->
                 Data.Bits.shiftR
                   @ (rep_avjs size2_avju)
                   $dBits_avJC
                   (CLaSH.Class.Num.resize
                      @ rep_avjs
                      $dResize_avJz
                      @ size1_avjt
                      @ size2_avju
                      $dKnownNat_avJB
                      $dKnownNat_avJA
                      (ds_dvYW
                       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                               :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                    ~#
                                  rep_avjs size1_avjt)))
                   (GHC.Num.-
                      @ GHC.Types.Int GHC.Num.$fNumInt argFracSZ_auGk resFracSZ_auGl);
               GHC.Types.True ->
                 Data.Bits.shiftL
                   @ (rep_avjs size2_avju)
                   $dBits_avJC
                   (CLaSH.Class.Num.resize
                      @ rep_avjs
                      $dResize_avJz
                      @ size1_avjt
                      @ size2_avju
                      $dKnownNat_avJB
                      $dKnownNat_avJA
                      (ds_dvYW
                       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                               :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                    ~#
                                  rep_avjs size1_avjt)))
                   (GHC.Num.-
                      @ GHC.Types.Int GHC.Num.$fNumInt resFracSZ_auGl argFracSZ_auGk)
             }
         })

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    (f_auGd :: CLaSH.Sized.Fixed.Fixed frac_avjN rep_avjO size_avjP) ->
    GHC.Num.fromInteger
      @ GHC.Types.Int
      GHC.Num.$fNumInt
      (GHC.TypeLits.natVal
         @ frac_avjN
         @ Data.Proxy.Proxy
         $dKnownNat_avxa
         (CLaSH.Sized.Fixed.asFracProxy
            @ frac_avjN @ rep_avjO @ size_avjP f_auGd))

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.unUF =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi
    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
              <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                               GHC.TypeLits.+ frac_avkL>_N
            :: CLaSH.Sized.Fixed.Fixed
                 frac_avkL
                 CLaSH.Sized.Unsigned.Unsigned
                 (int_avkK GHC.TypeLits.+ frac_avkL)
                 ~#
               CLaSH.Sized.Unsigned.Unsigned (int_avkK GHC.TypeLits.+ frac_avkL))

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.uf =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    CLaSH.Sized.Fixed.Fixed
      @ frac_avl5
      @ CLaSH.Sized.Unsigned.Unsigned
      @ (int_avl6 GHC.TypeLits.+ frac_avl5)
      fRep_auGb

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.unSF =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu
    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
              <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                           GHC.TypeLits.+ frac_avlq>_N
            :: CLaSH.Sized.Fixed.Fixed
                 frac_avlq
                 CLaSH.Sized.Signed.Signed
                 (int_avlp GHC.TypeLits.+ frac_avlq)
                 ~#
               CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq))

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX, Str=DmdType]
CLaSH.Sized.Fixed.sf =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    CLaSH.Sized.Fixed.Fixed
      @ frac_avlK
      @ CLaSH.Sized.Signed.Signed
      @ (int_avlL GHC.TypeLits.+ frac_avlK)
      fRep_auG9

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]], Str=DmdType]
CLaSH.Sized.Fixed.unFixed =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF
    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
              <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
            :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
                 ~#
               rep_auI3 size_auI4)

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId, Str=DmdType]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    let {
      $dNum_avIp :: GHC.Num.Num (GHC.Real.Ratio GHC.Integer.Type.Integer)
      [LclId, Str=DmdType]
      $dNum_avIp =
        GHC.Real.$fNumRatio
          @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger } in
    \ (f_auHA
         :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
      let {
        fRepI_auHE :: GHC.Integer.Type.Integer
        [LclId, Str=DmdType]
        fRepI_auHE =
          GHC.Real.toInteger
            @ (rep_auHy size_auHz)
            $dIntegral_avFy
            (f_auHA
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                          ~#
                        rep_auHy size_auHz)) } in
      let {
        fRepI_abs_auHF :: GHC.Integer.Type.Integer
        [LclId, Str=DmdType]
        fRepI_abs_auHF =
          GHC.Num.abs
            @ GHC.Integer.Type.Integer GHC.Num.$fNumInteger fRepI_auHE } in
      let {
        nF_auHD :: GHC.Types.Int
        [LclId, Str=DmdType]
        nF_auHD =
          CLaSH.Sized.Fixed.fracShift
            @ frac_auHx @ rep_auHy @ size_auHz $dKnownNat_avFx f_auHA } in
      GHC.Base.++
        @ GHC.Types.Char
        (case GHC.Classes.<
                @ GHC.Integer.Type.Integer
                GHC.Integer.Type.$fOrdInteger
                fRepI_auHE
                (__integer 0)
         of _ [Occ=Dead] {
           GHC.Types.False ->
             GHC.Show.show
               @ GHC.Integer.Type.Integer
               GHC.Show.$fShowInteger
               (Data.Bits.shiftR
                  @ GHC.Integer.Type.Integer
                  Data.Bits.$fBitsInteger
                  fRepI_auHE
                  nF_auHD);
           GHC.Types.True ->
             GHC.Types.:
               @ GHC.Types.Char
               (GHC.Types.C# '-')
               (GHC.Show.show
                  @ GHC.Integer.Type.Integer
                  GHC.Show.$fShowInteger
                  (Data.Bits.shiftR
                     @ GHC.Integer.Type.Integer
                     Data.Bits.$fBitsInteger
                     fRepI_abs_auHF
                     nF_auHD))
         })
        (GHC.Base.++
           @ GHC.Types.Char
           (GHC.Types.:
              @ GHC.Types.Char
              (GHC.Types.C# '.')
              (GHC.Types.[] @ GHC.Types.Char))
           (GHC.Base.$
              @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
              @ [GHC.Types.Char]
              (GHC.Base..
                 @ (GHC.Types.Int, [GHC.Types.Char])
                 @ [GHC.Types.Char]
                 @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                 (Data.Tuple.uncurry
                    @ GHC.Types.Int
                    @ [GHC.Types.Char]
                    @ [GHC.Types.Char]
                    (\ (n_auHJ :: GHC.Types.Int) (str_auHK :: [GHC.Types.Char]) ->
                       GHC.Base.++
                         @ GHC.Types.Char
                         (GHC.List.replicate
                            @ GHC.Types.Char
                            (GHC.Num.-
                               @ GHC.Types.Int
                               GHC.Num.$fNumInt
                               n_auHJ
                               (GHC.List.length @ GHC.Types.Char str_auHK))
                            (GHC.Types.C# '0'))
                         str_auHK))
                 (GHC.Base..
                    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                    @ (GHC.Types.Int, [GHC.Types.Char])
                    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                    (Control.Arrow.second
                       @ (->)
                       Control.Arrow.$fArrow(->)
                       @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                       @ [GHC.Types.Char]
                       @ GHC.Types.Int
                       (GHC.Base..
                          @ GHC.Integer.Type.Integer
                          @ GHC.Base.String
                          @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                          (GHC.Show.show @ GHC.Integer.Type.Integer GHC.Show.$fShowInteger)
                          (GHC.Real.numerator
                             @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger)))
                    (GHC.Base..
                       @ (Data.Maybe.Maybe
                            (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                       @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                       @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                       (Data.Maybe.fromJust
                          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                       (GHC.Base..
                          @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                          @ (Data.Maybe.Maybe
                               (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                          @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                          (Data.List.find
                             @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                             (GHC.Base..
                                @ GHC.Integer.Type.Integer
                                @ GHC.Types.Bool
                                @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                                (let {
                                   ds_dw45 :: GHC.Integer.Type.Integer
                                   [LclId, Str=DmdType]
                                   ds_dw45 = __integer 1 } in
                                 \ (ds_dw44 [OS=ProbOneShot] :: GHC.Integer.Type.Integer) ->
                                   GHC.Classes.==
                                     @ GHC.Integer.Type.Integer
                                     GHC.Integer.Type.$fEqInteger
                                     ds_dw44
                                     ds_dw45)
                                (GHC.Base..
                                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                   @ GHC.Integer.Type.Integer
                                   @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                                   (GHC.Real.denominator
                                      @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger)
                                   (Data.Tuple.snd
                                      @ GHC.Types.Int
                                      @ (GHC.Real.Ratio GHC.Integer.Type.Integer)))))
                          (GHC.Base..
                             @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                             @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                             @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                             (GHC.List.iterate
                                @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                                (Control.Arrow.***
                                   @ (->)
                                   Control.Arrow.$fArrow(->)
                                   @ GHC.Types.Int
                                   @ GHC.Types.Int
                                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                   (GHC.Enum.succ @ GHC.Types.Int GHC.Enum.$fEnumInt)
                                   (let {
                                      ds_dw48 :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                      [LclId, Str=DmdType]
                                      ds_dw48 =
                                        GHC.Num.fromInteger
                                          @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                          $dNum_avIp
                                          (__integer 10) } in
                                    \ (ds_dw47 :: GHC.Real.Ratio GHC.Integer.Type.Integer) ->
                                      GHC.Num.*
                                        @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                        $dNum_avIp
                                        ds_dw47
                                        ds_dw48)))
                             (GHC.Tuple.(,)
                                @ GHC.Types.Int
                                @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                (GHC.Types.I# 0)))))))
              (GHC.Real.%
                 @ GHC.Integer.Type.Integer
                 GHC.Real.$fIntegralInteger
                 (case GHC.Classes.<
                         @ GHC.Integer.Type.Integer
                         GHC.Integer.Type.$fOrdInteger
                         fRepI_auHE
                         (__integer 0)
                  of _ [Occ=Dead] {
                    GHC.Types.False ->
                      Data.Bits..&.
                        @ GHC.Integer.Type.Integer
                        Data.Bits.$fBitsInteger
                        fRepI_auHE
                        (GHC.Num.-
                           @ GHC.Integer.Type.Integer
                           GHC.Num.$fNumInteger
                           (GHC.Real.^
                              @ GHC.Integer.Type.Integer
                              @ GHC.Types.Int
                              GHC.Num.$fNumInteger
                              GHC.Real.$fIntegralInt
                              (__integer 2)
                              nF_auHD)
                           (__integer 1));
                    GHC.Types.True ->
                      Data.Bits..&.
                        @ GHC.Integer.Type.Integer
                        Data.Bits.$fBitsInteger
                        fRepI_abs_auHF
                        (GHC.Num.-
                           @ GHC.Integer.Type.Integer
                           GHC.Num.$fNumInteger
                           (GHC.Real.^
                              @ GHC.Integer.Type.Integer
                              @ GHC.Types.Int
                              GHC.Num.$fNumInteger
                              GHC.Real.$fIntegralInt
                              (__integer 2)
                              nF_auHD)
                           (__integer 1))
                  })
                 (GHC.Real.^
                    @ GHC.Integer.Type.Integer
                    @ GHC.Types.Int
                    GHC.Num.$fNumInteger
                    GHC.Real.$fIntegralInt
                    (__integer 2)
                    nF_auHD))))

Rec {
CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

$cshowList_avIE [Occ=LoopBreaker]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId, Str=DmdType]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    let {
      $dShow_avID
        :: GHC.Show.Show
             (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      [LclId, Str=DmdType]
      $dShow_avID =
        CLaSH.Sized.Fixed.$fShowFixed
          @ frac_auHx
          @ rep_auHy
          @ size_auHz
          $dShow_avFv
          $dBits_avFw
          $dKnownNat_avFx
          $dIntegral_avFy } in
    GHC.Show.$dmshowList
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      $dShow_avID

$cshowsPrec_avFB [Occ=LoopBreaker]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId, Str=DmdType]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    let {
      $dShow_avFA
        :: GHC.Show.Show
             (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      [LclId, Str=DmdType]
      $dShow_avFA =
        CLaSH.Sized.Fixed.$fShowFixed
          @ frac_auHx
          @ rep_auHy
          @ size_auHz
          $dShow_avFv
          $dBits_avFw
          $dKnownNat_avFx
          $dIntegral_avFy } in
    GHC.Show.$dmshowsPrec
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      $dShow_avFA
end Rec }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId, Str=DmdType]
$cmult_avFi =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) ->
    let {
      cobox_avFs
        :: CLaSH.Class.Num.MResult
             (rep_auHr size1_auHs) (rep_auHr size2_auHu)
           ~ rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
      [LclId, Str=DmdType]
      cobox_avFs =
        case case tup_avFg of _ [Occ=Dead] { (_ [Occ=Dead], tpl_B2) ->
             tpl_B2
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6C ->
        GHC.Types.Eq#
          @ *
          @ (CLaSH.Class.Num.MResult
               (rep_auHr size1_auHs) (rep_auHr size2_auHu))
          @ (rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
          @~ cobox_dw6C
        } } in
    let {
      $dMult_avFr
        :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
      [LclId, Str=DmdType]
      $dMult_avFr =
        case tup_avFg of _ [Occ=Dead] { (tpl_B1, _ [Occ=Dead]) ->
        tpl_B1
        } } in
    \ (ds_dw3N
         :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
      (ds_dw3O
         :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
      (CLaSH.Sized.Fixed.Fixed
         @ (frac1_auHq GHC.TypeLits.+ frac2_auHt)
         @ rep_auHr
         @ (size1_auHs GHC.TypeLits.+ size2_auHu)
         (case cobox_avFs of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
          (CLaSH.Class.Num.mult
             @ (rep_auHr size1_auHs)
             @ (rep_auHr size2_auHu)
             $dMult_avFr
             (ds_dw3N
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                      :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                           ~#
                         rep_auHr size1_auHs))
             (ds_dw3O
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                      :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                           ~#
                         rep_auHr size2_auHu)))
          `cast` (Sub cobox_dw3M
                  :: CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                       ~#
                     rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
          }))
      `cast` (Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                      <frac1_auHq>_N
                      <rep_auHr>_N
                      <size1_auHs>_N
                      <frac2_auHt>_N
                      <size2_auHu>_N))
              :: CLaSH.Sized.Fixed.Fixed
                   (frac1_auHq GHC.TypeLits.+ frac2_auHt)
                   rep_auHr
                   (size1_auHs GHC.TypeLits.+ size2_auHu)
                   ~#
                 CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
                 (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
                 (@ (size1_auHs :: GHC.TypeLits.Nat))
                 (@ (frac2_auHt :: GHC.TypeLits.Nat))
                 (@ (size2_auHu :: GHC.TypeLits.Nat))
                 (tup_avFg [Occ=Once]
                    :: CLaSH.Sized.Fixed.MultFixed
                         rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) ->
                 CLaSH.Class.Num.D:Mult
                   @ (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   @ (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
                   ($cmult_avFi
                      @ frac1_auHq
                      @ rep_auHr
                      @ size1_auHs
                      @ frac2_auHt
                      @ size2_auHu
                      tup_avFg)}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) ->
    CLaSH.Class.Num.D:Mult
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
      ($cmult_avFi
         @ frac1_auHq
         @ rep_auHr
         @ size1_auHs
         @ frac2_auHt
         @ size2_auHu
         tup_avFg)

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId, Str=DmdType]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    let {
      tup_avU6
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_avU6 =
        case tup_avDN
        of _ [Occ=Dead] { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead]) ->
        tpl_B2
        } } in
    let {
      $dBounded_avUu
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_avUu =
        case tup_avU6
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dOrd_avV9 :: GHC.Classes.Ord (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dOrd_avV9 =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dNum_avVa :: GHC.Num.Num (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dNum_avVa =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      $dBits_avUy :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_avUy =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B5
        } } in
    let {
      $dEq_avV8 :: GHC.Classes.Eq (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dEq_avV8 =
        Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_avUy } in
    let {
      $dResize_avUz :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_avUz =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_avUA
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_avUA =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B7, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B7
        } } in
    let {
      $dKnownNat_avVe :: GHC.TypeLits.KnownNat size2_auHh
      [LclId, Str=DmdType]
      $dKnownNat_avVe =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dBits_avUC
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_avUC =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B9, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_avUD
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_avUD =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_Ba
        } } in
    let {
      $dKnownNat_avVh :: GHC.TypeLits.KnownNat frac2_auHg
      [LclId, Str=DmdType]
      $dKnownNat_avVh =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bb, _ [Occ=Dead]) ->
        tpl_Bb
        } } in
    let {
      $dBounded_avVi :: GHC.Enum.Bounded (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBounded_avVi =
        case tup_avU6
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bc) ->
        tpl_Bc
        } } in
    let {
      tup_avU5
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_avU5 =
        case tup_avDN
        of _ [Occ=Dead] { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dOrd_avVl :: GHC.Classes.Ord (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dOrd_avVl =
        case tup_avU5
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dNum_avVm :: GHC.Num.Num (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dNum_avVm =
        case tup_avU5
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      $dBits_avUc :: Data.Bits.Bits (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dBits_avUc =
        case tup_avU5
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B5
        } } in
    let {
      $dEq_avVk :: GHC.Classes.Eq (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dEq_avVk =
        Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_avUc } in
    let {
      $dKnownNat_avVq :: GHC.TypeLits.KnownNat size1_auHf
      [LclId, Str=DmdType]
      $dKnownNat_avVq =
        case tup_avU5
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dKnownNat_avVt :: GHC.TypeLits.KnownNat frac1_auHd
      [LclId, Str=DmdType]
      $dKnownNat_avVt =
        case tup_avU5
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bb, _ [Occ=Dead]) ->
        tpl_Bb
        } } in
    let {
      $dBounded_avVu :: GHC.Enum.Bounded (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dBounded_avVu =
        case tup_avU5
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bc) ->
        tpl_Bc
        } } in
    let {
      $dNum_avFd
        :: GHC.Num.Num
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dNum_avFd =
        case tup_avDN
        of _ [Occ=Dead] { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3) ->
        tpl_B3
        } } in
    let {
      tup_avF3
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_avF3 =
        ($dBounded_avUu,
         $dEq_avVk,
         $dOrd_avVl,
         $dNum_avVm,
         $dBits_avUc,
         $dResize_avUz,
         $dKnownNat_avUA,
         $dKnownNat_avVq,
         $dBits_avUC,
         $dKnownNat_avUD,
         $dKnownNat_avVt,
         $dBounded_avVu) } in
    let {
      tup_avEM
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_avEM =
        ($dBounded_avUu,
         $dEq_avV8,
         $dOrd_avV9,
         $dNum_avVa,
         $dBits_avUy,
         $dResize_avUz,
         $dKnownNat_avUA,
         $dKnownNat_avVe,
         $dBits_avUC,
         $dKnownNat_avUD,
         $dKnownNat_avVh,
         $dBounded_avVi) } in
    \ (f1_auHm
         :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      (f2_auHn
         :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
      let {
        ds_dw39
          :: CLaSH.Sized.Fixed.Fixed
               (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
               rep_auHe
               (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
        [LclId, Str=DmdType]
        ds_dw39 =
          CLaSH.Sized.Fixed.resizeF
            @ frac2_auHg
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size2_auHh
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            tup_avEM
            f2_auHn } in
      let {
        ds_dw34
          :: CLaSH.Sized.Fixed.Fixed
               (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
               rep_auHe
               (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
        [LclId, Str=DmdType]
        ds_dw34 =
          CLaSH.Sized.Fixed.resizeF
            @ frac1_auHd
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size1_auHf
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            tup_avF3
            f1_auHm } in
      (CLaSH.Sized.Fixed.Fixed
         @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
         @ rep_auHe
         @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
         (GHC.Num.-
            @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
            $dNum_avFd
            (ds_dw34
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                       <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                     GHC.TypeLits.+ 1>_N
                     :: CLaSH.Sized.Fixed.Fixed
                          (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                          rep_auHe
                          (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                          ~#
                        rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                  GHC.TypeLits.+ 1)))
            (ds_dw39
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                       <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                     GHC.TypeLits.+ 1>_N
                     :: CLaSH.Sized.Fixed.Fixed
                          (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                          rep_auHe
                          (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                          ~#
                        rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                  GHC.TypeLits.+ 1)))))
      `cast` (Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
              :: CLaSH.Sized.Fixed.Fixed
                   (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                   rep_auHe
                   (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                   ~#
                 CLaSH.Class.Num.AResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId, Str=DmdType]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    let {
      tup_avSG
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_avSG =
        case tup_avDN
        of _ [Occ=Dead] { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead]) ->
        tpl_B2
        } } in
    let {
      $dBounded_avT4
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_avT4 =
        case tup_avSG
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dOrd_avTJ :: GHC.Classes.Ord (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dOrd_avTJ =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dNum_avTK :: GHC.Num.Num (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dNum_avTK =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      $dBits_avT8 :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_avT8 =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B5
        } } in
    let {
      $dEq_avTI :: GHC.Classes.Eq (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dEq_avTI =
        Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_avT8 } in
    let {
      $dResize_avT9 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_avT9 =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_avTa
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_avTa =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B7, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B7
        } } in
    let {
      $dKnownNat_avTO :: GHC.TypeLits.KnownNat size2_auHh
      [LclId, Str=DmdType]
      $dKnownNat_avTO =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dBits_avTc
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_avTc =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B9, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_avTd
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_avTd =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_Ba
        } } in
    let {
      $dKnownNat_avTR :: GHC.TypeLits.KnownNat frac2_auHg
      [LclId, Str=DmdType]
      $dKnownNat_avTR =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bb, _ [Occ=Dead]) ->
        tpl_Bb
        } } in
    let {
      $dBounded_avTS :: GHC.Enum.Bounded (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBounded_avTS =
        case tup_avSG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bc) ->
        tpl_Bc
        } } in
    let {
      tup_avSF
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_avSF =
        case tup_avDN
        of _ [Occ=Dead] { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dOrd_avTV :: GHC.Classes.Ord (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dOrd_avTV =
        case tup_avSF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dNum_avTW :: GHC.Num.Num (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dNum_avTW =
        case tup_avSF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      $dBits_avSM :: Data.Bits.Bits (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dBits_avSM =
        case tup_avSF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B5
        } } in
    let {
      $dEq_avTU :: GHC.Classes.Eq (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dEq_avTU =
        Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_avSM } in
    let {
      $dKnownNat_avU0 :: GHC.TypeLits.KnownNat size1_auHf
      [LclId, Str=DmdType]
      $dKnownNat_avU0 =
        case tup_avSF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dKnownNat_avU3 :: GHC.TypeLits.KnownNat frac1_auHd
      [LclId, Str=DmdType]
      $dKnownNat_avU3 =
        case tup_avSF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bb, _ [Occ=Dead]) ->
        tpl_Bb
        } } in
    let {
      $dBounded_avU4 :: GHC.Enum.Bounded (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dBounded_avU4 =
        case tup_avSF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bc) ->
        tpl_Bc
        } } in
    let {
      $dNum_avEv
        :: GHC.Num.Num
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dNum_avEv =
        case tup_avDN
        of _ [Occ=Dead] { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3) ->
        tpl_B3
        } } in
    let {
      tup_avEl
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_avEl =
        ($dBounded_avT4,
         $dEq_avTU,
         $dOrd_avTV,
         $dNum_avTW,
         $dBits_avSM,
         $dResize_avT9,
         $dKnownNat_avTa,
         $dKnownNat_avU0,
         $dBits_avTc,
         $dKnownNat_avTd,
         $dKnownNat_avU3,
         $dBounded_avU4) } in
    let {
      tup_avE4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_avE4 =
        ($dBounded_avT4,
         $dEq_avTI,
         $dOrd_avTJ,
         $dNum_avTK,
         $dBits_avT8,
         $dResize_avT9,
         $dKnownNat_avTa,
         $dKnownNat_avTO,
         $dBits_avTc,
         $dKnownNat_avTd,
         $dKnownNat_avTR,
         $dBounded_avTS) } in
    \ (f1_auHi
         :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      (f2_auHj
         :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
      let {
        ds_dw2p
          :: CLaSH.Sized.Fixed.Fixed
               (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
               rep_auHe
               (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
        [LclId, Str=DmdType]
        ds_dw2p =
          CLaSH.Sized.Fixed.resizeF
            @ frac2_auHg
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size2_auHh
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            tup_avE4
            f2_auHj } in
      let {
        ds_dw2k
          :: CLaSH.Sized.Fixed.Fixed
               (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
               rep_auHe
               (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
        [LclId, Str=DmdType]
        ds_dw2k =
          CLaSH.Sized.Fixed.resizeF
            @ frac1_auHd
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size1_auHf
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            tup_avEl
            f1_auHi } in
      (CLaSH.Sized.Fixed.Fixed
         @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
         @ rep_auHe
         @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
         (GHC.Num.+
            @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
            $dNum_avEv
            (ds_dw2k
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                       <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                     GHC.TypeLits.+ 1>_N
                     :: CLaSH.Sized.Fixed.Fixed
                          (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                          rep_auHe
                          (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                          ~#
                        rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                  GHC.TypeLits.+ 1)))
            (ds_dw2p
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                       <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                     GHC.TypeLits.+ 1>_N
                     :: CLaSH.Sized.Fixed.Fixed
                          (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                          rep_auHe
                          (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                          ~#
                        rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                  GHC.TypeLits.+ 1)))))
      `cast` (Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
              :: CLaSH.Sized.Fixed.Fixed
                   (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                   rep_auHe
                   (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                   ~#
                 CLaSH.Class.Num.AResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Str=DmdType]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) ->
    let {
      tup_avRs
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId, Str=DmdType]
      tup_avRs =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B2
        } } in
    let {
      $dNum_avDK :: GHC.Num.Num (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dNum_avDK =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dBits_avDI :: Data.Bits.Bits (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBits_avDI =
        case tup_avRs
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B9, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_avDx :: GHC.TypeLits.KnownNat frac_auGY
      [LclId, Str=DmdType]
      $dKnownNat_avDx =
        case tup_avRs
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_Ba
        } } in
    \ (i_auHa :: GHC.Integer.Type.Integer) ->
      CLaSH.Sized.Fixed.Fixed
        @ frac_auGY
        @ rep_auGZ
        @ size_auH0
        (Data.Bits.shiftL
           @ (rep_auGZ size_auH0)
           $dBits_avDI
           (GHC.Num.fromInteger @ (rep_auGZ size_auH0) $dNum_avDK i_auHa)
           (GHC.Num.fromInteger
              @ GHC.Types.Int
              GHC.Num.$fNumInt
              (GHC.TypeLits.natVal
                 @ frac_auGY
                 @ Data.Proxy.Proxy
                 $dKnownNat_avDx
                 (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_auGY))))

$csignum_avDg
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Str=DmdType]
$csignum_avDg =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) ->
    let {
      $dNum_avDn :: GHC.Num.Num (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dNum_avDn =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    \ (ds_dw2d
         :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
      CLaSH.Sized.Fixed.Fixed
        @ frac_auGY
        @ rep_auGZ
        @ size_auH0
        (GHC.Num.signum
           @ (rep_auGZ size_auH0)
           $dNum_avDn
           (ds_dw2d
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                         ~#
                       rep_auGZ size_auH0)))

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Str=DmdType]
$cabs_avCW =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) ->
    let {
      tup_avQ0
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId, Str=DmdType]
      tup_avQ0 =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B2
        } } in
    let {
      $dBounded_avQL :: GHC.Enum.Bounded (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBounded_avQL =
        case tup_avQ0
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dKnownNat_avQp :: GHC.TypeLits.KnownNat size_auH0
      [LclId, Str=DmdType]
      $dKnownNat_avQp =
        case tup_avQ0
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B7, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B7
        } } in
    let {
      tup_avPZ :: CLaSH.Sized.Fixed.SatN2C rep_auGZ size_auH0
      [LclId, Str=DmdType]
      tup_avPZ =
        case tup_avBm
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      cobox_avQD :: 1 GHC.TypeLits.<= size_auH0
      [LclId, Str=DmdType]
      cobox_avQD =
        case case tup_avPZ
             of _ [Occ=Dead]
             { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B1
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6f ->
        GHC.Types.Eq#
          @ GHC.Types.Bool
          @ (1 GHC.TypeLits.<=? size_auH0)
          @ 'GHC.Types.True
          @~ cobox_dw6f
        } } in
    let {
      cobox_avQE
        :: ((size_auH0 GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avQE =
        case case tup_avPZ
             of _ [Occ=Dead]
             { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B2
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6d ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ ((size_auH0 GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
          @ (size_auH0 GHC.TypeLits.+ 2)
          @~ cobox_dw6d
        } } in
    let {
      $dBitVector_avQF
        :: CLaSH.Class.BitVector.BitVector (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBitVector_avQF =
        case tup_avPZ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dBitVector_avQG
        :: CLaSH.Class.BitVector.BitVector
             (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBitVector_avQG =
        case tup_avPZ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      cobox_avQH
        :: CLaSH.Class.BitVector.BitSize (rep_auGZ size_auH0) ~ size_auH0
      [LclId, Str=DmdType]
      cobox_avQH =
        case case tup_avPZ
             of _ [Occ=Dead]
             { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B5
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6b ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ (CLaSH.Class.BitVector.BitSize (rep_auGZ size_auH0))
          @ size_auH0
          @~ cobox_dw6b
        } } in
    let {
      cobox_avQI
        :: CLaSH.Class.BitVector.BitSize
             (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
           ~ (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avQI =
        case case tup_avPZ
             of _ [Occ=Dead]
             { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B6
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw69 ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ (CLaSH.Class.BitVector.BitSize
               (rep_auGZ (size_auH0 GHC.TypeLits.+ 2)))
          @ (size_auH0 GHC.TypeLits.+ 2)
          @~ cobox_dw69
        } } in
    let {
      $dKnownNat_avQc
        :: GHC.TypeLits.KnownNat (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_avQc =
        case tup_avPZ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dBits_avQM
        :: Data.Bits.Bits (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBits_avQM =
        case tup_avPZ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba) ->
        tpl_Ba
        } } in
    let {
      $dResize_avD9 :: CLaSH.Class.Num.Resize rep_auGZ
      [LclId, Str=DmdType]
      $dResize_avD9 =
        case tup_avQ0
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B6
        } } in
    let {
      $dNum_avD6 :: GHC.Num.Num (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dNum_avD6 =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      tup_avD4 :: CLaSH.Sized.Fixed.SatN2C rep_auGZ size_auH0
      [LclId, Str=DmdType]
      tup_avD4 =
        (cobox_avQD,
         cobox_avQE,
         $dBitVector_avQF,
         $dBitVector_avQG,
         cobox_avQH,
         cobox_avQI,
         $dKnownNat_avQp,
         $dKnownNat_avQc,
         $dBounded_avQL,
         $dBits_avQM) } in
    \ (ds_dw1Z
         :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
      CLaSH.Sized.Fixed.Fixed
        @ frac_auGY
        @ rep_auGZ
        @ size_auH0
        (CLaSH.Sized.Fixed.satN2
           @ rep_auGZ
           @ size_auH0
           tup_avD4
           (GHC.Num.abs
              @ (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
              $dNum_avD6
              (CLaSH.Class.Num.resize
                 @ rep_auGZ
                 $dResize_avD9
                 @ size_auH0
                 @ (size_auH0 GHC.TypeLits.+ 2)
                 $dKnownNat_avQp
                 $dKnownNat_avQc
                 (ds_dw1Z
                  `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                            <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
                          :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                               ~#
                             rep_auGZ size_auH0)))))

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Str=DmdType]
$cnegate_avCC =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) ->
    let {
      tup_avP8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId, Str=DmdType]
      tup_avP8 =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B2
        } } in
    let {
      $dBounded_avPT :: GHC.Enum.Bounded (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBounded_avPT =
        case tup_avP8
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dKnownNat_avPx :: GHC.TypeLits.KnownNat size_auH0
      [LclId, Str=DmdType]
      $dKnownNat_avPx =
        case tup_avP8
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B7, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B7
        } } in
    let {
      tup_avP7 :: CLaSH.Sized.Fixed.SatN2C rep_auGZ size_auH0
      [LclId, Str=DmdType]
      tup_avP7 =
        case tup_avBm
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      cobox_avPL :: 1 GHC.TypeLits.<= size_auH0
      [LclId, Str=DmdType]
      cobox_avPL =
        case case tup_avP7
             of _ [Occ=Dead]
             { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B1
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw66 ->
        GHC.Types.Eq#
          @ GHC.Types.Bool
          @ (1 GHC.TypeLits.<=? size_auH0)
          @ 'GHC.Types.True
          @~ cobox_dw66
        } } in
    let {
      cobox_avPM
        :: ((size_auH0 GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avPM =
        case case tup_avP7
             of _ [Occ=Dead]
             { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B2
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw64 ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ ((size_auH0 GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
          @ (size_auH0 GHC.TypeLits.+ 2)
          @~ cobox_dw64
        } } in
    let {
      $dBitVector_avPN
        :: CLaSH.Class.BitVector.BitVector (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBitVector_avPN =
        case tup_avP7
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dBitVector_avPO
        :: CLaSH.Class.BitVector.BitVector
             (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBitVector_avPO =
        case tup_avP7
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      cobox_avPP
        :: CLaSH.Class.BitVector.BitSize (rep_auGZ size_auH0) ~ size_auH0
      [LclId, Str=DmdType]
      cobox_avPP =
        case case tup_avP7
             of _ [Occ=Dead]
             { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B5
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw62 ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ (CLaSH.Class.BitVector.BitSize (rep_auGZ size_auH0))
          @ size_auH0
          @~ cobox_dw62
        } } in
    let {
      cobox_avPQ
        :: CLaSH.Class.BitVector.BitSize
             (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
           ~ (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avPQ =
        case case tup_avP7
             of _ [Occ=Dead]
             { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B6
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw60 ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ (CLaSH.Class.BitVector.BitSize
               (rep_auGZ (size_auH0 GHC.TypeLits.+ 2)))
          @ (size_auH0 GHC.TypeLits.+ 2)
          @~ cobox_dw60
        } } in
    let {
      $dKnownNat_avPk
        :: GHC.TypeLits.KnownNat (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_avPk =
        case tup_avP7
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dBits_avPU
        :: Data.Bits.Bits (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBits_avPU =
        case tup_avP7
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba) ->
        tpl_Ba
        } } in
    let {
      $dResize_avCP :: CLaSH.Class.Num.Resize rep_auGZ
      [LclId, Str=DmdType]
      $dResize_avCP =
        case tup_avP8
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B6
        } } in
    let {
      $dNum_avCM :: GHC.Num.Num (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dNum_avCM =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      tup_avCK :: CLaSH.Sized.Fixed.SatN2C rep_auGZ size_auH0
      [LclId, Str=DmdType]
      tup_avCK =
        (cobox_avPL,
         cobox_avPM,
         $dBitVector_avPN,
         $dBitVector_avPO,
         cobox_avPP,
         cobox_avPQ,
         $dKnownNat_avPx,
         $dKnownNat_avPk,
         $dBounded_avPT,
         $dBits_avPU) } in
    \ (ds_dw1K
         :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
      CLaSH.Sized.Fixed.Fixed
        @ frac_auGY
        @ rep_auGZ
        @ size_auH0
        (CLaSH.Sized.Fixed.satN2
           @ rep_auGZ
           @ size_auH0
           tup_avCK
           (GHC.Num.negate
              @ (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
              $dNum_avCM
              (CLaSH.Class.Num.resize
                 @ rep_auGZ
                 $dResize_avCP
                 @ size_auH0
                 @ (size_auH0 GHC.TypeLits.+ 2)
                 $dKnownNat_avPx
                 $dKnownNat_avPk
                 (ds_dw1K
                  `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                            <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
                          :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                               ~#
                             rep_auGZ size_auH0)))))

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Str=DmdType]
$c-_avCb =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) ->
    let {
      tup_avOg
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId, Str=DmdType]
      tup_avOg =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B2
        } } in
    let {
      $dBounded_avP1 :: GHC.Enum.Bounded (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBounded_avP1 =
        case tup_avOg
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dResize_avOE :: CLaSH.Class.Num.Resize rep_auGZ
      [LclId, Str=DmdType]
      $dResize_avOE =
        case tup_avOg
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_avOF :: GHC.TypeLits.KnownNat size_auH0
      [LclId, Str=DmdType]
      $dKnownNat_avOF =
        case tup_avOg
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B7, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B7
        } } in
    let {
      tup_avOf :: CLaSH.Sized.Fixed.SatN2C rep_auGZ size_auH0
      [LclId, Str=DmdType]
      tup_avOf =
        case tup_avBm
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      cobox_avOT :: 1 GHC.TypeLits.<= size_auH0
      [LclId, Str=DmdType]
      cobox_avOT =
        case case tup_avOf
             of _ [Occ=Dead]
             { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B1
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw5X ->
        GHC.Types.Eq#
          @ GHC.Types.Bool
          @ (1 GHC.TypeLits.<=? size_auH0)
          @ 'GHC.Types.True
          @~ cobox_dw5X
        } } in
    let {
      cobox_avOU
        :: ((size_auH0 GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avOU =
        case case tup_avOf
             of _ [Occ=Dead]
             { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B2
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw5V ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ ((size_auH0 GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
          @ (size_auH0 GHC.TypeLits.+ 2)
          @~ cobox_dw5V
        } } in
    let {
      $dBitVector_avOV
        :: CLaSH.Class.BitVector.BitVector (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBitVector_avOV =
        case tup_avOf
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dBitVector_avOW
        :: CLaSH.Class.BitVector.BitVector
             (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBitVector_avOW =
        case tup_avOf
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      cobox_avOX
        :: CLaSH.Class.BitVector.BitSize (rep_auGZ size_auH0) ~ size_auH0
      [LclId, Str=DmdType]
      cobox_avOX =
        case case tup_avOf
             of _ [Occ=Dead]
             { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B5
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw5T ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ (CLaSH.Class.BitVector.BitSize (rep_auGZ size_auH0))
          @ size_auH0
          @~ cobox_dw5T
        } } in
    let {
      cobox_avOY
        :: CLaSH.Class.BitVector.BitSize
             (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
           ~ (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avOY =
        case case tup_avOf
             of _ [Occ=Dead]
             { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B6
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw5R ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ (CLaSH.Class.BitVector.BitSize
               (rep_auGZ (size_auH0 GHC.TypeLits.+ 2)))
          @ (size_auH0 GHC.TypeLits.+ 2)
          @~ cobox_dw5R
        } } in
    let {
      $dKnownNat_avOs
        :: GHC.TypeLits.KnownNat (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_avOs =
        case tup_avOf
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dBits_avP2
        :: Data.Bits.Bits (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBits_avP2 =
        case tup_avOf
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba) ->
        tpl_Ba
        } } in
    let {
      $dNum_avCl :: GHC.Num.Num (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dNum_avCl =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      tup_avCj :: CLaSH.Sized.Fixed.SatN2C rep_auGZ size_auH0
      [LclId, Str=DmdType]
      tup_avCj =
        (cobox_avOT,
         cobox_avOU,
         $dBitVector_avOV,
         $dBitVector_avOW,
         cobox_avOX,
         cobox_avOY,
         $dKnownNat_avOF,
         $dKnownNat_avOs,
         $dBounded_avP1,
         $dBits_avP2) } in
    \ (ds_dw1u :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
      (ds_dw1v
         :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
      CLaSH.Sized.Fixed.Fixed
        @ frac_auGY
        @ rep_auGZ
        @ size_auH0
        (CLaSH.Sized.Fixed.satN2
           @ rep_auGZ
           @ size_auH0
           tup_avCj
           (GHC.Num.-
              @ (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
              $dNum_avCl
              (CLaSH.Class.Num.resize
                 @ rep_auGZ
                 $dResize_avOE
                 @ size_auH0
                 @ (size_auH0 GHC.TypeLits.+ 2)
                 $dKnownNat_avOF
                 $dKnownNat_avOs
                 (ds_dw1u
                  `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                            <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
                          :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                               ~#
                             rep_auGZ size_auH0)))
              (CLaSH.Class.Num.resize
                 @ rep_auGZ
                 $dResize_avOE
                 @ size_auH0
                 @ (size_auH0 GHC.TypeLits.+ 2)
                 $dKnownNat_avOF
                 $dKnownNat_avOs
                 (ds_dw1v
                  `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                            <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
                          :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                               ~#
                             rep_auGZ size_auH0)))))

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Str=DmdType]
$c*_avBP =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) ->
    let {
      tup_avNl
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId, Str=DmdType]
      tup_avNl =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B2
        } } in
    let {
      $dBounded_avO3 :: GHC.Enum.Bounded (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBounded_avO3 =
        case tup_avNl
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dOrd_avO5
        :: GHC.Classes.Ord (rep_auGZ (size_auH0 GHC.TypeLits.+ size_auH0))
      [LclId, Str=DmdType]
      $dOrd_avO5 =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dNum_avO6
        :: GHC.Num.Num (rep_auGZ (size_auH0 GHC.TypeLits.+ size_auH0))
      [LclId, Str=DmdType]
      $dNum_avO6 =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      $dBits_avNI
        :: Data.Bits.Bits (rep_auGZ (size_auH0 GHC.TypeLits.+ size_auH0))
      [LclId, Str=DmdType]
      $dBits_avNI =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B5
        } } in
    let {
      $dEq_avO4
        :: GHC.Classes.Eq (rep_auGZ (size_auH0 GHC.TypeLits.+ size_auH0))
      [LclId, Str=DmdType]
      $dEq_avO4 =
        Data.Bits.$p1Bits
          @ (rep_auGZ (size_auH0 GHC.TypeLits.+ size_auH0)) $dBits_avNI } in
    let {
      $dResize_avO8 :: CLaSH.Class.Num.Resize rep_auGZ
      [LclId, Str=DmdType]
      $dResize_avO8 =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_avO9 :: GHC.TypeLits.KnownNat size_auH0
      [LclId, Str=DmdType]
      $dKnownNat_avO9 =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B7, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B7
        } } in
    let {
      $dKnownNat_avOa
        :: GHC.TypeLits.KnownNat (size_auH0 GHC.TypeLits.+ size_auH0)
      [LclId, Str=DmdType]
      $dKnownNat_avOa =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dBits_avOb :: Data.Bits.Bits (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBits_avOb =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B9, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_avOc :: GHC.TypeLits.KnownNat frac_auGY
      [LclId, Str=DmdType]
      $dKnownNat_avOc =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_Ba
        } } in
    let {
      $dKnownNat_avOd
        :: GHC.TypeLits.KnownNat (frac_auGY GHC.TypeLits.+ frac_auGY)
      [LclId, Str=DmdType]
      $dKnownNat_avOd =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bb, _ [Occ=Dead]) ->
        tpl_Bb
        } } in
    let {
      $dBounded_avOe
        :: GHC.Enum.Bounded (rep_auGZ (size_auH0 GHC.TypeLits.+ size_auH0))
      [LclId, Str=DmdType]
      $dBounded_avOe =
        case tup_avNl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Bc) ->
        tpl_Bc
        } } in
    let {
      cobox_avC7
        :: CLaSH.Class.Num.MResult
             (rep_auGZ size_auH0) (rep_auGZ size_auH0)
           ~ rep_auGZ (size_auH0 GHC.TypeLits.+ size_auH0)
      [LclId, Str=DmdType]
      cobox_avC7 =
        case case tup_avBm
             of _ [Occ=Dead]
             { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6) ->
             tpl_B6
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw5O ->
        GHC.Types.Eq#
          @ *
          @ (CLaSH.Class.Num.MResult
               (rep_auGZ size_auH0) (rep_auGZ size_auH0))
          @ (rep_auGZ (size_auH0 GHC.TypeLits.+ size_auH0))
          @~ cobox_dw5O
        } } in
    let {
      $dMult_avC6
        :: CLaSH.Class.Num.Mult (rep_auGZ size_auH0) (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dMult_avC6 =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead]) ->
        tpl_B5
        } } in
    let {
      tup_avBX
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId, Str=DmdType]
      tup_avBX =
        ($dBounded_avO3,
         $dEq_avO4,
         $dOrd_avO5,
         $dNum_avO6,
         $dBits_avNI,
         $dResize_avO8,
         $dKnownNat_avO9,
         $dKnownNat_avOa,
         $dBits_avOb,
         $dKnownNat_avOc,
         $dKnownNat_avOd,
         $dBounded_avOe) } in
    \ (ds_dw1d :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
      (ds_dw1e
         :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
      CLaSH.Sized.Fixed.resizeF
        @ (frac_auGY GHC.TypeLits.+ frac_auGY)
        @ frac_auGY
        @ rep_auGZ
        @ (size_auH0 GHC.TypeLits.+ size_auH0)
        @ size_auH0
        tup_avBX
        (CLaSH.Sized.Fixed.Fixed
           @ (frac_auGY GHC.TypeLits.+ frac_auGY)
           @ rep_auGZ
           @ (size_auH0 GHC.TypeLits.+ size_auH0)
           (case cobox_avC7 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
            (CLaSH.Class.Num.mult
               @ (rep_auGZ size_auH0)
               @ (rep_auGZ size_auH0)
               $dMult_avC6
               (ds_dw1d
                `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                          <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
                        :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                             ~#
                           rep_auGZ size_auH0))
               (ds_dw1e
                `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                          <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
                        :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                             ~#
                           rep_auGZ size_auH0)))
            `cast` (Sub cobox_dw1a
                    :: CLaSH.Class.Num.MResult
                         (rep_auGZ size_auH0) (rep_auGZ size_auH0)
                         ~#
                       rep_auGZ (size_auH0 GHC.TypeLits.+ size_auH0))
            }))

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Str=DmdType]
$c+_avBo =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) ->
    let {
      tup_avMt
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId, Str=DmdType]
      tup_avMt =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B2
        } } in
    let {
      $dBounded_avNe :: GHC.Enum.Bounded (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBounded_avNe =
        case tup_avMt
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      $dResize_avMR :: CLaSH.Class.Num.Resize rep_auGZ
      [LclId, Str=DmdType]
      $dResize_avMR =
        case tup_avMt
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_avMS :: GHC.TypeLits.KnownNat size_auH0
      [LclId, Str=DmdType]
      $dKnownNat_avMS =
        case tup_avMt
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B7, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B7
        } } in
    let {
      tup_avMs :: CLaSH.Sized.Fixed.SatN2C rep_auGZ size_auH0
      [LclId, Str=DmdType]
      tup_avMs =
        case tup_avBm
        of _ [Occ=Dead]
        { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B1
        } } in
    let {
      cobox_avN6 :: 1 GHC.TypeLits.<= size_auH0
      [LclId, Str=DmdType]
      cobox_avN6 =
        case case tup_avMs
             of _ [Occ=Dead]
             { (tpl_B1, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B1
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw5J ->
        GHC.Types.Eq#
          @ GHC.Types.Bool
          @ (1 GHC.TypeLits.<=? size_auH0)
          @ 'GHC.Types.True
          @~ cobox_dw5J
        } } in
    let {
      cobox_avN7
        :: ((size_auH0 GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avN7 =
        case case tup_avMs
             of _ [Occ=Dead]
             { (_ [Occ=Dead], tpl_B2, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B2
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw5H ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ ((size_auH0 GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
          @ (size_auH0 GHC.TypeLits.+ 2)
          @~ cobox_dw5H
        } } in
    let {
      $dBitVector_avN8
        :: CLaSH.Class.BitVector.BitVector (rep_auGZ size_auH0)
      [LclId, Str=DmdType]
      $dBitVector_avN8 =
        case tup_avMs
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl_B3, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B3
        } } in
    let {
      $dBitVector_avN9
        :: CLaSH.Class.BitVector.BitVector
             (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBitVector_avN9 =
        case tup_avMs
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      cobox_avNa
        :: CLaSH.Class.BitVector.BitSize (rep_auGZ size_auH0) ~ size_auH0
      [LclId, Str=DmdType]
      cobox_avNa =
        case case tup_avMs
             of _ [Occ=Dead]
             { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B5, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B5
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw5F ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ (CLaSH.Class.BitVector.BitSize (rep_auGZ size_auH0))
          @ size_auH0
          @~ cobox_dw5F
        } } in
    let {
      cobox_avNb
        :: CLaSH.Class.BitVector.BitSize
             (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
           ~ (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_avNb =
        case case tup_avMs
             of _ [Occ=Dead]
             { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B6, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
             tpl_B6
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw5D ->
        GHC.Types.Eq#
          @ GHC.TypeLits.Nat
          @ (CLaSH.Class.BitVector.BitSize
               (rep_auGZ (size_auH0 GHC.TypeLits.+ 2)))
          @ (size_auH0 GHC.TypeLits.+ 2)
          @~ cobox_dw5D
        } } in
    let {
      $dKnownNat_avMF
        :: GHC.TypeLits.KnownNat (size_auH0 GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_avMF =
        case tup_avMs
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B8, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B8
        } } in
    let {
      $dBits_avNf
        :: Data.Bits.Bits (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dBits_avNf =
        case tup_avMs
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_Ba) ->
        tpl_Ba
        } } in
    let {
      $dNum_avBy :: GHC.Num.Num (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      $dNum_avBy =
        case tup_avBm
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl_B4, _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_B4
        } } in
    let {
      tup_avBw :: CLaSH.Sized.Fixed.SatN2C rep_auGZ size_auH0
      [LclId, Str=DmdType]
      tup_avBw =
        (cobox_avN6,
         cobox_avN7,
         $dBitVector_avN8,
         $dBitVector_avN9,
         cobox_avNa,
         cobox_avNb,
         $dKnownNat_avMS,
         $dKnownNat_avMF,
         $dBounded_avNe,
         $dBits_avNf) } in
    \ (ds_dw0T :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
      (ds_dw0U
         :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
      CLaSH.Sized.Fixed.Fixed
        @ frac_auGY
        @ rep_auGZ
        @ size_auH0
        (CLaSH.Sized.Fixed.satN2
           @ rep_auGZ
           @ size_auH0
           tup_avBw
           (GHC.Num.+
              @ (rep_auGZ (size_auH0 GHC.TypeLits.+ 2))
              $dNum_avBy
              (CLaSH.Class.Num.resize
                 @ rep_auGZ
                 $dResize_avMR
                 @ size_auH0
                 @ (size_auH0 GHC.TypeLits.+ 2)
                 $dKnownNat_avMS
                 $dKnownNat_avMF
                 (ds_dw0T
                  `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                            <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
                          :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                               ~#
                             rep_auGZ size_auH0)))
              (CLaSH.Class.Num.resize
                 @ rep_auGZ
                 $dResize_avMR
                 @ size_auH0
                 @ (size_auH0 GHC.TypeLits.+ 2)
                 $dKnownNat_avMS
                 $dKnownNat_avMF
                 (ds_dw0U
                  `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                            <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
                          :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                               ~#
                             rep_auGZ size_auH0)))))

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auGY :: GHC.TypeLits.Nat))
             (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
             (@ (size_auH0 :: GHC.TypeLits.Nat))
             (tup_avBm
                :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_auGY rep_auGZ size_auH0
                     $c+_avBo @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm
                     $c*_avBP @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm
                     $c-_avCb @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm
                     $cnegate_avCC @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm
                     $cabs_avCW @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm
                     $csignum_avDg @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm
                     $cfromInteger_avDp @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
      ($c+_avBo @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm)
      ($c*_avBP @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm)
      ($c-_avCb @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm)
      ($cnegate_avCC @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm)
      ($cabs_avCW @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm)
      ($csignum_avDg @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm)
      ($cfromInteger_avDp @ frac_auGY @ rep_auGZ @ size_auH0 tup_avBm)

$cfromBV_avB8
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Vector.Vec
       (CLaSH.Class.BitVector.BitSize
          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
       CLaSH.Bit.Bit
     -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
[LclId, Str=DmdType]
$cfromBV_avB8 =
  \ (@ (frac_auGT :: GHC.TypeLits.Nat))
    (@ (rep_auGU :: GHC.TypeLits.Nat -> *))
    (@ (size_auGV :: GHC.TypeLits.Nat))
    ($dBitVector_avAW
       :: CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV))
    ($dKnownNat_avBa
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)))
    (bv_auGX
       :: CLaSH.Sized.Vector.Vec
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
            CLaSH.Bit.Bit) ->
    CLaSH.Sized.Fixed.Fixed
      @ frac_auGT
      @ rep_auGU
      @ size_auGV
      (CLaSH.Class.BitVector.fromBV
         @ (rep_auGU size_auGV)
         $dBitVector_avAW
         ($dKnownNat_avBa
          `cast` ((GHC.TypeLits.KnownNat
                     (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                        <frac_auGT>_N <rep_auGU>_N <size_auGV>_N))_R
                  :: GHC.TypeLits.KnownNat
                       (CLaSH.Class.BitVector.BitSize
                          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                       ~#
                     GHC.TypeLits.KnownNat
                       (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))))
         (bv_auGX
          `cast` ((CLaSH.Sized.Vector.Vec
                     (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                        <frac_auGT>_N <rep_auGU>_N <size_auGV>_N)
                     <CLaSH.Bit.Bit>_R)_R
                  :: CLaSH.Sized.Vector.Vec
                       (CLaSH.Class.BitVector.BitSize
                          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                       CLaSH.Bit.Bit
                       ~#
                     CLaSH.Sized.Vector.Vec
                       (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))
                       CLaSH.Bit.Bit)))

$ctoBV_avAY
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
     -> CLaSH.Sized.Vector.Vec
          (CLaSH.Class.BitVector.BitSize
             (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
          CLaSH.Bit.Bit
[LclId, Str=DmdType]
$ctoBV_avAY =
  \ (@ (frac_auGT :: GHC.TypeLits.Nat))
    (@ (rep_auGU :: GHC.TypeLits.Nat -> *))
    (@ (size_auGV :: GHC.TypeLits.Nat))
    ($dBitVector_avAW
       :: CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV))
    ($dKnownNat_avB0
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)))
    (ds_dw0H
       :: CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV) ->
    (CLaSH.Class.BitVector.toBV
       @ (rep_auGU size_auGV)
       $dBitVector_avAW
       ($dKnownNat_avB0
        `cast` ((GHC.TypeLits.KnownNat
                   (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                      <frac_auGT>_N <rep_auGU>_N <size_auGV>_N))_R
                :: GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                     ~#
                   GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))))
       (ds_dw0H
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGT>_P <rep_auGU>_R <size_auGV>_N
                :: CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
                     ~#
                   rep_auGU size_auGV)))
    `cast` ((CLaSH.Sized.Vector.Vec
               (Sym
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N))
               <CLaSH.Bit.Bit>_R)_R
            :: CLaSH.Sized.Vector.Vec
                 (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV)) CLaSH.Bit.Bit
                 ~#
               CLaSH.Sized.Vector.Vec
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                 CLaSH.Bit.Bit)

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auGT :: GHC.TypeLits.Nat))
             (@ (rep_auGU :: GHC.TypeLits.Nat -> *))
             (@ (size_auGV :: GHC.TypeLits.Nat))
             ($dBitVector_avAW
                :: CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_auGT rep_auGU size_auGV
                                         $ctoBV_avAY
                                           @ frac_auGT @ rep_auGU @ size_auGV $dBitVector_avAW
                                         $cfromBV_avB8
                                           @ frac_auGT @ rep_auGU @ size_auGV $dBitVector_avAW]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_auGT :: GHC.TypeLits.Nat))
    (@ (rep_auGU :: GHC.TypeLits.Nat -> *))
    (@ (size_auGV :: GHC.TypeLits.Nat))
    ($dBitVector_avAW
       :: CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV)) ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
      ($ctoBV_avAY @ frac_auGT @ rep_auGU @ size_auGV $dBitVector_avAW)
      ($cfromBV_avB8 @ frac_auGT @ rep_auGU @ size_auGV $dBitVector_avAW)

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId, Str=DmdType]
$cdef_avAg =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    CLaSH.Sized.Fixed.Fixed
      @ frac_auGL
      @ rep_auGM
      @ size_auGN
      (Data.Default.Class.def @ (rep_auGM size_auGN) $dDefault_avAe)

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (frac_auGL :: GHC.TypeLits.Nat))
                 (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
                 (@ (size_auGN :: GHC.TypeLits.Nat))
                 ($dDefault_avAe [Occ=Once]
                    :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
                 Data.Default.Class.D:Default
                   @ (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
                   ($cdef_avAg @ frac_auGL @ rep_auGM @ size_auGN $dDefault_avAe)}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    Data.Default.Class.D:Default
      @ (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
      ($cdef_avAg @ frac_auGL @ rep_auGM @ size_auGN $dDefault_avAe)

$cmaxBound_avA4
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId, Str=DmdType]
$cmaxBound_avA4 =
  \ (@ (frac_auGI :: GHC.TypeLits.Nat))
    (@ (rep_auGJ :: GHC.TypeLits.Nat -> *))
    (@ (size_auGK :: GHC.TypeLits.Nat))
    ($dBounded_avzT :: GHC.Enum.Bounded (rep_auGJ size_auGK)) ->
    CLaSH.Sized.Fixed.Fixed
      @ frac_auGI
      @ rep_auGJ
      @ size_auGK
      (GHC.Enum.maxBound @ (rep_auGJ size_auGK) $dBounded_avzT)

$cminBound_avzV
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId, Str=DmdType]
$cminBound_avzV =
  \ (@ (frac_auGI :: GHC.TypeLits.Nat))
    (@ (rep_auGJ :: GHC.TypeLits.Nat -> *))
    (@ (size_auGK :: GHC.TypeLits.Nat))
    ($dBounded_avzT :: GHC.Enum.Bounded (rep_auGJ size_auGK)) ->
    CLaSH.Sized.Fixed.Fixed
      @ frac_auGI
      @ rep_auGJ
      @ size_auGK
      (GHC.Enum.minBound @ (rep_auGJ size_auGK) $dBounded_avzT)

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auGI :: GHC.TypeLits.Nat))
             (@ (rep_auGJ :: GHC.TypeLits.Nat -> *))
             (@ (size_auGK :: GHC.TypeLits.Nat))
             ($dBounded_avzT :: GHC.Enum.Bounded (rep_auGJ size_auGK)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_auGI rep_auGJ size_auGK
                          $cminBound_avzV @ frac_auGI @ rep_auGJ @ size_auGK $dBounded_avzT
                          $cmaxBound_avA4 @ frac_auGI @ rep_auGJ @ size_auGK $dBounded_avzT]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_auGI :: GHC.TypeLits.Nat))
    (@ (rep_auGJ :: GHC.TypeLits.Nat -> *))
    (@ (size_auGK :: GHC.TypeLits.Nat))
    ($dBounded_avzT :: GHC.Enum.Bounded (rep_auGJ size_auGK)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
      ($cminBound_avzV @ frac_auGI @ rep_auGJ @ size_auGK $dBounded_avzT)
      ($cmaxBound_avA4 @ frac_auGI @ rep_auGJ @ size_auGK $dBounded_avzT)

$cmin_avzC
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId, Str=DmdType]
$cmin_avzC =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    let {
      $dCoercible_avLF
        :: GHC.Types.Coercible
             (rep_auFG size_auFH)
             (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
      [LclId, Str=DmdType]
      $dCoercible_avLF =
        GHC.Types.MkCoercible
          @ *
          @ (rep_auFG size_auFH)
          @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
          @~ (Sym
                (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                   <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N) } in
    GHC.Prim.coerce
      @ *
      @ (rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH)
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
      (case case $dCoercible_avLF
            of _ [Occ=Dead] { GHC.Types.MkCoercible $dCoercible_dw5s ->
            case $dCoercible_avLF
            of _ [Occ=Dead] { GHC.Types.MkCoercible $dCoercible_dw5t ->
            GHC.Types.MkCoercible
              @ *
              @ (rep_auFG size_auFH -> rep_auFG size_auFH)
              @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
                 -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
              @~ (($dCoercible_dw5s) -> ($dCoercible_dw5t))
            }
            }
       of _ [Occ=Dead] { GHC.Types.MkCoercible $dCoercible_dw5r ->
       GHC.Types.MkCoercible
         @ *
         @ (rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH)
         @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
         @~ (Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> ($dCoercible_dw5r))
       })
      (GHC.Classes.min @ (rep_auFG size_auFH) $dOrd_avyb)

$cmax_avzm
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId, Str=DmdType]
$cmax_avzm =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    let {
      $dCoercible_avLs
        :: GHC.Types.Coercible
             (rep_auFG size_auFH)
             (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
      [LclId, Str=DmdType]
      $dCoercible_avLs =
        GHC.Types.MkCoercible
          @ *
          @ (rep_auFG size_auFH)
          @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
          @~ (Sym
                (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                   <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N) } in
    GHC.Prim.coerce
      @ *
      @ (rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH)
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
      (case case $dCoercible_avLs
            of _ [Occ=Dead] { GHC.Types.MkCoercible $dCoercible_dw5o ->
            case $dCoercible_avLs
            of _ [Occ=Dead] { GHC.Types.MkCoercible $dCoercible_dw5p ->
            GHC.Types.MkCoercible
              @ *
              @ (rep_auFG size_auFH -> rep_auFG size_auFH)
              @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
                 -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
              @~ (($dCoercible_dw5o) -> ($dCoercible_dw5p))
            }
            }
       of _ [Occ=Dead] { GHC.Types.MkCoercible $dCoercible_dw5n ->
       GHC.Types.MkCoercible
         @ *
         @ (rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH)
         @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
         @~ (Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> ($dCoercible_dw5n))
       })
      (GHC.Classes.max @ (rep_auFG size_auFH) $dOrd_avyb)

$c<=_avz8
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId, Str=DmdType]
$c<=_avz8 =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Prim.coerce
      @ *
      @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> GHC.Types.Bool)
      (GHC.Types.MkCoercible
         @ *
         @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
         @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> GHC.Types.Bool)
         @~ (Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> <GHC.Types.Bool>_R))
      (GHC.Classes.<= @ (rep_auFG size_auFH) $dOrd_avyb)

$c>_avyU
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId, Str=DmdType]
$c>_avyU =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Prim.coerce
      @ *
      @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> GHC.Types.Bool)
      (GHC.Types.MkCoercible
         @ *
         @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
         @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> GHC.Types.Bool)
         @~ (Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> <GHC.Types.Bool>_R))
      (GHC.Classes.> @ (rep_auFG size_auFH) $dOrd_avyb)

$c>=_avyG
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId, Str=DmdType]
$c>=_avyG =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Prim.coerce
      @ *
      @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> GHC.Types.Bool)
      (GHC.Types.MkCoercible
         @ *
         @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
         @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> GHC.Types.Bool)
         @~ (Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> <GHC.Types.Bool>_R))
      (GHC.Classes.>= @ (rep_auFG size_auFH) $dOrd_avyb)

$c<_avys
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId, Str=DmdType]
$c<_avys =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Prim.coerce
      @ *
      @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> GHC.Types.Bool)
      (GHC.Types.MkCoercible
         @ *
         @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
         @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> GHC.Types.Bool)
         @~ (Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> <GHC.Types.Bool>_R))
      (GHC.Classes.< @ (rep_auFG size_auFH) $dOrd_avyb)

$ccompare_avye
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Ordering
[LclId, Str=DmdType]
$ccompare_avye =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Prim.coerce
      @ *
      @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Ordering)
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> GHC.Types.Ordering)
      (GHC.Types.MkCoercible
         @ *
         @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Ordering)
         @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> GHC.Types.Ordering)
         @~ (Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> <GHC.Types.Ordering>_R))
      (GHC.Classes.compare @ (rep_auFG size_auFH) $dOrd_avyb)

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auFF :: GHC.TypeLits.Nat))
             (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
             (@ (size_auFH :: GHC.TypeLits.Nat))
             ($dEq_avya
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH))
             ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_auFF rep_auFG size_auFH
                         $dEq_avya
                         $ccompare_avye
                           @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb
                         $c<_avys @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb
                         $c>=_avyG @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb
                         $c>_avyU @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb
                         $c<=_avz8 @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb
                         $cmax_avzm @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb
                         $cmin_avzC @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    ($dEq_avya
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH))
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
      $dEq_avya
      ($ccompare_avye
         @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb)
      ($c<_avys @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb)
      ($c>=_avyG @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb)
      ($c>_avyU @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb)
      ($c<=_avz8 @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb)
      ($cmax_avzm
         @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb)
      ($cmin_avzC
         @ frac_auFF @ rep_auFG @ size_auFH $dEq_avya $dOrd_avyb)

$c/=_avxV
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId, Str=DmdType]
$c/=_avxV =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    ($dEq_avxF :: GHC.Classes.Eq (rep_auFG size_auFH)) ->
    GHC.Prim.coerce
      @ *
      @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> GHC.Types.Bool)
      (GHC.Types.MkCoercible
         @ *
         @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
         @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> GHC.Types.Bool)
         @~ (Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> <GHC.Types.Bool>_R))
      (GHC.Classes./= @ (rep_auFG size_auFH) $dEq_avxF)

$c==_avxH
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId, Str=DmdType]
$c==_avxH =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    ($dEq_avxF :: GHC.Classes.Eq (rep_auFG size_auFH)) ->
    GHC.Prim.coerce
      @ *
      @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
         -> GHC.Types.Bool)
      (GHC.Types.MkCoercible
         @ *
         @ (rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool)
         @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
            -> GHC.Types.Bool)
         @~ (Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
             -> <GHC.Types.Bool>_R))
      (GHC.Classes.== @ (rep_auFG size_auFH) $dEq_avxF)

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auFF :: GHC.TypeLits.Nat))
             (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
             (@ (size_auFH :: GHC.TypeLits.Nat))
             ($dEq_avxF :: GHC.Classes.Eq (rep_auFG size_auFH)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_auFF rep_auFG size_auFH
                        $c==_avxH @ frac_auFF @ rep_auFG @ size_auFH $dEq_avxF
                        $c/=_avxV @ frac_auFF @ rep_auFG @ size_auFH $dEq_avxF]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    ($dEq_avxF :: GHC.Classes.Eq (rep_auFG size_auFH)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
      ($c==_avxH @ frac_auFF @ rep_auFG @ size_auFH $dEq_avxF)
      ($c/=_avxV @ frac_auFF @ rep_auFG @ size_auFH $dEq_avxF)

CLaSH.Sized.Fixed.decFixed
  :: GHC.Integer.Type.Integer
     -> Data.Typeable.Internal.TypeRep
     -> GHC.Integer.Type.Integer
     -> Language.Haskell.TH.Lib.TypeQ
[LclId, Str=DmdType]
CLaSH.Sized.Fixed.decFixed =
  \ (f_auGe :: GHC.Integer.Type.Integer)
    (r_auGf :: Data.Typeable.Internal.TypeRep)
    (s_auGg :: GHC.Integer.Type.Integer) ->
    GHC.List.foldl
      @ Language.Haskell.TH.Lib.TypeQ
      @ Language.Haskell.TH.Lib.TypeQ
      Language.Haskell.TH.Lib.appT
      (Language.Haskell.TH.Lib.conT
         (Language.Haskell.TH.Syntax.mkNameG_tc
            (GHC.CString.unpackCString# "clash-prelude-0.5"#)
            (GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#)
            (GHC.CString.unpackCString# "Fixed"#)))
      (GHC.Base.build
         @ Language.Haskell.TH.Lib.TypeQ
         (\ (@ a_dvZ6)
            (c_dvZ7 [OS=OneShot]
               :: Language.Haskell.TH.Lib.TypeQ -> a_dvZ6 -> a_dvZ6)
            (n_dvZ8 [OS=OneShot] :: a_dvZ6) ->
            c_dvZ7
              (Language.Haskell.TH.Lib.litT
                 (Language.Haskell.TH.Lib.numTyLit f_auGe))
              (c_dvZ7
                 (Language.Haskell.TH.Lib.conT
                    (Language.Haskell.TH.Syntax.mkName
                       (GHC.Show.show
                          @ Data.Typeable.Internal.TypeRep
                          Data.Typeable.Internal.$fShowTypeRep
                          r_auGf)))
                 (c_dvZ7
                    (Language.Haskell.TH.Lib.litT
                       (Language.Haskell.TH.Lib.numTyLit s_auGg))
                    (GHC.Base.foldr
                       @ Language.Haskell.TH.Lib.TypeQ
                       @ a_dvZ6
                       c_dvZ7
                       n_dvZ8
                       (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ))))))

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
$clift_avAv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    Language.Haskell.TH.Lib.sigE
      (Language.Haskell.TH.Lib.appE
         (Language.Haskell.TH.Lib.conE
            (Language.Haskell.TH.Syntax.mkNameG_d
               (GHC.CString.unpackCString# "clash-prelude-0.5"#)
               (GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#)
               (GHC.CString.unpackCString# "Fixed"#)))
         (Language.Haskell.TH.Syntax.lift
            @ (rep_auGP size_auGQ)
            $dLift_avAq
            (f_auGR
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                          ~#
                        rep_auGP size_auGQ))))
      (CLaSH.Sized.Fixed.decFixed
         (GHC.TypeLits.natVal
            @ frac_auGO
            @ Data.Proxy.Proxy
            $dKnownNat_avAr
            (CLaSH.Sized.Fixed.asFracProxy
               @ frac_auGO @ rep_auGP @ size_auGQ f_auGR))
         (Data.Typeable.Internal.typeRep
            @ (GHC.TypeLits.Nat -> *)
            @ Data.Proxy.Proxy
            @ rep_auGP
            $dTypeable_avAt
            (CLaSH.Sized.Fixed.asRepProxy
               @ frac_auGO @ rep_auGP @ size_auGQ f_auGR))
         (GHC.TypeLits.natVal
            @ size_auGQ
            @ (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP)
            $dKnownNat_avAs
            f_auGR))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=False)
         Tmpl= \ (@ (frac_auGO :: GHC.TypeLits.Nat))
                 (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
                 (@ (size_auGQ :: GHC.TypeLits.Nat))
                 ($dLift_avAq [Occ=Once]
                    :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
                 ($dKnownNat_avAr [Occ=Once] :: GHC.TypeLits.KnownNat frac_auGO)
                 ($dKnownNat_avAs [Occ=Once] :: GHC.TypeLits.KnownNat size_auGQ)
                 ($dTypeable_avAt [Occ=Once]
                    :: Data.Typeable.Internal.Typeable rep_auGP) ->
                 Language.Haskell.TH.Syntax.D:Lift
                   @ (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
                   ($clift_avAv
                      @ frac_auGO
                      @ rep_auGP
                      @ size_auGQ
                      $dLift_avAq
                      $dKnownNat_avAr
                      $dKnownNat_avAs
                      $dTypeable_avAt)}]
CLaSH.Sized.Fixed.$fLiftFixed =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP) ->
    Language.Haskell.TH.Syntax.D:Lift
      @ (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
      ($clift_avAv
         @ frac_auGO
         @ rep_auGP
         @ size_auGQ
         $dLift_avAq
         $dKnownNat_avAr
         $dKnownNat_avAs
         $dTypeable_avAt)



*** Simplifier:
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]],
     $cshowList{v avIE} [lid], $cshowsPrec{v avFB} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [$csignum{v avDg} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind [$cfromBV{v avB8} [lid]]
SimplBind [$ctoBV{v avAY} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind [$cmaxBound{v avA4} [lid]]
SimplBind [$cminBound{v avzV} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind [$cmin{v avzC} [lid]]
SimplBind [$cmax{v avzm} [lid]]
SimplBind [$c<={v avz8} [lid]]
SimplBind [$c>{v avyU} [lid]]
SimplBind [$c>={v avyG} [lid]]
SimplBind [$c<{v avys} [lid]]
SimplBind [$ccompare{v avye} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind [$c/={v avxV} [lid]]
SimplBind [$c=={v avxH} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.decFixed{v ruEI} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=1
  = {terms: 2,013, types: 11,377, coercions: 858}
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]],
     $cshowList{v avIE} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [$csignum{v avDg} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind [a_swhq{v} [lid]]
SimplBind [$cfromBV{v avB8} [lid]]
SimplBind [a_swhr{v} [lid]]
SimplBind [$ctoBV{v avAY} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swhs{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind [a_swht{v} [lid]]
SimplBind [$cmaxBound{v avA4} [lid]]
SimplBind [a_swhu{v} [lid]]
SimplBind [$cminBound{v avzV} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind [$cmin{v avzC} [lid]]
SimplBind [$cmax{v avzm} [lid]]
SimplBind [a_swhz{v} [lid]]
SimplBind [$c<={v avz8} [lid]]
SimplBind [a_swhA{v} [lid]]
SimplBind [$c>{v avyU} [lid]]
SimplBind [a_swhB{v} [lid]]
SimplBind [$c>={v avyG} [lid]]
SimplBind [a_swhC{v} [lid]]
SimplBind [$c<{v avys} [lid]]
SimplBind [a_swhD{v} [lid]]
SimplBind [$ccompare{v avye} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind [a_swhE{v} [lid]]
SimplBind [$c/={v avxV} [lid]]
SimplBind [a_swhF{v} [lid]]
SimplBind [$c=={v avxH} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=2
  = {terms: 1,801, types: 11,176, coercions: 925}
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]],
     $cshowList{v avIE} [lid]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$csignum{v avDg} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind [a_swhq{v} [lid]]
SimplBind [$cfromBV{v avB8} [lid]]
SimplBind [a_swhr{v} [lid]]
SimplBind [$ctoBV{v avAY} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swhs{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind [a_swht{v} [lid]]
SimplBind [$cmaxBound{v avA4} [lid]]
SimplBind [a_swhu{v} [lid]]
SimplBind [$cminBound{v avzV} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind [a_swlr{v} [lid]]
SimplBind [$cmin{v avzC} [lid]]
SimplBind [a_swls{v} [lid]]
SimplBind [$cmax{v avzm} [lid]]
SimplBind [a_swhz{v} [lid]]
SimplBind [$c<={v avz8} [lid]]
SimplBind [a_swhA{v} [lid]]
SimplBind [$c>{v avyU} [lid]]
SimplBind [a_swhB{v} [lid]]
SimplBind [$c>={v avyG} [lid]]
SimplBind [a_swhC{v} [lid]]
SimplBind [$c<{v avys} [lid]]
SimplBind [a_swhD{v} [lid]]
SimplBind [$ccompare{v avye} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind [a_swhE{v} [lid]]
SimplBind [$c/={v avxV} [lid]]
SimplBind [a_swhF{v} [lid]]
SimplBind [$c=={v avxH} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=3
  = {terms: 1,808, types: 11,336, coercions: 844}
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]],
     $cshowList{v avIE} [lid]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$csignum{v avDg} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind [a_swhq{v} [lid]]
SimplBind [$cfromBV{v avB8} [lid]]
SimplBind [a_swhr{v} [lid]]
SimplBind [$ctoBV{v avAY} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swhs{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind [a_swht{v} [lid]]
SimplBind [$cmaxBound{v avA4} [lid]]
SimplBind [a_swhu{v} [lid]]
SimplBind [$cminBound{v avzV} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind [a_swlr{v} [lid]]
SimplBind [$cmin{v avzC} [lid]]
SimplBind [a_swls{v} [lid]]
SimplBind [$cmax{v avzm} [lid]]
SimplBind [a_swhz{v} [lid]]
SimplBind [$c<={v avz8} [lid]]
SimplBind [a_swhA{v} [lid]]
SimplBind [$c>{v avyU} [lid]]
SimplBind [a_swhB{v} [lid]]
SimplBind [$c>={v avyG} [lid]]
SimplBind [a_swhC{v} [lid]]
SimplBind [$c<{v avys} [lid]]
SimplBind [a_swhD{v} [lid]]
SimplBind [$ccompare{v avye} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind [a_swhE{v} [lid]]
SimplBind [$c/={v avxV} [lid]]
SimplBind [a_swhF{v} [lid]]
SimplBind [$c=={v avxH} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]

==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = InitialPhase [Gentle],
             no inline,
             rules,
             eta-expand,
             no case-of-case}
Result size of Simplifier
  = {terms: 1,808, types: 11,336, coercions: 844}

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.fLit =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      truncated_auGG :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 140 0}]
      truncated_auGG =
        GHC.Float.RealFracMethods.truncateDoubleInteger
          (GHC.Float.timesDouble
             a_auGC
             (GHC.Real.^
                @ GHC.Types.Double
                @ GHC.Integer.Type.Integer
                GHC.Float.$fNumDouble
                GHC.Real.$fIntegralInteger
                (GHC.Types.D# 2.0)
                (GHC.TypeLits.natVal
                   @ frac_avhM
                   @ Data.Proxy.Proxy
                   $dKnownNat_avlM
                   (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avhM)))) } in
    let {
      rMin_auGE :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 50 0}]
      rMin_auGE =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    let {
      rMax_auGD :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 50 0}]
      rMax_auGD =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    Language.Haskell.TH.Syntax.unsafeTExpCoerce
      @ (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)
      (Language.Haskell.TH.Lib.appE
         (Language.Haskell.TH.Lib.conE
            (Language.Haskell.TH.Syntax.mkNameG_d
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#))))
         (Language.Haskell.TH.Lib.appE
            (Language.Haskell.TH.Lib.varE
               (Language.Haskell.TH.Syntax.mkNameG_v
                  (GHC.Base.build
                     @ GHC.Types.Char
                     (\ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "base"#))
                  (GHC.Base.build
                     @ GHC.Types.Char
                     (\ (@ b_a4Iy) ->
                        GHC.CString.unpackFoldrCString# @ b_a4Iy "GHC.Num"#))
                  (GHC.Base.build
                     @ GHC.Types.Char
                     (\ (@ b_a4Iy) ->
                        GHC.CString.unpackFoldrCString# @ b_a4Iy "fromInteger"#))))
            (Language.Haskell.TH.Syntax.lift
               @ GHC.Integer.Type.Integer
               Language.Haskell.TH.Syntax.$fLiftInteger
               (case GHC.Integer.Type.gtInteger truncated_auGG rMax_auGD
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger truncated_auGG rMin_auGE
                    of _ [Occ=Dead] {
                      GHC.Types.False -> truncated_auGG;
                      GHC.Types.True -> rMin_auGE
                    };
                  GHC.Types.True -> rMax_auGD
                }))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    let {
      cobox_avIU
        :: CLaSH.Class.BitVector.BitSize
             (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      cobox_avIU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        } } in
    let {
      cobox_avIT
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      cobox_avIT =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    let {
      cobox_avIQ
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      cobox_avIQ =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      repBV_auGx
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 90 0}]
      repBV_auGx =
        case case cobox_avIU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
             GHC.Types.Eq#
               @ *
               @ (CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                    CLaSH.Bit.Bit)
               @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
               @~ (CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_N)_N
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6X ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of _ [Occ=Dead]
            { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
            tpl_B4
            })
           (case cobox_avIU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Y ->
            (case tup_avmQ
             of _ [Occ=Dead]
             { (tpl_X1x, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
             tpl_B8
             })
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Y))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2))))
            })
           eta_B1)
        `cast` (Sub cobox_dw6X
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        } } in
    let {
      s_auGA :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 70 0}]
      s_auGA =
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (case case case cobox_avIQ
                        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ (n_aviz GHC.TypeLits.+ 2)
                          @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                          @~ (Sym cobox_dw7d)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw75 ->
                   GHC.Types.Eq#
                     @ *
                     @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                     @ (CLaSH.Sized.Vector.Vec
                          ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                     @~ (CLaSH.Sized.Vector.Vec cobox_dw75 <CLaSH.Bit.Bit>_N)_N
                   }
              of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvY9 ->
              repBV_auGx
              `cast` (Sub cobox_dvY9
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
              })) } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of _ [Occ=Dead]
            { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
            tpl_Ba
            })
           eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          ds_dvY4 :: CLaSH.Bit.Bit
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 70 0}]
          ds_dvY4 =
            CLaSH.Sized.Vector.vhead
              @ n_aviz
              @ CLaSH.Bit.Bit
              (CLaSH.Sized.Vector.vtail
                 @ (n_aviz GHC.TypeLits.+ 1)
                 @ CLaSH.Bit.Bit
                 (case case case cobox_avIQ
                            of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7g ->
                            GHC.Types.Eq#
                              @ GHC.TypeLits.Nat
                              @ (n_aviz GHC.TypeLits.+ 2)
                              @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                              @~ (Sym cobox_dw7g)
                            }
                       of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw73 ->
                       GHC.Types.Eq#
                         @ *
                         @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                         @ (CLaSH.Sized.Vector.Vec
                              ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                         @~ (CLaSH.Sized.Vector.Vec cobox_dw73 <CLaSH.Bit.Bit>_N)_N
                       }
                  of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvYc ->
                  repBV_auGx
                  `cast` (Sub cobox_dvYc
                          :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                               ~#
                             CLaSH.Sized.Vector.Vec
                               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                  })) } in
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_avIQ
                          of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw71 ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6W ->
                repBV_auGx
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case ds_dvY4 of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6T ->
                   s_auGA
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case ds_dvY4 of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6T ->
                   s_auGA
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        };
      GHC.Types.True ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_avIQ
                          of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw71 ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6W ->
                repBV_auGx
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1p, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_X1p
                    })
                   s_auGA
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6S ->
                   s_auGA
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1p, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_X1p
                    })
                   s_auGA
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_avIT of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6S ->
                   s_auGA
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
    }

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_avJB :: GHC.TypeLits.KnownNat size1_avjt
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avJB =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    let {
      $dKnownNat_avJA :: GHC.TypeLits.KnownNat size2_avju
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avJA =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dResize_avJz :: CLaSH.Class.Num.Resize rep_avjs
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_avJz =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dBits_avJy :: Data.Bits.Bits (rep_avjs size1_avjt)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_avJy =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1o, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dNum_avJx :: GHC.Num.Num (rep_avjs size1_avjt)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dNum_avJx =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B4
        } } in
    let {
      $dBounded_avJu :: GHC.Enum.Bounded (rep_avjs size2_avju)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_avJu =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1u
        } } in
    let {
      resFracSZ_auGl :: GHC.Types.Int
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 60 0}]
      resFracSZ_auGl =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac2_avjr
             @ Data.Proxy.Proxy
             (case tup_avnK
              of _ [Occ=Dead]
              { (tpl_X1w, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac2_avjr)) } in
    let {
      argFracSZ_auGk :: GHC.Types.Int
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 60 0}]
      argFracSZ_auGk =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac1_avjq
             @ Data.Proxy.Proxy
             (case tup_avnK
              of _ [Occ=Dead]
              { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Bb
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac1_avjq)) } in
    case GHC.Integer.Type.leInteger
           (GHC.TypeLits.natVal
              @ size1_avjt
              @ Data.Proxy.Proxy
              $dKnownNat_avJB
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size1_avjt))
           (GHC.TypeLits.natVal
              @ size2_avju
              @ Data.Proxy.Proxy
              $dKnownNat_avJA
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size2_avju))
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          fMax_auGn :: rep_avjs size2_avju
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          fMax_auGn =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_avJu } in
        let {
          mask_auGp :: rep_avjs size1_avjt
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 80 0}]
          mask_auGp =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_avJy
              (CLaSH.Class.Num.resize
                 @ rep_avjs
                 $dResize_avJz
                 @ size2_avju
                 @ size1_avjt
                 $dKnownNat_avJA
                 $dKnownNat_avJB
                 fMax_auGn) } in
        case GHC.Classes.leInt argFracSZ_auGk resFracSZ_auGl
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_auGt :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 70 0}]
              shiftedR_auGt =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_avJy
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- argFracSZ_auGk resFracSZ_auGl) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of _ [Occ=Dead]
                    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) $dNum_avJx (__integer 0))
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_avJy)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_avJy shiftedR_auGt mask_auGp)
                       mask_auGp
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_avJu)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_avJz
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_avJB
                       $dKnownNat_avJA
                       shiftedR_auGt)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_avJy)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_avJy shiftedR_auGt mask_auGp)
                       (GHC.Num.fromInteger
                          @ (rep_avjs size1_avjt) $dNum_avJx (__integer 0))
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_auGn
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_avJz
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_avJB
                       $dKnownNat_avJA
                       shiftedR_auGt)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_auGq :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 70 0}]
              shiftedL_auGq =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_avJy
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- resFracSZ_auGl argFracSZ_auGk) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of _ [Occ=Dead]
                    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) $dNum_avJx (__integer 0))
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_avJy)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_avJy shiftedL_auGq mask_auGp)
                       mask_auGp
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_avJu)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_avJz
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_avJB
                       $dKnownNat_avJA
                       shiftedL_auGq)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_avJy)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_avJy shiftedL_auGq mask_auGp)
                       (GHC.Num.fromInteger
                          @ (rep_avjs size1_avjt) $dNum_avJx (__integer 0))
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_auGn
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_avJz
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_avJB
                       $dKnownNat_avJA
                       shiftedL_auGq)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        };
      GHC.Types.True ->
        case GHC.Classes.leInt argFracSZ_auGk resFracSZ_auGl
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of _ [Occ=Dead]
                { (tpl_X1h, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_avJz
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_avJB
                  $dKnownNat_avJA
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- argFracSZ_auGk resFracSZ_auGl))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of _ [Occ=Dead]
                { (tpl_X1h, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_avJz
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_avJB
                  $dKnownNat_avJA
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- resFracSZ_auGl argFracSZ_auGk))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 70 0}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    (f_auGd :: CLaSH.Sized.Fixed.Fixed frac_avjN rep_avjO size_avjP) ->
    GHC.Num.$fNumInt_$cfromInteger
      (GHC.TypeLits.natVal
         @ frac_avjN
         @ Data.Proxy.Proxy
         $dKnownNat_avxa
         (CLaSH.Sized.Fixed.asFracProxy
            @ frac_avjN @ rep_avjO @ size_avjP f_auGd))

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      fRepI_auHE :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 30 0}]
      fRepI_auHE =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      fRepI_abs_auHF :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 20 0}]
      fRepI_abs_auHF = GHC.Integer.Type.absInteger fRepI_auHE } in
    let {
      nF_auHD :: GHC.Types.Int
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 30 0}]
      nF_auHD =
        CLaSH.Sized.Fixed.fracShift
          @ frac_auHx @ rep_auHy @ size_auHz $dKnownNat_avFx f_auHA } in
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a4II)
         (c_a4IJ [OS=OneShot] :: GHC.Types.Char -> b_a4II -> b_a4II)
         (n_a4IK [OS=OneShot] :: b_a4II) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a4II
           c_a4IJ
           n_a4IK
           (case GHC.Integer.Type.ltInteger fRepI_auHE (__integer 0)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Show.$fShowInteger_$cshow
                  (Data.Bits.$fBitsInteger_$cshiftR fRepI_auHE nF_auHD);
              GHC.Types.True ->
                GHC.Types.:
                  @ GHC.Types.Char
                  (GHC.Types.C# '-')
                  (GHC.Show.$fShowInteger_$cshow
                     (Data.Bits.$fBitsInteger_$cshiftR fRepI_abs_auHF nF_auHD))
            }))
      (GHC.Base.augment
         @ GHC.Types.Char
         (\ (@ b_X4Kn)
            (c_X4Kp [OS=OneShot] :: GHC.Types.Char -> b_X4Kn -> b_X4Kn)
            (n_X4Kr [OS=OneShot] :: b_X4Kn) ->
            c_X4Kp (GHC.Types.C# '.') n_X4Kr)
         (GHC.Base.$
            @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
            @ [GHC.Types.Char]
            (GHC.Base..
               @ (GHC.Types.Int, [GHC.Types.Char])
               @ [GHC.Types.Char]
               @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
               (Data.Tuple.uncurry
                  @ GHC.Types.Int
                  @ [GHC.Types.Char]
                  @ [GHC.Types.Char]
                  (\ (n_auHJ [OS=ProbOneShot] :: GHC.Types.Int)
                     (str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]) ->
                     GHC.Base.augment
                       @ GHC.Types.Char
                       (\ (@ b_X4M9)
                          (c_X4Mc [OS=OneShot] :: GHC.Types.Char -> b_X4M9 -> b_X4M9)
                          (n_X4Kt [OS=OneShot] :: b_X4M9) ->
                          GHC.Base.foldr
                            @ GHC.Types.Char
                            @ b_X4M9
                            c_X4Mc
                            n_X4Kt
                            (GHC.List.replicate
                               @ GHC.Types.Char
                               (GHC.Num.$fNumInt_$c-
                                  n_auHJ
                                  (GHC.Base.foldr
                                     @ GHC.Types.Char
                                     @ (GHC.Prim.Int# -> GHC.Types.Int)
                                     (GHC.List.incLen @ GHC.Types.Char)
                                     GHC.Types.I#
                                     str_auHK
                                     0))
                               (GHC.Types.C# '0')))
                       str_auHK))
               (GHC.Base..
                  @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                  @ (GHC.Types.Int, [GHC.Types.Char])
                  @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                  (Control.Arrow.$fArrow(->)_$csecond
                     @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                     @ [GHC.Types.Char]
                     @ GHC.Types.Int
                     (GHC.Base..
                        @ GHC.Integer.Type.Integer
                        @ GHC.Base.String
                        @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                        GHC.Show.$fShowInteger_$cshow
                        (GHC.Real.numerator
                           @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger)))
                  (GHC.Base..
                     @ (Data.Maybe.Maybe
                          (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                     @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                     @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                     (Data.Maybe.fromJust
                        @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                     (GHC.Base..
                        @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                        @ (Data.Maybe.Maybe
                             (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                        @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                        (Data.List.find
                           @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                           (GHC.Base..
                              @ GHC.Integer.Type.Integer
                              @ GHC.Types.Bool
                              @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                              (let {
                                 ds_dw45 :: GHC.Integer.Type.Integer
                                 [LclId,
                                  Str=DmdType,
                                  Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=True,
                                          ConLike=True, WorkFree=True, Expandable=True,
                                          Guidance=IF_ARGS [] 100 0}]
                                 ds_dw45 = __integer 1 } in
                               \ (ds_dw44 [OS=ProbOneShot] :: GHC.Integer.Type.Integer) ->
                                 GHC.Integer.Type.eqInteger ds_dw44 ds_dw45)
                              (GHC.Base..
                                 @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 @ GHC.Integer.Type.Integer
                                 @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 (GHC.Real.denominator
                                    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger)
                                 (Data.Tuple.snd
                                    @ GHC.Types.Int @ (GHC.Real.Ratio GHC.Integer.Type.Integer)))))
                        (GHC.Base..
                           @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                           @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                           @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                           (GHC.List.iterate
                              @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                              (Control.Arrow.$fArrow(->)_$c***
                                 @ GHC.Types.Int
                                 @ GHC.Types.Int
                                 @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 GHC.Enum.$fEnumInt_$csucc
                                 (let {
                                    ds_dw48 :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                    [LclId,
                                     Str=DmdType,
                                     Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                             ConLike=False, WorkFree=False, Expandable=False,
                                             Guidance=IF_ARGS [] 120 0}]
                                    ds_dw48 =
                                      GHC.Real.$fNumRatio_$s$cfromInteger (__integer 10) } in
                                  \ (ds_dw47 [OS=ProbOneShot]
                                       :: GHC.Real.Ratio GHC.Integer.Type.Integer) ->
                                    GHC.Real.$fNumRatio_$s$c* ds_dw47 ds_dw48)))
                           (GHC.Tuple.(,)
                              @ GHC.Types.Int
                              @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                              (GHC.Types.I# 0)))))))
            (GHC.Real.%_$s%
               (case GHC.Integer.Type.ltInteger fRepI_auHE (__integer 0)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    GHC.Integer.Type.andInteger
                      fRepI_auHE
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            (__integer 2)
                            nF_auHD)
                         (__integer 1));
                  GHC.Types.True ->
                    GHC.Integer.Type.andInteger
                      fRepI_abs_auHF
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            (__integer 2)
                            nF_auHD)
                         (__integer 1))
                })
               (GHC.Real.^
                  @ GHC.Integer.Type.Integer
                  @ GHC.Types.Int
                  GHC.Num.$fNumInteger
                  GHC.Real.$fIntegralInt
                  (__integer 2)
                  nF_auHD))))

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 120 40}]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a2g3)
         (c_a2g4 [OS=OneShot] :: GHC.Types.Char -> b_a2g3 -> b_a2g3)
         (n_a2g5 [OS=OneShot] :: b_a2g3) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a2g3
           c_a2g4
           n_a2g5
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY))
      s_a2fZ

Rec {
CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

$cshowList_avIE [Occ=LoopBreaker]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId,
 Arity=4,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0] 140 60}]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    let {
      $dShow_a2fj
        :: GHC.Show.Show
             (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=True, WorkFree=False, Expandable=True,
               Guidance=IF_ARGS [] 50 0}]
      $dShow_a2fj =
        CLaSH.Sized.Fixed.$fShowFixed
          @ frac_auHx
          @ rep_auHy
          @ size_auHz
          $dShow_avFv
          $dBits_avFw
          $dKnownNat_avFx
          $dIntegral_avFy } in
    \ (ls_a2fk
         :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
      (s_a2fl :: GHC.Base.String) ->
      GHC.Show.showList__
        @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
        (GHC.Show.shows
           @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
           $dShow_a2fj)
        ls_a2fk
        s_a2fl
end Rec }

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 70 0}]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl_X1B) ->
         tpl_X1B
         }
    of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
    (CLaSH.Class.Num.mult
       @ (rep_auHr size1_auHs)
       @ (rep_auHr size2_auHu)
       (case tup_avFg of _ [Occ=Dead] { (tpl_X1C, tpl_X1E) -> tpl_X1C })
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  $cmult_avFi
  `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                 (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                 (size1_XuJ3 :: GHC.TypeLits.Nat)
                 (frac2_XuJ5 :: GHC.TypeLits.Nat)
                 (size2_XuJ7 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
          -> Sym
               (CLaSH.Class.Num.NTCo:Mult[0]
                  <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                  <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
          :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
              -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                   (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
               ~#
             (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 450 0}]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_avU6
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avU6 =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1L, tpl_X1N, tpl_B3) ->
        tpl_X1N
        } } in
    let {
      $dBounded_avUu
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_avUu =
        case tup_avU6
        of _ [Occ=Dead]
        { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1N
        } } in
    let {
      $dBits_avUy :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_avUy =
        case tup_avU6
        of _ [Occ=Dead]
        { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_avUz :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_avUz =
        case tup_avU6
        of _ [Occ=Dead]
        { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_avUA
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avUA =
        case tup_avU6
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_avUC
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_avUC =
        case tup_avU6
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_avUD
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avUD =
        case tup_avU6
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    let {
      tup_avU5
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avU5 =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1Z, tpl_X21, tpl_B3) ->
        tpl_X1Z
        } } in
    let {
      $dBits_avUc :: Data.Bits.Bits (rep_auHe size1_auHf)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_avUc =
        case tup_avU5
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl_X24, tpl_B3) ->
        tpl_B3
        })
       ((CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_avUu,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_avUc,
            case tup_avU5
            of _ [Occ=Dead]
            { (tpl_X43, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_avU5
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X46, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_avUc,
            $dResize_avUz,
            $dKnownNat_avUA,
            case tup_avU5
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_avUC,
            $dKnownNat_avUD,
            case tup_avU5
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_avU5
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_avUu,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_avUy,
            case tup_avU6
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_avU6
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_avUy,
            $dResize_avUz,
            $dKnownNat_avUA,
            case tup_avU6
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_avUC,
            $dKnownNat_avUD,
            case tup_avU6
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_avU6
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 450 0}]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_avSG
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avSG =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1M, tpl_X1O, tpl_B3) ->
        tpl_X1O
        } } in
    let {
      $dBounded_avT4
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_avT4 =
        case tup_avSG
        of _ [Occ=Dead]
        { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1O
        } } in
    let {
      $dBits_avT8 :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_avT8 =
        case tup_avSG
        of _ [Occ=Dead]
        { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_avT9 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_avT9 =
        case tup_avSG
        of _ [Occ=Dead]
        { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_avTa
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avTa =
        case tup_avSG
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_avTc
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_avTc =
        case tup_avSG
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_avTd
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avTd =
        case tup_avSG
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    let {
      tup_avSF
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avSF =
        case tup_avDN of _ [Occ=Dead] { (tpl_X20, tpl_X22, tpl_B3) ->
        tpl_X20
        } } in
    let {
      $dBits_avSM :: Data.Bits.Bits (rep_auHe size1_auHf)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_avSM =
        case tup_avSF
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl_X25, tpl_B3) ->
        tpl_B3
        })
       ((CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_avT4,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_avSM,
            case tup_avSF
            of _ [Occ=Dead]
            { (tpl_X45, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_avSF
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X48, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_avSM,
            $dResize_avT9,
            $dKnownNat_avTa,
            case tup_avSF
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_avTc,
            $dKnownNat_avTd,
            case tup_avSF
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_avSF
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_avT4,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_avT8,
            case tup_avSG
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_avSG
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_avT8,
            $dResize_avT9,
            $dKnownNat_avTa,
            case tup_avSG
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_avTc,
            $dKnownNat_avTd,
            case tup_avSG
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_avSG
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0] 170 0}]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    let {
      tup_avRs
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avRs =
        case tup_avBm
        of _ [Occ=Dead]
        { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1N
        } } in
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       (case tup_avRs
        of _ [Occ=Dead]
        { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        })
       (GHC.Num.fromInteger
          @ (rep_auGZ size_auH0)
          (case tup_avBm
           of _ [Occ=Dead]
           { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B3
           })
          eta_X1I)
       (GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac_auGY
             @ Data.Proxy.Proxy
             (case tup_avRs
              of _ [Occ=Dead]
              { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_auGY))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      (case tup_avBm
       of _ [Occ=Dead]
       { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       tpl_B3
       })
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))

$csignum_avDg
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$csignum_avDg =
  a_swkh
  `cast` (forall (frac_auGY :: GHC.TypeLits.Nat)
                 (rep_auGZ :: GHC.TypeLits.Nat -> *)
                 (size_auH0 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
          :: (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> rep_auGZ size_auH0)
               ~#
             (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0))

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 300 0}]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup_avQ0
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avQ0 =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1V
        } } in
    let {
      $dKnownNat_avQp :: GHC.TypeLits.KnownNat size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avQp =
        case tup_avQ0
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_avPZ :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avPZ =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1X
        } } in
    let {
      $dKnownNat_avQc
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avQc =
        case tup_avPZ
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_avPZ
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_avPZ
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_avPZ
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_avPZ
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_avPZ
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_avPZ
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_avQp,
        $dKnownNat_avQc,
        case tup_avQ0
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_avPZ
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          (case tup_XvDa
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIL
             (case tup_avQ0
              of _ [Occ=Dead]
              { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B6
              })
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_avQp
             $dKnownNat_avQc
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 300 0}]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup_avP8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avP8 =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1W
        } } in
    let {
      $dKnownNat_avPx :: GHC.TypeLits.KnownNat size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avPx =
        case tup_avP8
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_avP7 :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avP7 =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_avPk
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avPk =
        case tup_avP7
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_avP7
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_avP7
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_avP7
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_avP7
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_avP7
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_avP7
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_avPx,
        $dKnownNat_avPk,
        case tup_avP8
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_avP7
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          (case tup_XvDb
           of _ [Occ=Dead]
           { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIM
             (case tup_avP8
              of _ [Occ=Dead]
              { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B6
              })
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_avPx
             $dKnownNat_avPk
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 370 0}]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup_avOg
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avOg =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dResize_avOE :: CLaSH.Class.Num.Resize rep_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_avOE =
        case tup_avOg
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_avOF :: GHC.TypeLits.KnownNat size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avOF =
        case tup_avOg
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_avOf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avOf =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X22
        } } in
    let {
      $dKnownNat_avOs
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avOs =
        case tup_avOf
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_avOf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_avOf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_avOf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_avOf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_avOf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_avOf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_avOF,
        $dKnownNat_avOs,
        case tup_avOg
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_avOf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          (case tup_XvDc
           of _ [Occ=Dead]
           { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_avOE
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_avOF
             $dKnownNat_avOs
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_avOE
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_avOF
             $dKnownNat_avOs
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 270 0}]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup_avNl
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avNl =
        case tup_XvDd
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Z
        } } in
    let {
      $dBits_avNI
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_avNI =
        case tup_avNl
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_avNI,
       case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B3
       },
       case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B4
       },
       $dBits_avNI,
       case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B6
       },
       case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B7
       },
       case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B8
       },
       case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B9
       },
       case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Ba
       },
       case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bb
       },
       case tup_avNl
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bc
       })
      ((case case tup_XvDd
             of _ [Occ=Dead]
             { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
             tpl_B6
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
        (CLaSH.Class.Num.mult
           @ (rep_XuIO size_XuIQ)
           @ (rep_XuIO size_XuIQ)
           (case tup_XvDd
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
            tpl_B5
            })
           (eta_X1U
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ))
           (eta_X3N
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ)))
        `cast` (Sub cobox_dw1a
                :: CLaSH.Class.Num.MResult
                     (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                     ~#
                   rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
        })
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                          GHC.TypeLits.+ size_XuIQ>_N
               :: rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ)))

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 370 0}]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup_avMt
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avMt =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X20
        } } in
    let {
      $dResize_avMR :: CLaSH.Class.Num.Resize rep_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_avMR =
        case tup_avMt
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_avMS :: GHC.TypeLits.KnownNat size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avMS =
        case tup_avMt
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_avMs :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_avMs =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X24
        } } in
    let {
      $dKnownNat_avMF
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_avMF =
        case tup_avMs
        of _ [Occ=Dead]
        { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_avMs
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_avMs
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_avMs
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_avMs
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_avMs
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_avMs
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_avMS,
        $dKnownNat_avMF,
        case tup_avMt
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_avMs
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          (case tup_XvDe
           of _ [Occ=Dead]
           { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_avMR
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_avMS
             $dKnownNat_avMF
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_avMR
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_avMS
             $dKnownNat_avMF
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $csignum_avDg @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($csignum_avDg @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

a_swhq
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Vector.Vec
       (CLaSH.Class.BitVector.BitSize
          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
       CLaSH.Bit.Bit
     -> rep_auGU size_auGV
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhq =
  \ (@ (frac_auGT :: GHC.TypeLits.Nat))
    (@ (rep_auGU :: GHC.TypeLits.Nat -> *))
    (@ (size_auGV :: GHC.TypeLits.Nat))
    ($dBitVector_avAW
       :: CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV))
    ($dKnownNat_avBa
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)))
    (bv_auGX
       :: CLaSH.Sized.Vector.Vec
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
            CLaSH.Bit.Bit) ->
    CLaSH.Class.BitVector.fromBV
      @ (rep_auGU size_auGV)
      $dBitVector_avAW
      ($dKnownNat_avBa
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))))
      (bv_auGX
       `cast` ((CLaSH.Sized.Vector.Vec
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N)
                  <CLaSH.Bit.Bit>_R)_R
               :: CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    CLaSH.Bit.Bit
                    ~#
                  CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))
                    CLaSH.Bit.Bit))

$cfromBV_avB8
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Vector.Vec
       (CLaSH.Class.BitVector.BitSize
          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
       CLaSH.Bit.Bit
     -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cfromBV_avB8 =
  a_swhq
  `cast` (forall (frac_auGT :: GHC.TypeLits.Nat)
                 (rep_auGU :: GHC.TypeLits.Nat -> *)
                 (size_auGV :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))>_R
          -> <CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGT>_P <rep_auGU>_R) <size_auGV>_N
          :: (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> rep_auGU size_auGV)
               ~#
             (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))

a_swhr
  :: forall (frac_XuIF :: GHC.TypeLits.Nat)
            (rep_XuIH :: GHC.TypeLits.Nat -> *)
            (size_XuIJ :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
     CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
     -> CLaSH.Sized.Vector.Vec
          (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ)) CLaSH.Bit.Bit
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhr =
  \ (@ (frac_XuIF :: GHC.TypeLits.Nat))
    (@ (rep_XuIH :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIJ :: GHC.TypeLits.Nat))
    ($dBitVector_XvCL
       :: CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ))
    ($dKnownNat_avB0
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ)))
    (ds_dw0H
       :: CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ) ->
    CLaSH.Class.BitVector.toBV
      @ (rep_XuIH size_XuIJ)
      $dBitVector_XvCL
      ($dKnownNat_avB0
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ))))
      (ds_dw0H
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIF>_P <rep_XuIH>_R <size_XuIJ>_N
               :: CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
                    ~#
                  rep_XuIH size_XuIJ))

$ctoBV_avAY
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
     -> CLaSH.Sized.Vector.Vec
          (CLaSH.Class.BitVector.BitSize
             (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
          CLaSH.Bit.Bit
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$ctoBV_avAY =
  a_swhr
  `cast` (forall (frac_XuIF :: GHC.TypeLits.Nat)
                 (rep_XuIH :: GHC.TypeLits.Nat -> *)
                 (size_XuIJ :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ>_R
          -> (CLaSH.Sized.Vector.Vec
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                      <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))
                <CLaSH.Bit.Bit>_R)_R
          :: (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ)) CLaSH.Bit.Bit)
               ~#
             (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                   CLaSH.Bit.Bit))

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         $ctoBV_avAY
                                           @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT
                                         $cfromBV_avB8
                                           @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ($ctoBV_avAY @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)
      ($cfromBV_avB8 @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)

a_swhs
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhs =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    Data.Default.Class.def @ (rep_auGM size_auGN) $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cdef_avAg =
  a_swhs
  `cast` (forall (frac_auGL :: GHC.TypeLits.Nat)
                 (rep_auGM :: GHC.TypeLits.Nat -> *)
                 (size_auGN :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_auGM size_auGN)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGL>_P <rep_auGM>_R) <size_auGN>_N
          :: (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              rep_auGM size_auGN)
               ~#
             (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  $cdef_avAg
  `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                 (rep_XuIO :: GHC.TypeLits.Nat -> *)
                 (size_XuIQ :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
          -> Sym
               (Data.Default.Class.NTCo:Default[0]
                  <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
          :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
               ~#
             (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))

a_swht
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swht =
  \ (@ (frac_auGI :: GHC.TypeLits.Nat))
    (@ (rep_auGJ :: GHC.TypeLits.Nat -> *))
    (@ (size_auGK :: GHC.TypeLits.Nat))
    ($dBounded_avzT :: GHC.Enum.Bounded (rep_auGJ size_auGK)) ->
    GHC.Enum.maxBound @ (rep_auGJ size_auGK) $dBounded_avzT

$cmaxBound_avA4
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmaxBound_avA4 =
  a_swht
  `cast` (forall (frac_auGI :: GHC.TypeLits.Nat)
                 (rep_auGJ :: GHC.TypeLits.Nat -> *)
                 (size_auGK :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_auGJ size_auGK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGI>_P <rep_auGJ>_R) <size_auGK>_N
          :: (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              rep_auGJ size_auGK)
               ~#
             (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK))

a_swhu
  :: forall (frac_XuIQ :: GHC.TypeLits.Nat)
            (rep_XuIS :: GHC.TypeLits.Nat -> *)
            (size_XuIU :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
     rep_XuIS size_XuIU
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhu =
  \ (@ (frac_XuIQ :: GHC.TypeLits.Nat))
    (@ (rep_XuIS :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIU :: GHC.TypeLits.Nat))
    ($dBounded_XvC4 :: GHC.Enum.Bounded (rep_XuIS size_XuIU)) ->
    GHC.Enum.minBound @ (rep_XuIS size_XuIU) $dBounded_XvC4

$cminBound_avzV
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cminBound_avzV =
  a_swhu
  `cast` (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                 (rep_XuIS :: GHC.TypeLits.Nat -> *)
                 (size_XuIU :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_XuIS size_XuIU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIQ>_P <rep_XuIS>_R) <size_XuIU>_N
          :: (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              rep_XuIS size_XuIU)
               ~#
             (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIQ rep_XuIS size_XuIU))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          $cminBound_avzV @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa
                          $cmaxBound_avA4 @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ($cminBound_avzV @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)
      ($cmaxBound_avA4 @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)

a_swlr
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swlr =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Classes.min @ (rep_auFG size_auFH) $dOrd_avyb

$cmin_avzC
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmin_avzC =
  a_swlr
  `cast` (forall (frac_auFF :: GHC.TypeLits.Nat)
                 (rep_auFG :: GHC.TypeLits.Nat -> *)
                 (size_auFH :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)>_R
          -> <GHC.Classes.Ord (rep_auFG size_auFH)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          :: (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH)
               ~#
             (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH))

a_swls
  :: forall (frac_XuHQ :: GHC.TypeLits.Nat)
            (rep_XuHS :: GHC.TypeLits.Nat -> *)
            (size_XuHU :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
      GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
     rep_XuHS size_XuHU -> rep_XuHS size_XuHU -> rep_XuHS size_XuHU
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swls =
  \ (@ (frac_XuHQ :: GHC.TypeLits.Nat))
    (@ (rep_XuHS :: GHC.TypeLits.Nat -> *))
    (@ (size_XuHU :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAq :: GHC.Classes.Ord (rep_XuHS size_XuHU)) ->
    GHC.Classes.max @ (rep_XuHS size_XuHU) $dOrd_XvAq

$cmax_avzm
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmax_avzm =
  a_swls
  `cast` (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                 (rep_XuHS :: GHC.TypeLits.Nat -> *)
                 (size_XuHU :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU)>_R
          -> <GHC.Classes.Ord (rep_XuHS size_XuHU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          :: (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              rep_XuHS size_XuHU -> rep_XuHS size_XuHU -> rep_XuHS size_XuHU)
               ~#
             (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU))

a_swhz
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhz =
  \ (@ (frac_XuHX :: GHC.TypeLits.Nat))
    (@ (rep_XuHZ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuI1 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAx :: GHC.Classes.Ord (rep_XuHZ size_XuI1)) ->
    GHC.Classes.<= @ (rep_XuHZ size_XuI1) $dOrd_XvAx

$c<=_avz8
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c<=_avz8 =
  a_swhz
  `cast` (forall (frac_XuHY :: GHC.TypeLits.Nat)
                 (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                 (size_XuI2 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2)>_R
          -> <GHC.Classes.Ord (rep_XuI0 size_XuI2)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              rep_XuI0 size_XuI2 -> rep_XuI0 size_XuI2 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> GHC.Types.Bool))

a_swhA
  :: forall (frac_XuI3 :: GHC.TypeLits.Nat)
            (rep_XuI5 :: GHC.TypeLits.Nat -> *)
            (size_XuI7 :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
      GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
     rep_XuI5 size_XuI7 -> rep_XuI5 size_XuI7 -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhA =
  \ (@ (frac_XuI3 :: GHC.TypeLits.Nat))
    (@ (rep_XuI5 :: GHC.TypeLits.Nat -> *))
    (@ (size_XuI7 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAD :: GHC.Classes.Ord (rep_XuI5 size_XuI7)) ->
    GHC.Classes.> @ (rep_XuI5 size_XuI7) $dOrd_XvAD

$c>_avyU
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c>_avyU =
  a_swhA
  `cast` (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                 (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                 (size_XuI7 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7)>_R
          -> <GHC.Classes.Ord (rep_XuI5 size_XuI7)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              rep_XuI5 size_XuI7 -> rep_XuI5 size_XuI7 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> GHC.Types.Bool))

a_swhB
  :: forall (frac_XuIa :: GHC.TypeLits.Nat)
            (rep_XuIc :: GHC.TypeLits.Nat -> *)
            (size_XuIe :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
      GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
     rep_XuIc size_XuIe -> rep_XuIc size_XuIe -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhB =
  \ (@ (frac_XuIa :: GHC.TypeLits.Nat))
    (@ (rep_XuIc :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIe :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAK :: GHC.Classes.Ord (rep_XuIc size_XuIe)) ->
    GHC.Classes.>= @ (rep_XuIc size_XuIe) $dOrd_XvAK

$c>=_avyG
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c>=_avyG =
  a_swhB
  `cast` (forall (frac_XuIa :: GHC.TypeLits.Nat)
                 (rep_XuIc :: GHC.TypeLits.Nat -> *)
                 (size_XuIe :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe)>_R
          -> <GHC.Classes.Ord (rep_XuIc size_XuIe)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              rep_XuIc size_XuIe -> rep_XuIc size_XuIe -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> GHC.Types.Bool))

a_swhC
  :: forall (frac_XuIh :: GHC.TypeLits.Nat)
            (rep_XuIj :: GHC.TypeLits.Nat -> *)
            (size_XuIl :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
      GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
     rep_XuIj size_XuIl -> rep_XuIj size_XuIl -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhC =
  \ (@ (frac_XuIh :: GHC.TypeLits.Nat))
    (@ (rep_XuIj :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIl :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAR :: GHC.Classes.Ord (rep_XuIj size_XuIl)) ->
    GHC.Classes.< @ (rep_XuIj size_XuIl) $dOrd_XvAR

$c<_avys
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c<_avys =
  a_swhC
  `cast` (forall (frac_XuIh :: GHC.TypeLits.Nat)
                 (rep_XuIj :: GHC.TypeLits.Nat -> *)
                 (size_XuIl :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl)>_R
          -> <GHC.Classes.Ord (rep_XuIj size_XuIl)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              rep_XuIj size_XuIl -> rep_XuIj size_XuIl -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> GHC.Types.Bool))

a_swhD
  :: forall (frac_XuIo :: GHC.TypeLits.Nat)
            (rep_XuIq :: GHC.TypeLits.Nat -> *)
            (size_XuIs :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
      GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
     rep_XuIq size_XuIs -> rep_XuIq size_XuIs -> GHC.Types.Ordering
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhD =
  \ (@ (frac_XuIo :: GHC.TypeLits.Nat))
    (@ (rep_XuIq :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIs :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAY :: GHC.Classes.Ord (rep_XuIq size_XuIs)) ->
    GHC.Classes.compare @ (rep_XuIq size_XuIs) $dOrd_XvAY

$ccompare_avye
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Ordering
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$ccompare_avye =
  a_swhD
  `cast` (forall (frac_XuIo :: GHC.TypeLits.Nat)
                 (rep_XuIq :: GHC.TypeLits.Nat -> *)
                 (size_XuIs :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs)>_R
          -> <GHC.Classes.Ord (rep_XuIq size_XuIs)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> <GHC.Types.Ordering>_R
          :: (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              rep_XuIq size_XuIs -> rep_XuIq size_XuIs -> GHC.Types.Ordering)
               ~#
             (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> GHC.Types.Ordering))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         $ccompare_avye
                           @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c<_avys @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c>=_avyG @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c>_avyU @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c<=_avz8 @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $cmax_avzm @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $cmin_avzC @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ($ccompare_avye
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<_avys @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>=_avyG @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>_avyU @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<=_avz8 @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmax_avzm
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmin_avzC
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)

a_swhE
  :: forall (frac_XuIw :: GHC.TypeLits.Nat)
            (rep_XuIy :: GHC.TypeLits.Nat -> *)
            (size_XuIA :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_XuIy size_XuIA) =>
     rep_XuIy size_XuIA -> rep_XuIy size_XuIA -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhE =
  \ (@ (frac_XuIw :: GHC.TypeLits.Nat))
    (@ (rep_XuIy :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIA :: GHC.TypeLits.Nat))
    ($dEq_avxF :: GHC.Classes.Eq (rep_XuIy size_XuIA)) ->
    GHC.Classes./= @ (rep_XuIy size_XuIA) $dEq_avxF

$c/=_avxV
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c/=_avxV =
  a_swhE
  `cast` (forall (frac_XuIw :: GHC.TypeLits.Nat)
                 (rep_XuIy :: GHC.TypeLits.Nat -> *)
                 (size_XuIA :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIy size_XuIA)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              rep_XuIy size_XuIA -> rep_XuIy size_XuIA -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> GHC.Types.Bool))

a_swhF
  :: forall (frac_XuIC :: GHC.TypeLits.Nat)
            (rep_XuIE :: GHC.TypeLits.Nat -> *)
            (size_XuIG :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_XuIE size_XuIG) =>
     rep_XuIE size_XuIG -> rep_XuIE size_XuIG -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhF =
  \ (@ (frac_XuIC :: GHC.TypeLits.Nat))
    (@ (rep_XuIE :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIG :: GHC.TypeLits.Nat))
    ($dEq_XvAF :: GHC.Classes.Eq (rep_XuIE size_XuIG)) ->
    GHC.Classes.== @ (rep_XuIE size_XuIG) $dEq_XvAF

$c==_avxH
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c==_avxH =
  a_swhF
  `cast` (forall (frac_XuIC :: GHC.TypeLits.Nat)
                 (rep_XuIE :: GHC.TypeLits.Nat -> *)
                 (size_XuIG :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIE size_XuIG)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              rep_XuIE size_XuIG -> rep_XuIE size_XuIG -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> GHC.Types.Bool))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        $c==_avxH @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL
                        $c/=_avxV @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ($c==_avxH @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)
      ($c/=_avxV @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$clift_avAv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    Language.Haskell.TH.Lib.sigE
      (Language.Haskell.TH.Lib.appE
         (Language.Haskell.TH.Lib.conE
            (Language.Haskell.TH.Syntax.mkNameG_d
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#))))
         (Language.Haskell.TH.Syntax.lift
            @ (rep_auGP size_auGQ)
            $dLift_avAq
            (f_auGR
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                          ~#
                        rep_auGP size_auGQ))))
      (GHC.List.foldl
         @ Language.Haskell.TH.Lib.TypeQ
         @ Language.Haskell.TH.Lib.TypeQ
         Language.Haskell.TH.Lib.appT
         (Language.Haskell.TH.Lib.conT
            (Language.Haskell.TH.Syntax.mkNameG_tc
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#))))
         (GHC.Base.build
            @ Language.Haskell.TH.Lib.TypeQ
            (\ (@ a_dvZ6)
               (c_dvZ7 [OS=OneShot]
                  :: Language.Haskell.TH.Lib.TypeQ -> a_dvZ6 -> a_dvZ6)
               (n_dvZ8 [OS=OneShot] :: a_dvZ6) ->
               c_dvZ7
                 (Language.Haskell.TH.Lib.litT
                    (Language.Haskell.TH.Lib.numTyLit
                       (GHC.TypeLits.natVal
                          @ frac_auGO
                          @ Data.Proxy.Proxy
                          $dKnownNat_avAr
                          (CLaSH.Sized.Fixed.asFracProxy
                             @ frac_auGO @ rep_auGP @ size_auGQ f_auGR))))
                 (c_dvZ7
                    (Language.Haskell.TH.Lib.conT
                       (Language.Haskell.TH.Syntax.mkName
                          (Data.Typeable.Internal.$fShowTypeRep_$cshow
                             (Data.Typeable.Internal.typeRep
                                @ (GHC.TypeLits.Nat -> *)
                                @ Data.Proxy.Proxy
                                @ rep_auGP
                                $dTypeable_avAt
                                (CLaSH.Sized.Fixed.asRepProxy
                                   @ frac_auGO @ rep_auGP @ size_auGQ f_auGR)))))
                    (c_dvZ7
                       (Language.Haskell.TH.Lib.litT
                          (Language.Haskell.TH.Lib.numTyLit
                             (GHC.TypeLits.natVal
                                @ size_auGQ
                                @ (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP)
                                $dKnownNat_avAs
                                f_auGR)))
                       n_dvZ8)))))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                              (rep_auGP :: GHC.TypeLits.Nat -> *)
                              (size_auGQ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
                       -> <GHC.TypeLits.KnownNat frac_auGO>_R
                       -> <GHC.TypeLits.KnownNat size_auGQ>_R
                       -> <Data.Typeable.Internal.Typeable rep_auGP>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_N)
                       :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                                  (rep_auGP :: GHC.TypeLits.Nat -> *)
                                  (size_auGQ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
                            GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
                            Data.Typeable.Internal.Typeable rep_auGP) =>
                           CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_auGO :: GHC.TypeLits.Nat)
                                  (rep_auGP :: GHC.TypeLits.Nat -> *)
                                  (size_auGQ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
                            GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
                            Data.Typeable.Internal.Typeable rep_auGP) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  $clift_avAv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                  <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)))



*** Specialise:

==================== Specialise ====================
Result size of Specialise
  = {terms: 1,974, types: 11,423, coercions: 844}

Rec {
$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId, Arity=2, Str=DmdType]
$s^_swu6 =
  \ (eta_akDk [Occ=Once] :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    let {
      $dReal_swui :: GHC.Real.Real GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      $dReal_swui =
        GHC.Real.$p1Integral
          @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger } in
    let {
      $dNum1_swuh :: GHC.Num.Num GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      $dNum1_swuh =
        GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal_swui } in
    let {
      $dOrd_swug :: GHC.Classes.Ord GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      $dOrd_swug =
        GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal_swui } in
    case GHC.Classes.<
           @ GHC.Integer.Type.Integer
           $dOrd_swug
           eta1_akDl
           (GHC.Num.fromInteger
              @ GHC.Integer.Type.Integer $dNum1_swuh (__integer 0))
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Classes.==
               @ GHC.Integer.Type.Integer
               (GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer $dOrd_swug)
               eta1_akDl
               (GHC.Num.fromInteger
                  @ GHC.Integer.Type.Integer $dNum1_swuh (__integer 0))
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              $dReal1_swus :: GHC.Real.Real GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              $dReal1_swus =
                GHC.Real.$p1Integral
                  @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger } in
            let {
              a1_swur :: GHC.Classes.Ord GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              a1_swur =
                GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal1_swus } in
            let {
              $dEq_swuq [Occ=OnceL] :: GHC.Classes.Eq GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              $dEq_swuq =
                GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer a1_swur } in
            let {
              $dNum2_swup :: GHC.Num.Num GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              $dNum2_swup =
                GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal1_swus } in
            letrec {
              f_swuf [Occ=LoopBreaker]
                :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
              [LclId, Arity=2, Str=DmdType]
              f_swuf =
                \ (x_akDA :: GHC.Types.Double)
                  (y_akDB :: GHC.Integer.Type.Integer) ->
                  case GHC.Real.even
                         @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger y_akDB
                  of _ [Occ=Dead] {
                    GHC.Types.False ->
                      case GHC.Classes.==
                             @ GHC.Integer.Type.Integer
                             $dEq_swuq
                             y_akDB
                             (GHC.Num.fromInteger
                                @ GHC.Integer.Type.Integer $dNum2_swup (__integer 1))
                      of _ [Occ=Dead] {
                        GHC.Types.False ->
                          let {
                            $dReal2_swuw :: GHC.Real.Real GHC.Integer.Type.Integer
                            [LclId, Str=DmdType]
                            $dReal2_swuw =
                              GHC.Real.$p1Integral
                                @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger } in
                          let {
                            a2_swuv :: GHC.Classes.Ord GHC.Integer.Type.Integer
                            [LclId, Str=DmdType]
                            a2_swuv =
                              GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal2_swuw } in
                          let {
                            $dEq1_swuu [Occ=OnceL] :: GHC.Classes.Eq GHC.Integer.Type.Integer
                            [LclId, Str=DmdType]
                            $dEq1_swuu =
                              GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer a2_swuv } in
                          let {
                            $dNum3_swut :: GHC.Num.Num GHC.Integer.Type.Integer
                            [LclId, Str=DmdType]
                            $dNum3_swut =
                              GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal2_swuw } in
                          letrec {
                            g1_swuo [Occ=LoopBreaker]
                              :: GHC.Types.Double
                                 -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
                            [LclId, Arity=3, Str=DmdType]
                            g1_swuo =
                              \ (x1_akDN :: GHC.Types.Double)
                                (y1_akDO :: GHC.Integer.Type.Integer)
                                (z_akDP [Occ=Once*] :: GHC.Types.Double) ->
                                case GHC.Real.even
                                       @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger y1_akDO
                                of _ [Occ=Dead] {
                                  GHC.Types.False ->
                                    case GHC.Classes.==
                                           @ GHC.Integer.Type.Integer
                                           $dEq1_swuu
                                           y1_akDO
                                           (GHC.Num.fromInteger
                                              @ GHC.Integer.Type.Integer $dNum3_swut (__integer 1))
                                    of _ [Occ=Dead] {
                                      GHC.Types.False ->
                                        g1_swuo
                                          (GHC.Num.*
                                             @ GHC.Types.Double
                                             GHC.Float.$fNumDouble
                                             x1_akDN
                                             x1_akDN)
                                          (GHC.Real.quot
                                             @ GHC.Integer.Type.Integer
                                             GHC.Real.$fIntegralInteger
                                             (GHC.Num.-
                                                @ GHC.Integer.Type.Integer
                                                $dNum3_swut
                                                y1_akDO
                                                (GHC.Num.fromInteger
                                                   @ GHC.Integer.Type.Integer
                                                   $dNum3_swut
                                                   (__integer 1)))
                                             (GHC.Num.fromInteger
                                                @ GHC.Integer.Type.Integer
                                                $dNum3_swut
                                                (__integer 2)))
                                          (GHC.Num.*
                                             @ GHC.Types.Double
                                             GHC.Float.$fNumDouble
                                             x1_akDN
                                             z_akDP);
                                      GHC.Types.True ->
                                        GHC.Num.*
                                          @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN z_akDP
                                    };
                                  GHC.Types.True ->
                                    g1_swuo
                                      (GHC.Num.*
                                         @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN x1_akDN)
                                      (GHC.Real.quot
                                         @ GHC.Integer.Type.Integer
                                         GHC.Real.$fIntegralInteger
                                         y1_akDO
                                         (GHC.Num.fromInteger
                                            @ GHC.Integer.Type.Integer $dNum3_swut (__integer 2)))
                                      z_akDP
                                }; } in
                          g1_swuo
                            (GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x_akDA x_akDA)
                            (GHC.Real.quot
                               @ GHC.Integer.Type.Integer
                               GHC.Real.$fIntegralInteger
                               (GHC.Num.-
                                  @ GHC.Integer.Type.Integer
                                  $dNum2_swup
                                  y_akDB
                                  (GHC.Num.fromInteger
                                     @ GHC.Integer.Type.Integer $dNum2_swup (__integer 1)))
                               (GHC.Num.fromInteger
                                  @ GHC.Integer.Type.Integer $dNum2_swup (__integer 2)))
                            x_akDA;
                        GHC.Types.True -> x_akDA
                      };
                    GHC.Types.True ->
                      f_swuf
                        (GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x_akDA x_akDA)
                        (GHC.Real.quot
                           @ GHC.Integer.Type.Integer
                           GHC.Real.$fIntegralInteger
                           y_akDB
                           (GHC.Num.fromInteger
                              @ GHC.Integer.Type.Integer $dNum2_swup (__integer 2)))
                  }; } in
            f_swuf eta_akDk eta1_akDl;
          GHC.Types.True ->
            GHC.Num.fromInteger
              @ GHC.Types.Double GHC.Float.$fNumDouble (__integer 1)
        };
      GHC.Types.True ->
        GHC.Err.error
          @ GHC.Types.Double
          (GHC.CString.unpackCString# "Negative exponent"#)
    }
end Rec }

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.fLit =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      truncated_swu2 :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      truncated_swu2 =
        GHC.Float.RealFracMethods.truncateDoubleInteger
          (GHC.Float.timesDouble
             a_auGC
             (GHC.Real.^
                @ GHC.Types.Double
                @ GHC.Integer.Type.Integer
                GHC.Float.$fNumDouble
                GHC.Real.$fIntegralInteger
                (GHC.Types.D# 2.0)
                (GHC.TypeLits.natVal
                   @ frac_avhM
                   @ Data.Proxy.Proxy
                   $dKnownNat_avlM
                   (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avhM)))) } in
    let {
      rMin_swu1 :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      rMin_swu1 =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    let {
      rMax_swu0 :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      rMax_swu0 =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    Language.Haskell.TH.Syntax.unsafeTExpCoerce
      @ (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)
      (Language.Haskell.TH.Lib.appE
         (Language.Haskell.TH.Lib.conE
            (Language.Haskell.TH.Syntax.mkNameG_d
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#))))
         (Language.Haskell.TH.Lib.appE
            (Language.Haskell.TH.Lib.varE
               (Language.Haskell.TH.Syntax.mkNameG_v
                  (GHC.Base.build
                     @ GHC.Types.Char
                     (\ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "base"#))
                  (GHC.Base.build
                     @ GHC.Types.Char
                     (\ (@ b_a4Iy) ->
                        GHC.CString.unpackFoldrCString# @ b_a4Iy "GHC.Num"#))
                  (GHC.Base.build
                     @ GHC.Types.Char
                     (\ (@ b_a4Iy) ->
                        GHC.CString.unpackFoldrCString# @ b_a4Iy "fromInteger"#))))
            (Language.Haskell.TH.Syntax.lift
               @ GHC.Integer.Type.Integer
               Language.Haskell.TH.Syntax.$fLiftInteger
               (case GHC.Integer.Type.gtInteger truncated_swu2 rMax_swu0
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger truncated_swu2 rMin_swu1
                    of _ [Occ=Dead] {
                      GHC.Types.False -> truncated_swu2;
                      GHC.Types.True -> rMin_swu1
                    };
                  GHC.Types.True -> rMax_swu0
                }))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    let {
      cobox_swtW
        :: CLaSH.Class.BitVector.BitSize
             (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_swtW =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        } } in
    let {
      cobox_swtV
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId, Str=DmdType]
      cobox_swtV =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    let {
      cobox_swtU
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_swtU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      repBV_swtT =
        case case cobox_swtW of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
             GHC.Types.Eq#
               @ *
               @ (CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                    CLaSH.Bit.Bit)
               @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
               @~ (CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_N)_N
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6X ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of _ [Occ=Dead]
            { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
            tpl_B4
            })
           (case cobox_swtW of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Y ->
            (case tup_avmQ
             of _ [Occ=Dead]
             { (tpl_X1x, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
             tpl_B8
             })
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Y))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2))))
            })
           eta_B1)
        `cast` (Sub cobox_dw6X
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      s_swtS =
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (case case case cobox_swtU
                        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ (n_aviz GHC.TypeLits.+ 2)
                          @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                          @~ (Sym cobox_dw7d)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw75 ->
                   GHC.Types.Eq#
                     @ *
                     @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                     @ (CLaSH.Sized.Vector.Vec
                          ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                     @~ (CLaSH.Sized.Vector.Vec cobox_dw75 <CLaSH.Bit.Bit>_N)_N
                   }
              of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvY9 ->
              repBV_swtT
              `cast` (Sub cobox_dvY9
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
              })) } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of _ [Occ=Dead]
            { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
            tpl_Ba
            })
           eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          ds_swtR :: CLaSH.Bit.Bit
          [LclId, Str=DmdType]
          ds_swtR =
            CLaSH.Sized.Vector.vhead
              @ n_aviz
              @ CLaSH.Bit.Bit
              (CLaSH.Sized.Vector.vtail
                 @ (n_aviz GHC.TypeLits.+ 1)
                 @ CLaSH.Bit.Bit
                 (case case case cobox_swtU
                            of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7g ->
                            GHC.Types.Eq#
                              @ GHC.TypeLits.Nat
                              @ (n_aviz GHC.TypeLits.+ 2)
                              @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                              @~ (Sym cobox_dw7g)
                            }
                       of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw73 ->
                       GHC.Types.Eq#
                         @ *
                         @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                         @ (CLaSH.Sized.Vector.Vec
                              ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                         @~ (CLaSH.Sized.Vector.Vec cobox_dw73 <CLaSH.Bit.Bit>_N)_N
                       }
                  of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvYc ->
                  repBV_swtT
                  `cast` (Sub cobox_dvYc
                          :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                               ~#
                             CLaSH.Sized.Vector.Vec
                               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                  })) } in
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_swtU
                          of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw71 ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6W ->
                repBV_swtT
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case ds_swtR of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6T ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case ds_swtR of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6T ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        };
      GHC.Types.True ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_swtU
                          of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw71 ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6W ->
                repBV_swtT
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1p, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_X1p
                    })
                   s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6S ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1p, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_X1p
                    })
                   s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6S ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
    }

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_swtI =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat_swtH =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dResize_swtG :: CLaSH.Class.Num.Resize rep_avjs
      [LclId, Str=DmdType]
      $dResize_swtG =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dBits_swtF :: Data.Bits.Bits (rep_avjs size1_avjt)
      [LclId, Str=DmdType]
      $dBits_swtF =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1o, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dNum_swtE :: GHC.Num.Num (rep_avjs size1_avjt)
      [LclId, Str=DmdType]
      $dNum_swtE =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B4
        } } in
    let {
      $dBounded_swtD :: GHC.Enum.Bounded (rep_avjs size2_avju)
      [LclId, Str=DmdType]
      $dBounded_swtD =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1u
        } } in
    let {
      resFracSZ_swtC :: GHC.Types.Int
      [LclId, Str=DmdType]
      resFracSZ_swtC =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac2_avjr
             @ Data.Proxy.Proxy
             (case tup_avnK
              of _ [Occ=Dead]
              { (tpl_X1w, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac2_avjr)) } in
    let {
      argFracSZ_swtB :: GHC.Types.Int
      [LclId, Str=DmdType]
      argFracSZ_swtB =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac1_avjq
             @ Data.Proxy.Proxy
             (case tup_avnK
              of _ [Occ=Dead]
              { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Bb
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac1_avjq)) } in
    case GHC.Integer.Type.leInteger
           (GHC.TypeLits.natVal
              @ size1_avjt
              @ Data.Proxy.Proxy
              $dKnownNat_swtI
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size1_avjt))
           (GHC.TypeLits.natVal
              @ size2_avju
              @ Data.Proxy.Proxy
              $dKnownNat_swtH
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size2_avju))
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId, Str=DmdType]
          fMax_swtA =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId, Str=DmdType]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (CLaSH.Class.Num.resize
                 @ rep_avjs
                 $dResize_swtG
                 @ size2_avju
                 @ size1_avjt
                 $dKnownNat_swtH
                 $dKnownNat_swtI
                 fMax_swtA) } in
        case GHC.Classes.leInt argFracSZ_swtB resFracSZ_swtC
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- argFracSZ_swtB resFracSZ_swtC) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of _ [Occ=Dead]
                    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) $dNum_swtE (__integer 0))
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger
                          @ (rep_avjs size1_avjt) $dNum_swtE (__integer 0))
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- resFracSZ_swtC argFracSZ_swtB) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of _ [Occ=Dead]
                    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) $dNum_swtE (__integer 0))
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger
                          @ (rep_avjs size1_avjt) $dNum_swtE (__integer 0))
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        };
      GHC.Types.True ->
        case GHC.Classes.leInt argFracSZ_swtB resFracSZ_swtC
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of _ [Occ=Dead]
                { (tpl_X1h, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_swtG
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- argFracSZ_swtB resFracSZ_swtC))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of _ [Occ=Dead]
                { (tpl_X1h, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_swtG
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- resFracSZ_swtC argFracSZ_swtB))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 70 0}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    (f_auGd :: CLaSH.Sized.Fixed.Fixed frac_avjN rep_avjO size_avjP) ->
    GHC.Num.$fNumInt_$cfromInteger
      (GHC.TypeLits.natVal
         @ frac_avjN
         @ Data.Proxy.Proxy
         $dKnownNat_avxa
         (CLaSH.Sized.Fixed.asFracProxy
            @ frac_avjN @ rep_avjO @ size_avjP f_auGd))

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      nF_swti :: GHC.Types.Int
      [LclId, Str=DmdType]
      nF_swti =
        CLaSH.Sized.Fixed.fracShift
          @ frac_auHx @ rep_auHy @ size_auHz $dKnownNat_avFx f_auHA } in
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a4II)
         (c_a4IJ [OS=OneShot] :: GHC.Types.Char -> b_a4II -> b_a4II)
         (n_a4IK [OS=OneShot] :: b_a4II) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a4II
           c_a4IJ
           n_a4IK
           (case GHC.Integer.Type.ltInteger fRepI_swtk (__integer 0)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Show.$fShowInteger_$cshow
                  (Data.Bits.$fBitsInteger_$cshiftR fRepI_swtk nF_swti);
              GHC.Types.True ->
                GHC.Types.:
                  @ GHC.Types.Char
                  (GHC.Types.C# '-')
                  (GHC.Show.$fShowInteger_$cshow
                     (Data.Bits.$fBitsInteger_$cshiftR fRepI_abs_swtj nF_swti))
            }))
      (GHC.Base.augment
         @ GHC.Types.Char
         (\ (@ b_X4Kn)
            (c_X4Kp [OS=OneShot] :: GHC.Types.Char -> b_X4Kn -> b_X4Kn)
            (n_X4Kr [OS=OneShot] :: b_X4Kn) ->
            c_X4Kp (GHC.Types.C# '.') n_X4Kr)
         (GHC.Base.$
            @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
            @ [GHC.Types.Char]
            (GHC.Base..
               @ (GHC.Types.Int, [GHC.Types.Char])
               @ [GHC.Types.Char]
               @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
               (Data.Tuple.uncurry
                  @ GHC.Types.Int
                  @ [GHC.Types.Char]
                  @ [GHC.Types.Char]
                  (\ (n_auHJ [OS=ProbOneShot] :: GHC.Types.Int)
                     (str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]) ->
                     GHC.Base.augment
                       @ GHC.Types.Char
                       (\ (@ b_X4M9)
                          (c_X4Mc [OS=OneShot] :: GHC.Types.Char -> b_X4M9 -> b_X4M9)
                          (n_X4Kt [OS=OneShot] :: b_X4M9) ->
                          GHC.Base.foldr
                            @ GHC.Types.Char
                            @ b_X4M9
                            c_X4Mc
                            n_X4Kt
                            (GHC.List.replicate
                               @ GHC.Types.Char
                               (GHC.Num.$fNumInt_$c-
                                  n_auHJ
                                  (GHC.Base.foldr
                                     @ GHC.Types.Char
                                     @ (GHC.Prim.Int# -> GHC.Types.Int)
                                     (GHC.List.incLen @ GHC.Types.Char)
                                     GHC.Types.I#
                                     str_auHK
                                     0))
                               (GHC.Types.C# '0')))
                       str_auHK))
               (GHC.Base..
                  @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                  @ (GHC.Types.Int, [GHC.Types.Char])
                  @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                  (Control.Arrow.$fArrow(->)_$csecond
                     @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                     @ [GHC.Types.Char]
                     @ GHC.Types.Int
                     (GHC.Base..
                        @ GHC.Integer.Type.Integer
                        @ GHC.Base.String
                        @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                        GHC.Show.$fShowInteger_$cshow
                        (GHC.Real.numerator
                           @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger)))
                  (GHC.Base..
                     @ (Data.Maybe.Maybe
                          (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                     @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                     @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                     (Data.Maybe.fromJust
                        @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                     (GHC.Base..
                        @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                        @ (Data.Maybe.Maybe
                             (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                        @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                        (Data.List.find
                           @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                           (GHC.Base..
                              @ GHC.Integer.Type.Integer
                              @ GHC.Types.Bool
                              @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                              (let {
                                 ds_swtm :: GHC.Integer.Type.Integer
                                 [LclId, Str=DmdType]
                                 ds_swtm = __integer 1 } in
                               \ (ds_dw44 [OS=ProbOneShot] :: GHC.Integer.Type.Integer) ->
                                 GHC.Integer.Type.eqInteger ds_dw44 ds_swtm)
                              (GHC.Base..
                                 @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 @ GHC.Integer.Type.Integer
                                 @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 (GHC.Real.denominator
                                    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger)
                                 (Data.Tuple.snd
                                    @ GHC.Types.Int @ (GHC.Real.Ratio GHC.Integer.Type.Integer)))))
                        (GHC.Base..
                           @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                           @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                           @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                           (GHC.List.iterate
                              @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                              (Control.Arrow.$fArrow(->)_$c***
                                 @ GHC.Types.Int
                                 @ GHC.Types.Int
                                 @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 GHC.Enum.$fEnumInt_$csucc
                                 (let {
                                    ds_swth :: GHC.Real.Ratio GHC.Integer.Type.Integer
                                    [LclId, Str=DmdType]
                                    ds_swth =
                                      GHC.Real.$fNumRatio_$s$cfromInteger (__integer 10) } in
                                  \ (ds_dw47 [OS=ProbOneShot]
                                       :: GHC.Real.Ratio GHC.Integer.Type.Integer) ->
                                    GHC.Real.$fNumRatio_$s$c* ds_dw47 ds_swth)))
                           (GHC.Tuple.(,)
                              @ GHC.Types.Int
                              @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                              (GHC.Types.I# 0)))))))
            (GHC.Real.%_$s%
               (case GHC.Integer.Type.ltInteger fRepI_swtk (__integer 0)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    GHC.Integer.Type.andInteger
                      fRepI_swtk
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            (__integer 2)
                            nF_swti)
                         (__integer 1));
                  GHC.Types.True ->
                    GHC.Integer.Type.andInteger
                      fRepI_abs_swtj
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            (__integer 2)
                            nF_swti)
                         (__integer 1))
                })
               (GHC.Real.^
                  @ GHC.Integer.Type.Integer
                  @ GHC.Types.Int
                  GHC.Num.$fNumInteger
                  GHC.Real.$fIntegralInt
                  (__integer 2)
                  nF_swti))))

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 120 40}]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a2g3)
         (c_a2g4 [OS=OneShot] :: GHC.Types.Char -> b_a2g3 -> b_a2g3)
         (n_a2g5 [OS=OneShot] :: b_a2g3) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a2g3
           c_a2g4
           n_a2g5
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY))
      s_a2fZ

Rec {
CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

$cshowList_avIE [Occ=LoopBreaker]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId,
 Arity=4,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0] 140 60}]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    let {
      $dShow_swtc
        :: GHC.Show.Show
             (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      [LclId, Str=DmdType]
      $dShow_swtc =
        CLaSH.Sized.Fixed.$fShowFixed
          @ frac_auHx
          @ rep_auHy
          @ size_auHz
          $dShow_avFv
          $dBits_avFw
          $dKnownNat_avFx
          $dIntegral_avFy } in
    \ (ls_a2fk
         :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
      (s_a2fl :: GHC.Base.String) ->
      GHC.Show.showList__
        @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
        (GHC.Show.shows
           @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
           $dShow_swtc)
        ls_a2fk
        s_a2fl
end Rec }

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 70 0}]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl_X1B) ->
         tpl_X1B
         }
    of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
    (CLaSH.Class.Num.mult
       @ (rep_auHr size1_auHs)
       @ (rep_auHr size2_auHu)
       (case tup_avFg of _ [Occ=Dead] { (tpl_X1C, tpl_X1E) -> tpl_X1C })
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  $cmult_avFi
  `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                 (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                 (size1_XuJ3 :: GHC.TypeLits.Nat)
                 (frac2_XuJ5 :: GHC.TypeLits.Nat)
                 (size2_XuJ7 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
          -> Sym
               (CLaSH.Class.Num.NTCo:Mult[0]
                  <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                  <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
          :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
              -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                   (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
               ~#
             (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 450 0}]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    letrec {
      $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dBits_swt2 =
        case tup_swt3
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      tup_swt3
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swt3 =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1Z, tpl_X21, tpl_B3) ->
        tpl_X1Z
        }; } in
    letrec {
      $dKnownNat_swt4
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swt4 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        };
      $dBits_swt5
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swt5 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        };
      $dKnownNat_swt6
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_swt6 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swt7 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        };
      $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_swt8 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      $dBounded_swt9
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swt9 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1N
        };
      tup_swta
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swta =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1L, tpl_X1N, tpl_B3) ->
        tpl_X1N
        }; } in
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl_X24, tpl_B3) ->
        tpl_B3
        })
       ((CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X43, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X46, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 450 0}]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    letrec {
      $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dBits_swsK =
        case tup_swsL
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      tup_swsL
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swsL =
        case tup_avDN of _ [Occ=Dead] { (tpl_X20, tpl_X22, tpl_B3) ->
        tpl_X20
        }; } in
    letrec {
      $dKnownNat_swsM
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swsM =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        };
      $dBits_swsN
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swsN =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        };
      $dKnownNat_swsO
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_swsO =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swsP =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        };
      $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_swsQ =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      $dBounded_swsR
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swsR =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1O
        };
      tup_swsS
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swsS =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1M, tpl_X1O, tpl_B3) ->
        tpl_X1O
        }; } in
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl_X25, tpl_B3) ->
        tpl_B3
        })
       ((CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X45, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X48, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0] 170 0}]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    let {
      tup_swsA
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId, Str=DmdType]
      tup_swsA =
        case tup_avBm
        of _ [Occ=Dead]
        { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1N
        } } in
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       (case tup_swsA
        of _ [Occ=Dead]
        { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        })
       (GHC.Num.fromInteger
          @ (rep_auGZ size_auH0)
          (case tup_avBm
           of _ [Occ=Dead]
           { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B3
           })
          eta_X1I)
       (GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac_auGY
             @ Data.Proxy.Proxy
             (case tup_swsA
              of _ [Occ=Dead]
              { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_auGY))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      (case tup_avBm
       of _ [Occ=Dead]
       { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       tpl_B3
       })
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))

$csignum_avDg
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$csignum_avDg =
  a_swkh
  `cast` (forall (frac_auGY :: GHC.TypeLits.Nat)
                 (rep_auGZ :: GHC.TypeLits.Nat -> *)
                 (size_auH0 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
          :: (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> rep_auGZ size_auH0)
               ~#
             (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0))

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 300 0}]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    letrec {
      $dKnownNat_swsv
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsv =
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        };
      tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId, Str=DmdType]
      tup_swsw =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1X
        }; } in
    letrec {
      $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
      [LclId, Str=DmdType]
      $dKnownNat_swsx =
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      tup_swsy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId, Str=DmdType]
      tup_swsy =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1V
        }; } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          (case tup_XvDa
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIL
             (case tup_swsy
              of _ [Occ=Dead]
              { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B6
              })
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 300 0}]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    letrec {
      $dKnownNat_swsn
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsn =
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        };
      tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId, Str=DmdType]
      tup_swso =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        }; } in
    letrec {
      $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
      [LclId, Str=DmdType]
      $dKnownNat_swsp =
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      tup_swsq
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId, Str=DmdType]
      tup_swsq =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1W
        }; } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          (case tup_XvDb
           of _ [Occ=Dead]
           { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIM
             (case tup_swsq
              of _ [Occ=Dead]
              { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B6
              })
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 370 0}]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    letrec {
      $dKnownNat_swse
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swse =
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        };
      tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId, Str=DmdType]
      tup_swsf =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X22
        }; } in
    letrec {
      $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
      [LclId, Str=DmdType]
      $dKnownNat_swsg =
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      tup_swsi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId, Str=DmdType]
      tup_swsi =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        }; } in
    let {
      $dResize_swsh :: CLaSH.Class.Num.Resize rep_XuIN
      [LclId, Str=DmdType]
      $dResize_swsh =
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          (case tup_XvDc
           of _ [Occ=Dead]
           { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_swsh
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_swsh
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 270 0}]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    letrec {
      $dBits_sws7
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      $dBits_sws7 =
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      tup_sws8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId, Str=DmdType]
      tup_sws8 =
        case tup_XvDd
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Z
        }; } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B3
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B6
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B7
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B8
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B9
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Ba
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bb
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bc
       })
      ((case case tup_XvDd
             of _ [Occ=Dead]
             { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
             tpl_B6
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
        (CLaSH.Class.Num.mult
           @ (rep_XuIO size_XuIQ)
           @ (rep_XuIO size_XuIQ)
           (case tup_XvDd
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
            tpl_B5
            })
           (eta_X1U
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ))
           (eta_X3N
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ)))
        `cast` (Sub cobox_dw1a
                :: CLaSH.Class.Num.MResult
                     (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                     ~#
                   rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
        })
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                          GHC.TypeLits.+ size_XuIQ>_N
               :: rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ)))

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 370 0}]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    letrec {
      $dKnownNat_sws0
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_sws0 =
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        };
      tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      tup_sws1 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X24
        }; } in
    letrec {
      $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
      [LclId, Str=DmdType]
      $dKnownNat_sws2 =
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      tup_sws4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId, Str=DmdType]
      tup_sws4 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X20
        }; } in
    let {
      $dResize_sws3 :: CLaSH.Class.Num.Resize rep_XuIP
      [LclId, Str=DmdType]
      $dResize_sws3 =
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          (case tup_XvDe
           of _ [Occ=Dead]
           { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_sws3
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_sws3
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $csignum_avDg @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($csignum_avDg @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

a_swhq
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Vector.Vec
       (CLaSH.Class.BitVector.BitSize
          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
       CLaSH.Bit.Bit
     -> rep_auGU size_auGV
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhq =
  \ (@ (frac_auGT :: GHC.TypeLits.Nat))
    (@ (rep_auGU :: GHC.TypeLits.Nat -> *))
    (@ (size_auGV :: GHC.TypeLits.Nat))
    ($dBitVector_avAW
       :: CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV))
    ($dKnownNat_avBa
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)))
    (bv_auGX
       :: CLaSH.Sized.Vector.Vec
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
            CLaSH.Bit.Bit) ->
    CLaSH.Class.BitVector.fromBV
      @ (rep_auGU size_auGV)
      $dBitVector_avAW
      ($dKnownNat_avBa
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))))
      (bv_auGX
       `cast` ((CLaSH.Sized.Vector.Vec
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N)
                  <CLaSH.Bit.Bit>_R)_R
               :: CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    CLaSH.Bit.Bit
                    ~#
                  CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))
                    CLaSH.Bit.Bit))

$cfromBV_avB8
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Vector.Vec
       (CLaSH.Class.BitVector.BitSize
          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
       CLaSH.Bit.Bit
     -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cfromBV_avB8 =
  a_swhq
  `cast` (forall (frac_auGT :: GHC.TypeLits.Nat)
                 (rep_auGU :: GHC.TypeLits.Nat -> *)
                 (size_auGV :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))>_R
          -> <CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGT>_P <rep_auGU>_R) <size_auGV>_N
          :: (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> rep_auGU size_auGV)
               ~#
             (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))

a_swhr
  :: forall (frac_XuIF :: GHC.TypeLits.Nat)
            (rep_XuIH :: GHC.TypeLits.Nat -> *)
            (size_XuIJ :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
     CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
     -> CLaSH.Sized.Vector.Vec
          (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ)) CLaSH.Bit.Bit
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhr =
  \ (@ (frac_XuIF :: GHC.TypeLits.Nat))
    (@ (rep_XuIH :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIJ :: GHC.TypeLits.Nat))
    ($dBitVector_XvCL
       :: CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ))
    ($dKnownNat_avB0
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ)))
    (ds_dw0H
       :: CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ) ->
    CLaSH.Class.BitVector.toBV
      @ (rep_XuIH size_XuIJ)
      $dBitVector_XvCL
      ($dKnownNat_avB0
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ))))
      (ds_dw0H
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIF>_P <rep_XuIH>_R <size_XuIJ>_N
               :: CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
                    ~#
                  rep_XuIH size_XuIJ))

$ctoBV_avAY
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
     -> CLaSH.Sized.Vector.Vec
          (CLaSH.Class.BitVector.BitSize
             (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
          CLaSH.Bit.Bit
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$ctoBV_avAY =
  a_swhr
  `cast` (forall (frac_XuIF :: GHC.TypeLits.Nat)
                 (rep_XuIH :: GHC.TypeLits.Nat -> *)
                 (size_XuIJ :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ>_R
          -> (CLaSH.Sized.Vector.Vec
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                      <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))
                <CLaSH.Bit.Bit>_R)_R
          :: (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ)) CLaSH.Bit.Bit)
               ~#
             (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                   CLaSH.Bit.Bit))

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         $ctoBV_avAY
                                           @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT
                                         $cfromBV_avB8
                                           @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ($ctoBV_avAY @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)
      ($cfromBV_avB8 @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)

a_swhs
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhs =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    Data.Default.Class.def @ (rep_auGM size_auGN) $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cdef_avAg =
  a_swhs
  `cast` (forall (frac_auGL :: GHC.TypeLits.Nat)
                 (rep_auGM :: GHC.TypeLits.Nat -> *)
                 (size_auGN :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_auGM size_auGN)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGL>_P <rep_auGM>_R) <size_auGN>_N
          :: (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              rep_auGM size_auGN)
               ~#
             (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  $cdef_avAg
  `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                 (rep_XuIO :: GHC.TypeLits.Nat -> *)
                 (size_XuIQ :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
          -> Sym
               (Data.Default.Class.NTCo:Default[0]
                  <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
          :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
               ~#
             (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))

a_swht
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swht =
  \ (@ (frac_auGI :: GHC.TypeLits.Nat))
    (@ (rep_auGJ :: GHC.TypeLits.Nat -> *))
    (@ (size_auGK :: GHC.TypeLits.Nat))
    ($dBounded_avzT :: GHC.Enum.Bounded (rep_auGJ size_auGK)) ->
    GHC.Enum.maxBound @ (rep_auGJ size_auGK) $dBounded_avzT

$cmaxBound_avA4
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmaxBound_avA4 =
  a_swht
  `cast` (forall (frac_auGI :: GHC.TypeLits.Nat)
                 (rep_auGJ :: GHC.TypeLits.Nat -> *)
                 (size_auGK :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_auGJ size_auGK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGI>_P <rep_auGJ>_R) <size_auGK>_N
          :: (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              rep_auGJ size_auGK)
               ~#
             (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK))

a_swhu
  :: forall (frac_XuIQ :: GHC.TypeLits.Nat)
            (rep_XuIS :: GHC.TypeLits.Nat -> *)
            (size_XuIU :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
     rep_XuIS size_XuIU
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhu =
  \ (@ (frac_XuIQ :: GHC.TypeLits.Nat))
    (@ (rep_XuIS :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIU :: GHC.TypeLits.Nat))
    ($dBounded_XvC4 :: GHC.Enum.Bounded (rep_XuIS size_XuIU)) ->
    GHC.Enum.minBound @ (rep_XuIS size_XuIU) $dBounded_XvC4

$cminBound_avzV
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cminBound_avzV =
  a_swhu
  `cast` (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                 (rep_XuIS :: GHC.TypeLits.Nat -> *)
                 (size_XuIU :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_XuIS size_XuIU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIQ>_P <rep_XuIS>_R) <size_XuIU>_N
          :: (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              rep_XuIS size_XuIU)
               ~#
             (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIQ rep_XuIS size_XuIU))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          $cminBound_avzV @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa
                          $cmaxBound_avA4 @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ($cminBound_avzV @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)
      ($cmaxBound_avA4 @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)

a_swlr
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swlr =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Classes.min @ (rep_auFG size_auFH) $dOrd_avyb

$cmin_avzC
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmin_avzC =
  a_swlr
  `cast` (forall (frac_auFF :: GHC.TypeLits.Nat)
                 (rep_auFG :: GHC.TypeLits.Nat -> *)
                 (size_auFH :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)>_R
          -> <GHC.Classes.Ord (rep_auFG size_auFH)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          :: (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH)
               ~#
             (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH))

a_swls
  :: forall (frac_XuHQ :: GHC.TypeLits.Nat)
            (rep_XuHS :: GHC.TypeLits.Nat -> *)
            (size_XuHU :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
      GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
     rep_XuHS size_XuHU -> rep_XuHS size_XuHU -> rep_XuHS size_XuHU
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swls =
  \ (@ (frac_XuHQ :: GHC.TypeLits.Nat))
    (@ (rep_XuHS :: GHC.TypeLits.Nat -> *))
    (@ (size_XuHU :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAq :: GHC.Classes.Ord (rep_XuHS size_XuHU)) ->
    GHC.Classes.max @ (rep_XuHS size_XuHU) $dOrd_XvAq

$cmax_avzm
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmax_avzm =
  a_swls
  `cast` (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                 (rep_XuHS :: GHC.TypeLits.Nat -> *)
                 (size_XuHU :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU)>_R
          -> <GHC.Classes.Ord (rep_XuHS size_XuHU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          :: (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              rep_XuHS size_XuHU -> rep_XuHS size_XuHU -> rep_XuHS size_XuHU)
               ~#
             (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU))

a_swhz
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhz =
  \ (@ (frac_XuHX :: GHC.TypeLits.Nat))
    (@ (rep_XuHZ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuI1 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAx :: GHC.Classes.Ord (rep_XuHZ size_XuI1)) ->
    GHC.Classes.<= @ (rep_XuHZ size_XuI1) $dOrd_XvAx

$c<=_avz8
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c<=_avz8 =
  a_swhz
  `cast` (forall (frac_XuHY :: GHC.TypeLits.Nat)
                 (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                 (size_XuI2 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2)>_R
          -> <GHC.Classes.Ord (rep_XuI0 size_XuI2)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              rep_XuI0 size_XuI2 -> rep_XuI0 size_XuI2 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> GHC.Types.Bool))

a_swhA
  :: forall (frac_XuI3 :: GHC.TypeLits.Nat)
            (rep_XuI5 :: GHC.TypeLits.Nat -> *)
            (size_XuI7 :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
      GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
     rep_XuI5 size_XuI7 -> rep_XuI5 size_XuI7 -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhA =
  \ (@ (frac_XuI3 :: GHC.TypeLits.Nat))
    (@ (rep_XuI5 :: GHC.TypeLits.Nat -> *))
    (@ (size_XuI7 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAD :: GHC.Classes.Ord (rep_XuI5 size_XuI7)) ->
    GHC.Classes.> @ (rep_XuI5 size_XuI7) $dOrd_XvAD

$c>_avyU
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c>_avyU =
  a_swhA
  `cast` (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                 (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                 (size_XuI7 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7)>_R
          -> <GHC.Classes.Ord (rep_XuI5 size_XuI7)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              rep_XuI5 size_XuI7 -> rep_XuI5 size_XuI7 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> GHC.Types.Bool))

a_swhB
  :: forall (frac_XuIa :: GHC.TypeLits.Nat)
            (rep_XuIc :: GHC.TypeLits.Nat -> *)
            (size_XuIe :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
      GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
     rep_XuIc size_XuIe -> rep_XuIc size_XuIe -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhB =
  \ (@ (frac_XuIa :: GHC.TypeLits.Nat))
    (@ (rep_XuIc :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIe :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAK :: GHC.Classes.Ord (rep_XuIc size_XuIe)) ->
    GHC.Classes.>= @ (rep_XuIc size_XuIe) $dOrd_XvAK

$c>=_avyG
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c>=_avyG =
  a_swhB
  `cast` (forall (frac_XuIa :: GHC.TypeLits.Nat)
                 (rep_XuIc :: GHC.TypeLits.Nat -> *)
                 (size_XuIe :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe)>_R
          -> <GHC.Classes.Ord (rep_XuIc size_XuIe)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              rep_XuIc size_XuIe -> rep_XuIc size_XuIe -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> GHC.Types.Bool))

a_swhC
  :: forall (frac_XuIh :: GHC.TypeLits.Nat)
            (rep_XuIj :: GHC.TypeLits.Nat -> *)
            (size_XuIl :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
      GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
     rep_XuIj size_XuIl -> rep_XuIj size_XuIl -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhC =
  \ (@ (frac_XuIh :: GHC.TypeLits.Nat))
    (@ (rep_XuIj :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIl :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAR :: GHC.Classes.Ord (rep_XuIj size_XuIl)) ->
    GHC.Classes.< @ (rep_XuIj size_XuIl) $dOrd_XvAR

$c<_avys
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c<_avys =
  a_swhC
  `cast` (forall (frac_XuIh :: GHC.TypeLits.Nat)
                 (rep_XuIj :: GHC.TypeLits.Nat -> *)
                 (size_XuIl :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl)>_R
          -> <GHC.Classes.Ord (rep_XuIj size_XuIl)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              rep_XuIj size_XuIl -> rep_XuIj size_XuIl -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> GHC.Types.Bool))

a_swhD
  :: forall (frac_XuIo :: GHC.TypeLits.Nat)
            (rep_XuIq :: GHC.TypeLits.Nat -> *)
            (size_XuIs :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
      GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
     rep_XuIq size_XuIs -> rep_XuIq size_XuIs -> GHC.Types.Ordering
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhD =
  \ (@ (frac_XuIo :: GHC.TypeLits.Nat))
    (@ (rep_XuIq :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIs :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAY :: GHC.Classes.Ord (rep_XuIq size_XuIs)) ->
    GHC.Classes.compare @ (rep_XuIq size_XuIs) $dOrd_XvAY

$ccompare_avye
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Ordering
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$ccompare_avye =
  a_swhD
  `cast` (forall (frac_XuIo :: GHC.TypeLits.Nat)
                 (rep_XuIq :: GHC.TypeLits.Nat -> *)
                 (size_XuIs :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs)>_R
          -> <GHC.Classes.Ord (rep_XuIq size_XuIs)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> <GHC.Types.Ordering>_R
          :: (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              rep_XuIq size_XuIs -> rep_XuIq size_XuIs -> GHC.Types.Ordering)
               ~#
             (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> GHC.Types.Ordering))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         $ccompare_avye
                           @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c<_avys @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c>=_avyG @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c>_avyU @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c<=_avz8 @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $cmax_avzm @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $cmin_avzC @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ($ccompare_avye
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<_avys @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>=_avyG @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>_avyU @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<=_avz8 @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmax_avzm
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmin_avzC
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)

a_swhE
  :: forall (frac_XuIw :: GHC.TypeLits.Nat)
            (rep_XuIy :: GHC.TypeLits.Nat -> *)
            (size_XuIA :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_XuIy size_XuIA) =>
     rep_XuIy size_XuIA -> rep_XuIy size_XuIA -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhE =
  \ (@ (frac_XuIw :: GHC.TypeLits.Nat))
    (@ (rep_XuIy :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIA :: GHC.TypeLits.Nat))
    ($dEq_avxF :: GHC.Classes.Eq (rep_XuIy size_XuIA)) ->
    GHC.Classes./= @ (rep_XuIy size_XuIA) $dEq_avxF

$c/=_avxV
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c/=_avxV =
  a_swhE
  `cast` (forall (frac_XuIw :: GHC.TypeLits.Nat)
                 (rep_XuIy :: GHC.TypeLits.Nat -> *)
                 (size_XuIA :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIy size_XuIA)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              rep_XuIy size_XuIA -> rep_XuIy size_XuIA -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> GHC.Types.Bool))

a_swhF
  :: forall (frac_XuIC :: GHC.TypeLits.Nat)
            (rep_XuIE :: GHC.TypeLits.Nat -> *)
            (size_XuIG :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_XuIE size_XuIG) =>
     rep_XuIE size_XuIG -> rep_XuIE size_XuIG -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhF =
  \ (@ (frac_XuIC :: GHC.TypeLits.Nat))
    (@ (rep_XuIE :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIG :: GHC.TypeLits.Nat))
    ($dEq_XvAF :: GHC.Classes.Eq (rep_XuIE size_XuIG)) ->
    GHC.Classes.== @ (rep_XuIE size_XuIG) $dEq_XvAF

$c==_avxH
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c==_avxH =
  a_swhF
  `cast` (forall (frac_XuIC :: GHC.TypeLits.Nat)
                 (rep_XuIE :: GHC.TypeLits.Nat -> *)
                 (size_XuIG :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIE size_XuIG)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              rep_XuIE size_XuIG -> rep_XuIE size_XuIG -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> GHC.Types.Bool))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        $c==_avxH @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL
                        $c/=_avxV @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ($c==_avxH @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)
      ($c/=_avxV @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$clift_avAv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    Language.Haskell.TH.Lib.sigE
      (Language.Haskell.TH.Lib.appE
         (Language.Haskell.TH.Lib.conE
            (Language.Haskell.TH.Syntax.mkNameG_d
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#))))
         (Language.Haskell.TH.Syntax.lift
            @ (rep_auGP size_auGQ)
            $dLift_avAq
            (f_auGR
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                          ~#
                        rep_auGP size_auGQ))))
      (GHC.List.foldl
         @ Language.Haskell.TH.Lib.TypeQ
         @ Language.Haskell.TH.Lib.TypeQ
         Language.Haskell.TH.Lib.appT
         (Language.Haskell.TH.Lib.conT
            (Language.Haskell.TH.Syntax.mkNameG_tc
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#))
               (GHC.Base.build
                  @ GHC.Types.Char
                  (\ (@ b_a4Iy) ->
                     GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#))))
         (GHC.Base.build
            @ Language.Haskell.TH.Lib.TypeQ
            (\ (@ a_dvZ6)
               (c_dvZ7 [OS=OneShot]
                  :: Language.Haskell.TH.Lib.TypeQ -> a_dvZ6 -> a_dvZ6)
               (n_dvZ8 [OS=OneShot] :: a_dvZ6) ->
               c_dvZ7
                 (Language.Haskell.TH.Lib.litT
                    (Language.Haskell.TH.Lib.numTyLit
                       (GHC.TypeLits.natVal
                          @ frac_auGO
                          @ Data.Proxy.Proxy
                          $dKnownNat_avAr
                          (CLaSH.Sized.Fixed.asFracProxy
                             @ frac_auGO @ rep_auGP @ size_auGQ f_auGR))))
                 (c_dvZ7
                    (Language.Haskell.TH.Lib.conT
                       (Language.Haskell.TH.Syntax.mkName
                          (Data.Typeable.Internal.$fShowTypeRep_$cshow
                             (Data.Typeable.Internal.typeRep
                                @ (GHC.TypeLits.Nat -> *)
                                @ Data.Proxy.Proxy
                                @ rep_auGP
                                $dTypeable_avAt
                                (CLaSH.Sized.Fixed.asRepProxy
                                   @ frac_auGO @ rep_auGP @ size_auGQ f_auGR)))))
                    (c_dvZ7
                       (Language.Haskell.TH.Lib.litT
                          (Language.Haskell.TH.Lib.numTyLit
                             (GHC.TypeLits.natVal
                                @ size_auGQ
                                @ (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP)
                                $dKnownNat_avAs
                                f_auGR)))
                       n_dvZ8)))))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                              (rep_auGP :: GHC.TypeLits.Nat -> *)
                              (size_auGQ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
                       -> <GHC.TypeLits.KnownNat frac_auGO>_R
                       -> <GHC.TypeLits.KnownNat size_auGQ>_R
                       -> <Data.Typeable.Internal.Typeable rep_auGP>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_N)
                       :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                                  (rep_auGP :: GHC.TypeLits.Nat -> *)
                                  (size_auGQ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
                            GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
                            Data.Typeable.Internal.Typeable rep_auGP) =>
                           CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_auGO :: GHC.TypeLits.Nat)
                                  (rep_auGP :: GHC.TypeLits.Nat -> *)
                                  (size_auGQ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
                            GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
                            Data.Typeable.Internal.Typeable rep_auGP) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  $clift_avAv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                  <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Float out(FOS {Lam = Just 0, Consts = True, PAPs = False}):

==================== Levels added: ====================
<$s^_swu6,<0,0>>
<$s^_swu6,<0,0>> =
  \ <eta_akDk,<1,0>> <eta1_akDl,<1,0>> ->
    let {
      <$dReal_swuD,F<0,0>>
      <$dReal_swuD,F<0,0>> =
        GHC.Real.$p1Integral
          @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger } in
    let {
      <$dNum1_swuE,F<0,0>>
      <$dNum1_swuE,F<0,0>> =
        GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal_swuD } in
    let {
      <$dOrd_swuF,F<0,0>>
      <$dOrd_swuF,F<0,0>> =
        GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal_swuD } in
    case GHC.Classes.<
           @ GHC.Integer.Type.Integer
           $dOrd_swuF
           eta1_akDl
           (let {
              <lvl_swuH,F<0,0>>
              <lvl_swuH,F<0,0>> =
                GHC.Num.fromInteger
                  @ GHC.Integer.Type.Integer
                  $dNum1_swuE
                  (let {
                     <lvl_swuG,F<0,0>>
                     <lvl_swuG,F<0,0>> = __integer 0 } in
                   lvl_swuG) } in
            lvl_swuH)
    of <wild_akDp,<1,1>> {
      GHC.Types.False ->
        case GHC.Classes.==
               @ GHC.Integer.Type.Integer
               (let {
                  <lvl_swuI,F<0,0>>
                  <lvl_swuI,F<0,0>> =
                    GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer $dOrd_swuF } in
                lvl_swuI)
               eta1_akDl
               (let {
                  <lvl_swuK,F<0,0>>
                  <lvl_swuK,F<0,0>> =
                    GHC.Num.fromInteger
                      @ GHC.Integer.Type.Integer
                      $dNum1_swuE
                      (let {
                         <lvl_swuJ,F<0,0>>
                         <lvl_swuJ,F<0,0>> = __integer 0 } in
                       lvl_swuJ) } in
                lvl_swuK)
        of <wild1_akDs,<1,2>> {
          GHC.Types.False ->
            let {
              <$dReal1_swuL,F<0,0>>
              <$dReal1_swuL,F<0,0>> =
                GHC.Real.$p1Integral
                  @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger } in
            let {
              <a1_swuM,F<0,0>>
              <a1_swuM,F<0,0>> =
                GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal1_swuL } in
            let {
              <$dEq_swuN,F<0,0>>
              <$dEq_swuN,F<0,0>> =
                GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer a1_swuM } in
            let {
              <$dNum2_swuO,F<0,0>>
              <$dNum2_swuO,F<0,0>> =
                GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal1_swuL } in
            letrec {
              <f_swuQ,F<0,0>>
              <f_swuQ,F<0,0>> =
                \ <x_akDA,<2,0>> <y_akDB,<2,0>> ->
                  case GHC.Real.even
                         @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger y_akDB
                  of <wild2_akDC,<2,1>> {
                    GHC.Types.False ->
                      case GHC.Classes.==
                             @ GHC.Integer.Type.Integer
                             $dEq_swuN
                             y_akDB
                             (let {
                                <lvl_swuS,F<0,0>>
                                <lvl_swuS,F<0,0>> =
                                  GHC.Num.fromInteger
                                    @ GHC.Integer.Type.Integer
                                    $dNum2_swuO
                                    (let {
                                       <lvl_swuR,F<0,0>>
                                       <lvl_swuR,F<0,0>> = __integer 1 } in
                                     lvl_swuR) } in
                              lvl_swuS)
                      of <wild3_akDF,<2,2>> {
                        GHC.Types.False ->
                          let {
                            <$dReal2_swuT,F<0,0>>
                            <$dReal2_swuT,F<0,0>> =
                              GHC.Real.$p1Integral
                                @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger } in
                          let {
                            <a2_swuU,F<0,0>>
                            <a2_swuU,F<0,0>> =
                              GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal2_swuT } in
                          let {
                            <$dEq1_swuV,F<0,0>>
                            <$dEq1_swuV,F<0,0>> =
                              GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer a2_swuU } in
                          let {
                            <$dNum3_swuW,F<0,0>>
                            <$dNum3_swuW,F<0,0>> =
                              GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal2_swuT } in
                          letrec {
                            <g1_swuY,F<0,0>>
                            <g1_swuY,F<0,0>> =
                              \ <x1_akDN,<3,0>> <y1_akDO,<3,0>> <z_akDP,<3,0>> ->
                                case GHC.Real.even
                                       @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger y1_akDO
                                of <wild4_akDQ,<3,1>> {
                                  GHC.Types.False ->
                                    case GHC.Classes.==
                                           @ GHC.Integer.Type.Integer
                                           $dEq1_swuV
                                           y1_akDO
                                           (let {
                                              <lvl_swv0,F<0,0>>
                                              <lvl_swv0,F<0,0>> =
                                                GHC.Num.fromInteger
                                                  @ GHC.Integer.Type.Integer
                                                  $dNum3_swuW
                                                  (let {
                                                     <lvl_swuZ,F<0,0>>
                                                     <lvl_swuZ,F<0,0>> = __integer 1 } in
                                                   lvl_swuZ) } in
                                            lvl_swv0)
                                    of <wild5_akDT,<3,2>> {
                                      GHC.Types.False ->
                                        g1_swuY
                                          (GHC.Num.*
                                             @ GHC.Types.Double
                                             GHC.Float.$fNumDouble
                                             x1_akDN
                                             x1_akDN)
                                          (GHC.Real.quot
                                             @ GHC.Integer.Type.Integer
                                             GHC.Real.$fIntegralInteger
                                             (GHC.Num.-
                                                @ GHC.Integer.Type.Integer
                                                $dNum3_swuW
                                                y1_akDO
                                                (let {
                                                   <lvl_swv2,F<0,0>>
                                                   <lvl_swv2,F<0,0>> =
                                                     GHC.Num.fromInteger
                                                       @ GHC.Integer.Type.Integer
                                                       $dNum3_swuW
                                                       (let {
                                                          <lvl_swv1,F<0,0>>
                                                          <lvl_swv1,F<0,0>> = __integer 1 } in
                                                        lvl_swv1) } in
                                                 lvl_swv2))
                                             (let {
                                                <lvl_swv4,F<0,0>>
                                                <lvl_swv4,F<0,0>> =
                                                  GHC.Num.fromInteger
                                                    @ GHC.Integer.Type.Integer
                                                    $dNum3_swuW
                                                    (let {
                                                       <lvl_swv3,F<0,0>>
                                                       <lvl_swv3,F<0,0>> = __integer 2 } in
                                                     lvl_swv3) } in
                                              lvl_swv4))
                                          (GHC.Num.*
                                             @ GHC.Types.Double
                                             GHC.Float.$fNumDouble
                                             x1_akDN
                                             z_akDP);
                                      GHC.Types.True ->
                                        GHC.Num.*
                                          @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN z_akDP
                                    };
                                  GHC.Types.True ->
                                    g1_swuY
                                      (GHC.Num.*
                                         @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN x1_akDN)
                                      (GHC.Real.quot
                                         @ GHC.Integer.Type.Integer
                                         GHC.Real.$fIntegralInteger
                                         y1_akDO
                                         (let {
                                            <lvl_swv6,F<0,0>>
                                            <lvl_swv6,F<0,0>> =
                                              GHC.Num.fromInteger
                                                @ GHC.Integer.Type.Integer
                                                $dNum3_swuW
                                                (let {
                                                   <lvl_swv5,F<0,0>>
                                                   <lvl_swv5,F<0,0>> = __integer 2 } in
                                                 lvl_swv5) } in
                                          lvl_swv6))
                                      z_akDP
                                }; } in
                          g1_swuY
                            (GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x_akDA x_akDA)
                            (GHC.Real.quot
                               @ GHC.Integer.Type.Integer
                               GHC.Real.$fIntegralInteger
                               (GHC.Num.-
                                  @ GHC.Integer.Type.Integer
                                  $dNum2_swuO
                                  y_akDB
                                  (let {
                                     <lvl_swv8,F<0,0>>
                                     <lvl_swv8,F<0,0>> =
                                       GHC.Num.fromInteger
                                         @ GHC.Integer.Type.Integer
                                         $dNum2_swuO
                                         (let {
                                            <lvl_swv7,F<0,0>>
                                            <lvl_swv7,F<0,0>> = __integer 1 } in
                                          lvl_swv7) } in
                                   lvl_swv8))
                               (let {
                                  <lvl_swva,F<0,0>>
                                  <lvl_swva,F<0,0>> =
                                    GHC.Num.fromInteger
                                      @ GHC.Integer.Type.Integer
                                      $dNum2_swuO
                                      (let {
                                         <lvl_swv9,F<0,0>>
                                         <lvl_swv9,F<0,0>> = __integer 2 } in
                                       lvl_swv9) } in
                                lvl_swva))
                            x_akDA;
                        GHC.Types.True -> x_akDA
                      };
                    GHC.Types.True ->
                      f_swuQ
                        (GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x_akDA x_akDA)
                        (GHC.Real.quot
                           @ GHC.Integer.Type.Integer
                           GHC.Real.$fIntegralInteger
                           y_akDB
                           (let {
                              <lvl_swvc,F<0,0>>
                              <lvl_swvc,F<0,0>> =
                                GHC.Num.fromInteger
                                  @ GHC.Integer.Type.Integer
                                  $dNum2_swuO
                                  (let {
                                     <lvl_swvb,F<0,0>>
                                     <lvl_swvb,F<0,0>> = __integer 2 } in
                                   lvl_swvb) } in
                            lvl_swvc))
                  }; } in
            f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True ->
            let {
              <lvl_swve,F<0,0>>
              <lvl_swve,F<0,0>> =
                GHC.Num.fromInteger
                  @ GHC.Types.Double
                  GHC.Float.$fNumDouble
                  (let {
                     <lvl_swvd,F<0,0>>
                     <lvl_swvd,F<0,0>> = __integer 1 } in
                   lvl_swvd) } in
            lvl_swve
        };
      GHC.Types.True ->
        let {
          <lvl_swvg,F<0,0>>
          <lvl_swvg,F<0,0>> =
            GHC.Err.error
              @ GHC.Types.Double
              (let {
                 <lvl_swvf,F<0,0>>
                 <lvl_swvf,F<0,0>> =
                   GHC.CString.unpackCString# "Negative exponent"# } in
               lvl_swvf) } in
        lvl_swvg
    };
<CLaSH.Sized.Fixed.fLit,<0,0>>
<CLaSH.Sized.Fixed.fLit,<0,0>> =
  \ <frac_avhM,<1,0>>
    <rep_avhN,<1,0>>
    <size_avhO,<1,0>>
    <$dKnownNat_avlM,<1,0>>
    <$dNum_avlN,<1,0>>
    <$dBounded_avlO,<1,0>>
    <$dIntegral_avlP,<1,0>>
    <a_auGC,<1,0>> ->
    let {
      <truncated_swu2,<1,1>>
      <truncated_swu2,<1,1>> =
        GHC.Float.RealFracMethods.truncateDoubleInteger
          (GHC.Float.timesDouble
             a_auGC
             (GHC.Real.^
                @ GHC.Types.Double
                @ GHC.Integer.Type.Integer
                GHC.Float.$fNumDouble
                GHC.Real.$fIntegralInteger
                (let {
                   <lvl_swvh,F<0,0>>
                   <lvl_swvh,F<0,0>> = GHC.Types.D# 2.0 } in
                 lvl_swvh)
                (GHC.TypeLits.natVal
                   @ frac_avhM
                   @ Data.Proxy.Proxy
                   $dKnownNat_avlM
                   (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avhM)))) } in
    let {
      <rMin_swu1,<1,2>>
      <rMin_swu1,<1,2>> =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    let {
      <rMax_swu0,<1,3>>
      <rMax_swu0,<1,3>> =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    Language.Haskell.TH.Syntax.unsafeTExpCoerce
      @ (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)
      (Language.Haskell.TH.Lib.appE
         (let {
            <lvl_swvp,F<0,0>>
            <lvl_swvp,F<0,0>> =
              Language.Haskell.TH.Lib.conE
                (let {
                   <lvl_swvo,F<0,0>>
                   <lvl_swvo,F<0,0>> =
                     Language.Haskell.TH.Syntax.mkNameG_d
                       (let {
                          <lvl_swvj,F<0,0>>
                          <lvl_swvj,F<0,0>> =
                            GHC.Base.build
                              @ GHC.Types.Char
                              (let {
                                 <lvl_swvi,F<0,0>>
                                 <lvl_swvi,F<0,0>> =
                                   \ <b_a4Iy,<0,1>> ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b_a4Iy "clash-prelude-0.5"# } in
                               lvl_swvi) } in
                        lvl_swvj)
                       (let {
                          <lvl_swvl,F<0,0>>
                          <lvl_swvl,F<0,0>> =
                            GHC.Base.build
                              @ GHC.Types.Char
                              (let {
                                 <lvl_swvk,F<0,0>>
                                 <lvl_swvk,F<0,0>> =
                                   \ <b_a4Iy,<0,1>> ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b_a4Iy "CLaSH.Sized.Fixed"# } in
                               lvl_swvk) } in
                        lvl_swvl)
                       (let {
                          <lvl_swvn,F<0,0>>
                          <lvl_swvn,F<0,0>> =
                            GHC.Base.build
                              @ GHC.Types.Char
                              (let {
                                 <lvl_swvm,F<0,0>>
                                 <lvl_swvm,F<0,0>> =
                                   \ <b_a4Iy,<0,1>> ->
                                     GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"# } in
                               lvl_swvm) } in
                        lvl_swvn) } in
                 lvl_swvo) } in
          lvl_swvp)
         (Language.Haskell.TH.Lib.appE
            (let {
               <lvl_swvx,F<0,0>>
               <lvl_swvx,F<0,0>> =
                 Language.Haskell.TH.Lib.varE
                   (let {
                      <lvl_swvw,F<0,0>>
                      <lvl_swvw,F<0,0>> =
                        Language.Haskell.TH.Syntax.mkNameG_v
                          (let {
                             <lvl_swvr,F<0,0>>
                             <lvl_swvr,F<0,0>> =
                               GHC.Base.build
                                 @ GHC.Types.Char
                                 (let {
                                    <lvl_swvq,F<0,0>>
                                    <lvl_swvq,F<0,0>> =
                                      \ <b_a4Iy,<0,1>> ->
                                        GHC.CString.unpackFoldrCString# @ b_a4Iy "base"# } in
                                  lvl_swvq) } in
                           lvl_swvr)
                          (let {
                             <lvl_swvt,F<0,0>>
                             <lvl_swvt,F<0,0>> =
                               GHC.Base.build
                                 @ GHC.Types.Char
                                 (let {
                                    <lvl_swvs,F<0,0>>
                                    <lvl_swvs,F<0,0>> =
                                      \ <b_a4Iy,<0,1>> ->
                                        GHC.CString.unpackFoldrCString# @ b_a4Iy "GHC.Num"# } in
                                  lvl_swvs) } in
                           lvl_swvt)
                          (let {
                             <lvl_swvv,F<0,0>>
                             <lvl_swvv,F<0,0>> =
                               GHC.Base.build
                                 @ GHC.Types.Char
                                 (let {
                                    <lvl_swvu,F<0,0>>
                                    <lvl_swvu,F<0,0>> =
                                      \ <b_a4Iy,<0,1>> ->
                                        GHC.CString.unpackFoldrCString# @ b_a4Iy "fromInteger"# } in
                                  lvl_swvu) } in
                           lvl_swvv) } in
                    lvl_swvw) } in
             lvl_swvx)
            (Language.Haskell.TH.Syntax.lift
               @ GHC.Integer.Type.Integer
               Language.Haskell.TH.Syntax.$fLiftInteger
               (case GHC.Integer.Type.gtInteger truncated_swu2 rMax_swu0
                of <wild_X13,<1,4>> {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger truncated_swu2 rMin_swu1
                    of <wild_Xd,<1,5>> {
                      GHC.Types.False -> truncated_swu2;
                      GHC.Types.True -> rMin_swu1
                    };
                  GHC.Types.True -> rMax_swu0
                }))))
<CLaSH.Sized.Fixed.satN2,<0,0>>
<CLaSH.Sized.Fixed.satN2,<0,0>> =
  \ <rep_aviy,<1,0>>
    <n_aviz,<1,0>>
    <tup_avmQ,<1,0>>
    <eta_B1,<1,0>> ->
    let {
      <cobox_swtW,<1,1>>
      <cobox_swtW,<1,1>> =
        case tup_avmQ
        of <wild_XY,<1,1>>
        { (<tpl_X1g,<1,1>>, <tpl_B2,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>, <tpl_B7,<1,1>>, <tpl_B8,<1,1>>, <tpl_B9,<1,1>>, <tpl_Ba,<1,1>>) ->
        tpl_B6
        } } in
    let {
      <cobox_swtV,<1,2>>
      <cobox_swtV,<1,2>> =
        case tup_avmQ
        of <wild_X10,<1,2>>
        { (<tpl_X1i,<1,2>>, <tpl_B2,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>) ->
        tpl_B5
        } } in
    let {
      <cobox_swtU,<1,3>>
      <cobox_swtU,<1,3>> =
        case tup_avmQ
        of <wild_X14,<1,3>>
        { (<tpl_X1l,<1,3>>, <tpl_B2,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_B2
        } } in
    let {
      <repBV_swtT,<1,4>>
      <repBV_swtT,<1,4>> =
        case case cobox_swtW
             of <cobox_avJ3,<1,4>> { GHC.Types.Eq# <cobox_dw6Z,<1,4>> ->
             GHC.Types.Eq#
               @ *
               @ (CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                    CLaSH.Bit.Bit)
               @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
               @~ (CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_N)_N
             }
        of <cobox_Xvnk,<1,4>> { GHC.Types.Eq# <cobox_dw6X,<1,4>> ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of <wild_X1m,<1,5>>
            { (<tpl_X1t,<1,5>>, <tpl_B2,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
            tpl_B4
            })
           (case cobox_swtW
            of <cobox_XvJf,<1,5>> { GHC.Types.Eq# <cobox_dw6Y,<1,5>> ->
            (case tup_avmQ
             of <wild_X1o,<1,6>>
             { (<tpl_X1x,<1,6>>, <tpl_B2,<1,6>>, <tpl_B3,<1,6>>, <tpl_B4,<1,6>>, <tpl_B5,<1,6>>, <tpl_B6,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>) ->
             tpl_B8
             })
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Y))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2))))
            })
           eta_B1)
        `cast` (Sub cobox_dw6X
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        } } in
    let {
      <s_swtS,<1,5>>
      <s_swtS,<1,5>> =
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (case case case cobox_swtU
                        of <cobox_avJi,<1,5>> { GHC.Types.Eq# <cobox_dw7d,<1,5>> ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ (n_aviz GHC.TypeLits.+ 2)
                          @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                          @~ (Sym cobox_dw7d)
                        }
                   of <cobox_avJg,<1,5>> { GHC.Types.Eq# <cobox_dw75,<1,5>> ->
                   GHC.Types.Eq#
                     @ *
                     @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                     @ (CLaSH.Sized.Vector.Vec
                          ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                     @~ (CLaSH.Sized.Vector.Vec cobox_dw75 <CLaSH.Bit.Bit>_N)_N
                   }
              of <cobox_XvnF,<1,5>> { GHC.Types.Eq# <cobox_dvY9,<1,5>> ->
              repBV_swtT
              `cast` (Sub cobox_dvY9
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
              })) } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of <wild_X1c,<1,6>>
            { (<tpl_X1t,<1,6>>, <tpl_B2,<1,6>>, <tpl_B3,<1,6>>, <tpl_B4,<1,6>>, <tpl_B5,<1,6>>, <tpl_B6,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>) ->
            tpl_Ba
            })
           eta_B1
    of <wild_X1t,<1,6>> {
      GHC.Types.False ->
        let {
          <ds_swtR,<1,7>>
          <ds_swtR,<1,7>> =
            CLaSH.Sized.Vector.vhead
              @ n_aviz
              @ CLaSH.Bit.Bit
              (CLaSH.Sized.Vector.vtail
                 @ (n_aviz GHC.TypeLits.+ 1)
                 @ CLaSH.Bit.Bit
                 (case case case cobox_swtU
                            of <cobox_avJd,<1,7>> { GHC.Types.Eq# <cobox_dw7g,<1,7>> ->
                            GHC.Types.Eq#
                              @ GHC.TypeLits.Nat
                              @ (n_aviz GHC.TypeLits.+ 2)
                              @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                              @~ (Sym cobox_dw7g)
                            }
                       of <cobox_avJb,<1,7>> { GHC.Types.Eq# <cobox_dw73,<1,7>> ->
                       GHC.Types.Eq#
                         @ *
                         @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                         @ (CLaSH.Sized.Vector.Vec
                              ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                         @~ (CLaSH.Sized.Vector.Vec cobox_dw73 <CLaSH.Bit.Bit>_N)_N
                       }
                  of <cobox_Xvny,<1,7>> { GHC.Types.Eq# <cobox_dvYc,<1,7>> ->
                  repBV_swtT
                  `cast` (Sub cobox_dvYc
                          :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                               ~#
                             CLaSH.Sized.Vector.Vec
                               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                  })) } in
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_swtU
                          of <cobox_avJ8,<1,8>> { GHC.Types.Eq# <cobox_dw7j,<1,8>> ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of <cobox_avJ6,<1,8>> { GHC.Types.Eq# <cobox_dw71,<1,8>> ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of <cobox_Xvnq,<1,8>> { GHC.Types.Eq# <cobox_dw6W,<1,8>> ->
                repBV_swtT
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of <wild_Xu,<1,8>> {
          CLaSH.Bit.H ->
            case ds_swtR of <wild_Xv,<1,9>> {
              CLaSH.Bit.H ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of <wild_XU,<1,10>>
                   { (<tpl_X1d,<1,10>>, <tpl_B2,<1,10>>, <tpl_B3,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of <wild_X12,<1,10>>
                   { (<tpl_X1k,<1,10>>, <tpl_B2,<1,10>>, <tpl_B3,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>) ->
                   tpl_B3
                   })
                  (case cobox_swtV
                   of <cobox_XvJ5,<1,10>> { GHC.Types.Eq# <cobox_dw7b,<1,10>> ->
                   (case tup_avmQ
                    of <wild_XW,<1,11>>
                    { (<tpl_X1e,<1,11>>, <tpl_B2,<1,11>>, <tpl_B3,<1,11>>, <tpl_B4,<1,11>>, <tpl_B5,<1,11>>, <tpl_B6,<1,11>>, <tpl_B7,<1,11>>, <tpl_B8,<1,11>>, <tpl_B9,<1,11>>, <tpl_Ba,<1,11>>) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV
                        of <cobox_XvJ4,<1,10>> { GHC.Types.Eq# <cobox_dw7c,<1,10>> ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of <cobox_Xvob,<1,10>> { GHC.Types.Eq# <cobox_dw6T,<1,10>> ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case ds_swtR of <wild_Xv,<1,9>> {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of <wild_XU,<1,10>>
                   { (<tpl_X1d,<1,10>>, <tpl_B2,<1,10>>, <tpl_B3,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of <wild_X12,<1,10>>
                   { (<tpl_X1k,<1,10>>, <tpl_B2,<1,10>>, <tpl_B3,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>) ->
                   tpl_B3
                   })
                  (case cobox_swtV
                   of <cobox_XvJ5,<1,10>> { GHC.Types.Eq# <cobox_dw7b,<1,10>> ->
                   (case tup_avmQ
                    of <wild_XW,<1,11>>
                    { (<tpl_X1e,<1,11>>, <tpl_B2,<1,11>>, <tpl_B3,<1,11>>, <tpl_B4,<1,11>>, <tpl_B5,<1,11>>, <tpl_B6,<1,11>>, <tpl_B7,<1,11>>, <tpl_B8,<1,11>>, <tpl_B9,<1,11>>, <tpl_Ba,<1,11>>) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV
                        of <cobox_XvJ4,<1,10>> { GHC.Types.Eq# <cobox_dw7c,<1,10>> ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of <cobox_Xvob,<1,10>> { GHC.Types.Eq# <cobox_dw6T,<1,10>> ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        };
      GHC.Types.True ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_swtU
                          of <cobox_avJ8,<1,7>> { GHC.Types.Eq# <cobox_dw7j,<1,7>> ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of <cobox_avJ6,<1,7>> { GHC.Types.Eq# <cobox_dw71,<1,7>> ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of <cobox_Xvnq,<1,7>> { GHC.Types.Eq# <cobox_dw6W,<1,7>> ->
                repBV_swtT
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of <wild_Xu,<1,7>> {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of <wild_X1e,<1,8>>
                    { (<tpl_X1p,<1,8>>, <tpl_B2,<1,8>>, <tpl_B3,<1,8>>, <tpl_B4,<1,8>>, <tpl_B5,<1,8>>, <tpl_B6,<1,8>>, <tpl_B7,<1,8>>, <tpl_B8,<1,8>>, <tpl_B9,<1,8>>, <tpl_Ba,<1,8>>) ->
                    tpl_X1p
                    })
                   s_swtS
            of <wild_Xv,<1,8>> {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of <wild_X12,<1,9>>
                   { (<tpl_X1k,<1,9>>, <tpl_B2,<1,9>>, <tpl_B3,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>) ->
                   tpl_B3
                   })
                  (case cobox_swtV
                   of <cobox_XvJ7,<1,9>> { GHC.Types.Eq# <cobox_dw79,<1,9>> ->
                   (case tup_avmQ
                    of <wild_XW,<1,10>>
                    { (<tpl_X1e,<1,10>>, <tpl_B2,<1,10>>, <tpl_B3,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV
                        of <cobox_avJl,<1,9>> { GHC.Types.Eq# <cobox_dw7a,<1,9>> ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of <cobox_Xvo0,<1,9>> { GHC.Types.Eq# <cobox_dw6S,<1,9>> ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of <wild_XU,<1,9>>
                   { (<tpl_X1d,<1,9>>, <tpl_B2,<1,9>>, <tpl_B3,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>) ->
                   tpl_B9
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of <wild_X1e,<1,8>>
                    { (<tpl_X1p,<1,8>>, <tpl_B2,<1,8>>, <tpl_B3,<1,8>>, <tpl_B4,<1,8>>, <tpl_B5,<1,8>>, <tpl_B6,<1,8>>, <tpl_B7,<1,8>>, <tpl_B8,<1,8>>, <tpl_B9,<1,8>>, <tpl_Ba,<1,8>>) ->
                    tpl_X1p
                    })
                   s_swtS
            of <wild_Xv,<1,8>> {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of <wild_XU,<1,9>>
                   { (<tpl_X1d,<1,9>>, <tpl_B2,<1,9>>, <tpl_B3,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of <wild_X12,<1,9>>
                   { (<tpl_X1k,<1,9>>, <tpl_B2,<1,9>>, <tpl_B3,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>) ->
                   tpl_B3
                   })
                  (case cobox_swtV
                   of <cobox_XvJ7,<1,9>> { GHC.Types.Eq# <cobox_dw79,<1,9>> ->
                   (case tup_avmQ
                    of <wild_XW,<1,10>>
                    { (<tpl_X1e,<1,10>>, <tpl_B2,<1,10>>, <tpl_B3,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV
                        of <cobox_avJl,<1,9>> { GHC.Types.Eq# <cobox_dw7a,<1,9>> ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of <cobox_Xvo0,<1,9>> { GHC.Types.Eq# <cobox_dw6S,<1,9>> ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
    }
<CLaSH.Sized.Fixed.resizeF,<0,0>>
<CLaSH.Sized.Fixed.resizeF,<0,0>> =
  \ <frac1_avjq,<1,0>>
    <frac2_avjr,<1,0>>
    <rep_avjs,<1,0>>
    <size1_avjt,<1,0>>
    <size2_avju,<1,0>>
    <tup_avnK,<1,0>>
    <eta_B1,<1,0>> ->
    let {
      <$dKnownNat_swtI,<1,1>>
      <$dKnownNat_swtI,<1,1>> =
        case tup_avnK
        of <wild_X10,<1,1>>
        { (<tpl_X1i,<1,1>>, <tpl_B2,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>, <tpl_B7,<1,1>>, <tpl_B8,<1,1>>, <tpl_B9,<1,1>>, <tpl_Ba,<1,1>>, <tpl_Bb,<1,1>>, <tpl_Bc,<1,1>>) ->
        tpl_B8
        } } in
    let {
      <$dKnownNat_swtH,<1,2>>
      <$dKnownNat_swtH,<1,2>> =
        case tup_avnK
        of <wild_X12,<1,2>>
        { (<tpl_X1k,<1,2>>, <tpl_B2,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B7
        } } in
    let {
      <$dResize_swtG,<1,3>>
      <$dResize_swtG,<1,3>> =
        case tup_avnK
        of <wild_X14,<1,3>>
        { (<tpl_X1m,<1,3>>, <tpl_B2,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B6
        } } in
    let {
      <$dBits_swtF,<1,4>>
      <$dBits_swtF,<1,4>> =
        case tup_avnK
        of <wild_X16,<1,4>>
        { (<tpl_X1o,<1,4>>, <tpl_B2,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>, <tpl_Bb,<1,4>>, <tpl_Bc,<1,4>>) ->
        tpl_B5
        } } in
    let {
      <$dNum_swtE,<1,5>>
      <$dNum_swtE,<1,5>> =
        case tup_avnK
        of <wild_X1a,<1,5>>
        { (<tpl_X1r,<1,5>>, <tpl_B2,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>, <tpl_Bb,<1,5>>, <tpl_Bc,<1,5>>) ->
        tpl_B4
        } } in
    let {
      <$dBounded_swtD,<1,6>>
      <$dBounded_swtD,<1,6>> =
        case tup_avnK
        of <wild_X1e,<1,6>>
        { (<tpl_X1u,<1,6>>, <tpl_B2,<1,6>>, <tpl_B3,<1,6>>, <tpl_B4,<1,6>>, <tpl_B5,<1,6>>, <tpl_B6,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>, <tpl_Bb,<1,6>>, <tpl_Bc,<1,6>>) ->
        tpl_X1u
        } } in
    let {
      <resFracSZ_swtC,<1,7>>
      <resFracSZ_swtC,<1,7>> =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac2_avjr
             @ Data.Proxy.Proxy
             (case tup_avnK
              of <wild_X1i,<1,7>>
              { (<tpl_X1w,<1,7>>, <tpl_B2,<1,7>>, <tpl_B3,<1,7>>, <tpl_B4,<1,7>>, <tpl_B5,<1,7>>, <tpl_B6,<1,7>>, <tpl_B7,<1,7>>, <tpl_B8,<1,7>>, <tpl_B9,<1,7>>, <tpl_Ba,<1,7>>, <tpl_Bb,<1,7>>, <tpl_Bc,<1,7>>) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac2_avjr)) } in
    let {
      <argFracSZ_swtB,<1,8>>
      <argFracSZ_swtB,<1,8>> =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac1_avjq
             @ Data.Proxy.Proxy
             (case tup_avnK
              of <wild_X1g,<1,8>>
              { (<tpl_X1y,<1,8>>, <tpl_B2,<1,8>>, <tpl_B3,<1,8>>, <tpl_B4,<1,8>>, <tpl_B5,<1,8>>, <tpl_B6,<1,8>>, <tpl_B7,<1,8>>, <tpl_B8,<1,8>>, <tpl_B9,<1,8>>, <tpl_Ba,<1,8>>, <tpl_Bb,<1,8>>, <tpl_Bc,<1,8>>) ->
              tpl_Bb
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac1_avjq)) } in
    case GHC.Integer.Type.leInteger
           (GHC.TypeLits.natVal
              @ size1_avjt
              @ Data.Proxy.Proxy
              $dKnownNat_swtI
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size1_avjt))
           (GHC.TypeLits.natVal
              @ size2_avju
              @ Data.Proxy.Proxy
              $dKnownNat_swtH
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size2_avju))
    of <wild_X1o,<1,9>> {
      GHC.Types.False ->
        let {
          <fMax_swtA,<1,10>>
          <fMax_swtA,<1,10>> =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          <mask_swtz,<1,11>>
          <mask_swtz,<1,11>> =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (CLaSH.Class.Num.resize
                 @ rep_avjs
                 $dResize_swtG
                 @ size2_avju
                 @ size1_avjt
                 $dKnownNat_swtH
                 $dKnownNat_swtI
                 fMax_swtA) } in
        case GHC.Classes.leInt argFracSZ_swtB resFracSZ_swtC
        of <wild_Xr,<1,12>> {
          GHC.Types.False ->
            let {
              <shiftedR_swty,<1,13>>
              <shiftedR_swty,<1,13>> =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- argFracSZ_swtB resFracSZ_swtC) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of <wild_X1c,<1,14>>
                    { (<tpl_X1t,<1,14>>, <tpl_B2,<1,14>>, <tpl_B3,<1,14>>, <tpl_B4,<1,14>>, <tpl_B5,<1,14>>, <tpl_B6,<1,14>>, <tpl_B7,<1,14>>, <tpl_B8,<1,14>>, <tpl_B9,<1,14>>, <tpl_Ba,<1,14>>, <tpl_Bb,<1,14>>, <tpl_Bc,<1,14>>) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt)
                      $dNum_swtE
                      (let {
                         <lvl_swvy,F<0,0>>
                         <lvl_swvy,F<0,0>> = __integer 0 } in
                       lvl_swvy))
            of <wild_Xv,<1,14>> {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of <wild_Xw,<1,15>> {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger
                          @ (rep_avjs size1_avjt)
                          $dNum_swtE
                          (let {
                             <lvl_swvz,F<0,0>>
                             <lvl_swvz,F<0,0>> = __integer 0 } in
                           lvl_swvz))
                of <wild_Xw,<1,15>> {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              <shiftedL_swtK,<1,13>>
              <shiftedL_swtK,<1,13>> =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- resFracSZ_swtC argFracSZ_swtB) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of <wild_X1c,<1,14>>
                    { (<tpl_X1t,<1,14>>, <tpl_B2,<1,14>>, <tpl_B3,<1,14>>, <tpl_B4,<1,14>>, <tpl_B5,<1,14>>, <tpl_B6,<1,14>>, <tpl_B7,<1,14>>, <tpl_B8,<1,14>>, <tpl_B9,<1,14>>, <tpl_Ba,<1,14>>, <tpl_Bb,<1,14>>, <tpl_Bc,<1,14>>) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt)
                      $dNum_swtE
                      (let {
                         <lvl_swvA,F<0,0>>
                         <lvl_swvA,F<0,0>> = __integer 0 } in
                       lvl_swvA))
            of <wild_Xv,<1,14>> {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of <wild_Xw,<1,15>> {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger
                          @ (rep_avjs size1_avjt)
                          $dNum_swtE
                          (let {
                             <lvl_swvB,F<0,0>>
                             <lvl_swvB,F<0,0>> = __integer 0 } in
                           lvl_swvB))
                of <wild_Xw,<1,15>> {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        };
      GHC.Types.True ->
        case GHC.Classes.leInt argFracSZ_swtB resFracSZ_swtC
        of <wild_Xo,<1,10>> {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of <wild_XY,<1,11>>
                { (<tpl_X1h,<1,11>>, <tpl_B2,<1,11>>, <tpl_B3,<1,11>>, <tpl_B4,<1,11>>, <tpl_B5,<1,11>>, <tpl_B6,<1,11>>, <tpl_B7,<1,11>>, <tpl_B8,<1,11>>, <tpl_B9,<1,11>>, <tpl_Ba,<1,11>>, <tpl_Bb,<1,11>>, <tpl_Bc,<1,11>>) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_swtG
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- argFracSZ_swtB resFracSZ_swtC))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of <wild_XY,<1,11>>
                { (<tpl_X1h,<1,11>>, <tpl_B2,<1,11>>, <tpl_B3,<1,11>>, <tpl_B4,<1,11>>, <tpl_B5,<1,11>>, <tpl_B6,<1,11>>, <tpl_B7,<1,11>>, <tpl_B8,<1,11>>, <tpl_B9,<1,11>>, <tpl_Ba,<1,11>>, <tpl_Bb,<1,11>>, <tpl_Bc,<1,11>>) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_swtG
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- resFracSZ_swtC argFracSZ_swtB))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
    }
<CLaSH.Sized.Fixed.asRepProxy,<0,0>>
<CLaSH.Sized.Fixed.asRepProxy,<0,0>> =
  \ <frac_avk6,<1,0>>
    <rep_avk7,<1,0>>
    <size_avk8,<1,0>>
    <ds_dvZa,<1,0>> ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7
<CLaSH.Sized.Fixed.asFracProxy,<0,0>>
<CLaSH.Sized.Fixed.asFracProxy,<0,0>> =
  \ <frac_avkp,<1,0>>
    <rep_avkq,<1,0>>
    <size_avkr,<1,0>>
    <ds_dvZf,<1,0>> ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp
<CLaSH.Sized.Fixed.fracShift,<0,0>>
<CLaSH.Sized.Fixed.fracShift,<0,0>> =
  \ <frac_avjN,<1,0>>
    <rep_avjO,<1,0>>
    <size_avjP,<1,0>>
    <$dKnownNat_avxa,<1,0>>
    <f_auGd,<1,0>> ->
    GHC.Num.$fNumInt_$cfromInteger
      (GHC.TypeLits.natVal
         @ frac_avjN
         @ Data.Proxy.Proxy
         $dKnownNat_avxa
         (CLaSH.Sized.Fixed.asFracProxy
            @ frac_avjN @ rep_avjO @ size_avjP f_auGd))
<a_swaI,<0,0>>
<a_swaI,<0,0>> =
  \ <int_avkK,<1,0>> <frac_avkL,<1,0>> <ds_dvZi,<1,0>> -> ds_dvZi
<CLaSH.Sized.Fixed.unUF,<0,0>>
<CLaSH.Sized.Fixed.unUF,<0,0>> =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))
<a_swaJ,<0,0>>
<a_swaJ,<0,0>> =
  \ <frac_avl5,<1,0>>
    <int_avl6,<1,0>>
    <ds_dvZp,<1,0>>
    <fRep_auGb,<1,0>> ->
    fRep_auGb
<CLaSH.Sized.Fixed.uf,<0,0>>
<CLaSH.Sized.Fixed.uf,<0,0>> =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))
<a_swaK,<0,0>>
<a_swaK,<0,0>> =
  \ <int_avlp,<1,0>> <frac_avlq,<1,0>> <ds_dvZu,<1,0>> -> ds_dvZu
<CLaSH.Sized.Fixed.unSF,<0,0>>
<CLaSH.Sized.Fixed.unSF,<0,0>> =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))
<a_swaL,<0,0>>
<a_swaL,<0,0>> =
  \ <frac_avlK,<1,0>>
    <int_avlL,<1,0>>
    <ds_dvZB,<1,0>>
    <fRep_auG9,<1,0>> ->
    fRep_auG9
<CLaSH.Sized.Fixed.sf,<0,0>>
<CLaSH.Sized.Fixed.sf,<0,0>> =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))
<a_swaM,<0,0>>
<a_swaM,<0,0>> =
  \ <frac_auI2,<1,0>>
    <rep_auI3,<1,0>>
    <size_auI4,<1,0>>
    <ds_dvZF,<1,0>> ->
    ds_dvZF
<CLaSH.Sized.Fixed.unFixed,<0,0>>
<CLaSH.Sized.Fixed.unFixed,<0,0>> =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))
<$cshow_avFD,<0,0>>
<$cshow_avFD,<0,0>> =
  \ <frac_auHx,<1,0>>
    <rep_auHy,<1,0>>
    <size_auHz,<1,0>>
    <$dShow_avFv,<1,0>>
    <$dBits_avFw,<1,0>>
    <$dKnownNat_avFx,<1,0>>
    <$dIntegral_avFy,<1,0>>
    <f_auHA,<1,0>> ->
    let {
      <fRepI_swtk,<1,1>>
      <fRepI_swtk,<1,1>> =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      <fRepI_abs_swtj,<1,2>>
      <fRepI_abs_swtj,<1,2>> =
        GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      <nF_swti,<1,3>>
      <nF_swti,<1,3>> =
        CLaSH.Sized.Fixed.fracShift
          @ frac_auHx @ rep_auHy @ size_auHz $dKnownNat_avFx f_auHA } in
    GHC.Base.augment
      @ GHC.Types.Char
      (\ <b_a4II,<1,4>> <c_a4IJ,<1,4>> <n_a4IK,<1,4>> ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a4II
           c_a4IJ
           n_a4IK
           (case GHC.Integer.Type.ltInteger
                   fRepI_swtk
                   (let {
                      <lvl_swvC,F<0,0>>
                      <lvl_swvC,F<0,0>> = __integer 0 } in
                    lvl_swvC)
            of <wild_X1C,<1,5>> {
              GHC.Types.False ->
                GHC.Show.$fShowInteger_$cshow
                  (Data.Bits.$fBitsInteger_$cshiftR fRepI_swtk nF_swti);
              GHC.Types.True ->
                GHC.Types.:
                  @ GHC.Types.Char
                  (let {
                     <lvl_swvD,F<0,0>>
                     <lvl_swvD,F<0,0>> = GHC.Types.C# '-' } in
                   lvl_swvD)
                  (GHC.Show.$fShowInteger_$cshow
                     (Data.Bits.$fBitsInteger_$cshiftR fRepI_abs_swtj nF_swti))
            }))
      (GHC.Base.augment
         @ GHC.Types.Char
         (let {
            <lvl_swvF,F<0,0>>
            <lvl_swvF,F<0,0>> =
              \ <b_X4Kn,<0,1>> <c_X4Kp,<0,1>> <n_X4Kr,<0,1>> ->
                c_X4Kp
                  (let {
                     <lvl_swvE,F<0,0>>
                     <lvl_swvE,F<0,0>> = GHC.Types.C# '.' } in
                   lvl_swvE)
                  n_X4Kr } in
          lvl_swvF)
         (GHC.Base.$
            @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
            @ [GHC.Types.Char]
            (let {
               <lvl_sww3,F<0,0>>
               <lvl_sww3,F<0,0>> =
                 GHC.Base..
                   @ (GHC.Types.Int, [GHC.Types.Char])
                   @ [GHC.Types.Char]
                   @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                   (let {
                      <lvl_swvI,F<0,0>>
                      <lvl_swvI,F<0,0>> =
                        Data.Tuple.uncurry
                          @ GHC.Types.Int
                          @ [GHC.Types.Char]
                          @ [GHC.Types.Char]
                          (let {
                             <lvl_swvH,F<0,0>>
                             <lvl_swvH,F<0,0>> =
                               \ <n_auHJ,<0,1>> <str_auHK,<0,1>> ->
                                 GHC.Base.augment
                                   @ GHC.Types.Char
                                   (\ <b_X4M9,<0,2>> <c_X4Mc,<0,2>> <n_X4Kt,<0,2>> ->
                                      GHC.Base.foldr
                                        @ GHC.Types.Char
                                        @ b_X4M9
                                        c_X4Mc
                                        n_X4Kt
                                        (GHC.List.replicate
                                           @ GHC.Types.Char
                                           (GHC.Num.$fNumInt_$c-
                                              n_auHJ
                                              (GHC.Base.foldr
                                                 @ GHC.Types.Char
                                                 @ (GHC.Prim.Int# -> GHC.Types.Int)
                                                 (GHC.List.incLen @ GHC.Types.Char)
                                                 GHC.Types.I#
                                                 str_auHK
                                                 0))
                                           (let {
                                              <lvl_swvG,F<0,0>>
                                              <lvl_swvG,F<0,0>> = GHC.Types.C# '0' } in
                                            lvl_swvG)))
                                   str_auHK } in
                           lvl_swvH) } in
                    lvl_swvI)
                   (let {
                      <lvl_sww2,F<0,0>>
                      <lvl_sww2,F<0,0>> =
                        GHC.Base..
                          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                          @ (GHC.Types.Int, [GHC.Types.Char])
                          @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                          (let {
                             <lvl_swvL,F<0,0>>
                             <lvl_swvL,F<0,0>> =
                               Control.Arrow.$fArrow(->)_$csecond
                                 @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 @ [GHC.Types.Char]
                                 @ GHC.Types.Int
                                 (let {
                                    <lvl_swvK,F<0,0>>
                                    <lvl_swvK,F<0,0>> =
                                      GHC.Base..
                                        @ GHC.Integer.Type.Integer
                                        @ GHC.Base.String
                                        @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                        GHC.Show.$fShowInteger_$cshow
                                        (let {
                                           <lvl_swvJ,F<0,0>>
                                           <lvl_swvJ,F<0,0>> =
                                             GHC.Real.numerator
                                               @ GHC.Integer.Type.Integer
                                               GHC.Real.$fIntegralInteger } in
                                         lvl_swvJ) } in
                                  lvl_swvK) } in
                           lvl_swvL)
                          (let {
                             <lvl_sww1,F<0,0>>
                             <lvl_sww1,F<0,0>> =
                               GHC.Base..
                                 @ (Data.Maybe.Maybe
                                      (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                                 @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                 (Data.Maybe.fromJust
                                    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                                 (let {
                                    <lvl_sww0,F<0,0>>
                                    <lvl_sww0,F<0,0>> =
                                      GHC.Base..
                                        @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                                        @ (Data.Maybe.Maybe
                                             (GHC.Types.Int,
                                              GHC.Real.Ratio GHC.Integer.Type.Integer))
                                        @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                        (let {
                                           <lvl_swvR,F<0,0>>
                                           <lvl_swvR,F<0,0>> =
                                             Data.List.find
                                               @ (GHC.Types.Int,
                                                  GHC.Real.Ratio GHC.Integer.Type.Integer)
                                               (let {
                                                  <lvl_swvQ,F<0,0>>
                                                  <lvl_swvQ,F<0,0>> =
                                                    GHC.Base..
                                                      @ GHC.Integer.Type.Integer
                                                      @ GHC.Types.Bool
                                                      @ (GHC.Types.Int,
                                                         GHC.Real.Ratio GHC.Integer.Type.Integer)
                                                      (let {
                                                         <lvl_swvN,F<0,0>>
                                                         <lvl_swvN,F<0,0>> =
                                                           let {
                                                             <ds_swvM,F<0,0>>
                                                             <ds_swvM,F<0,0>> = __integer 1 } in
                                                           \ <ds_dw44,<0,1>> ->
                                                             GHC.Integer.Type.eqInteger
                                                               ds_dw44 ds_swvM } in
                                                       lvl_swvN)
                                                      (let {
                                                         <lvl_swvP,F<0,0>>
                                                         <lvl_swvP,F<0,0>> =
                                                           GHC.Base..
                                                             @ (GHC.Real.Ratio
                                                                  GHC.Integer.Type.Integer)
                                                             @ GHC.Integer.Type.Integer
                                                             @ (GHC.Types.Int,
                                                                GHC.Real.Ratio
                                                                  GHC.Integer.Type.Integer)
                                                             (let {
                                                                <lvl_swvO,F<0,0>>
                                                                <lvl_swvO,F<0,0>> =
                                                                  GHC.Real.denominator
                                                                    @ GHC.Integer.Type.Integer
                                                                    GHC.Real.$fIntegralInteger } in
                                                              lvl_swvO)
                                                             (Data.Tuple.snd
                                                                @ GHC.Types.Int
                                                                @ (GHC.Real.Ratio
                                                                     GHC.Integer.Type.Integer)) } in
                                                       lvl_swvP) } in
                                                lvl_swvQ) } in
                                         lvl_swvR)
                                        (let {
                                           <lvl_swvZ,F<0,0>>
                                           <lvl_swvZ,F<0,0>> =
                                             GHC.Base..
                                               @ (GHC.Types.Int,
                                                  GHC.Real.Ratio GHC.Integer.Type.Integer)
                                               @ [(GHC.Types.Int,
                                                   GHC.Real.Ratio GHC.Integer.Type.Integer)]
                                               @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                               (let {
                                                  <lvl_swvW,F<0,0>>
                                                  <lvl_swvW,F<0,0>> =
                                                    GHC.List.iterate
                                                      @ (GHC.Types.Int,
                                                         GHC.Real.Ratio GHC.Integer.Type.Integer)
                                                      (let {
                                                         <lvl_swvV,F<0,0>>
                                                         <lvl_swvV,F<0,0>> =
                                                           Control.Arrow.$fArrow(->)_$c***
                                                             @ GHC.Types.Int
                                                             @ GHC.Types.Int
                                                             @ (GHC.Real.Ratio
                                                                  GHC.Integer.Type.Integer)
                                                             @ (GHC.Real.Ratio
                                                                  GHC.Integer.Type.Integer)
                                                             GHC.Enum.$fEnumInt_$csucc
                                                             (let {
                                                                <lvl_swvU,F<0,0>>
                                                                <lvl_swvU,F<0,0>> =
                                                                  let {
                                                                    <ds_swvT,F<0,0>>
                                                                    <ds_swvT,F<0,0>> =
                                                                      GHC.Real.$fNumRatio_$s$cfromInteger
                                                                        (let {
                                                                           <lvl_swvS,F<0,0>>
                                                                           <lvl_swvS,F<0,0>> =
                                                                             __integer 10 } in
                                                                         lvl_swvS) } in
                                                                  \ <ds_dw47,<0,1>> ->
                                                                    GHC.Real.$fNumRatio_$s$c*
                                                                      ds_dw47 ds_swvT } in
                                                              lvl_swvU) } in
                                                       lvl_swvV) } in
                                                lvl_swvW)
                                               (let {
                                                  <lvl_swvY,F<0,0>>
                                                  <lvl_swvY,F<0,0>> =
                                                    GHC.Tuple.(,)
                                                      @ GHC.Types.Int
                                                      @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
                                                      (let {
                                                         <lvl_swvX,F<0,0>>
                                                         <lvl_swvX,F<0,0>> = GHC.Types.I# 0 } in
                                                       lvl_swvX) } in
                                                lvl_swvY) } in
                                         lvl_swvZ) } in
                                  lvl_sww0) } in
                           lvl_sww1) } in
                    lvl_sww2) } in
             lvl_sww3)
            (GHC.Real.%_$s%
               (case GHC.Integer.Type.ltInteger
                       fRepI_swtk
                       (let {
                          <lvl_sww4,F<0,0>>
                          <lvl_sww4,F<0,0>> = __integer 0 } in
                        lvl_sww4)
                of <wild_X1C,<1,4>> {
                  GHC.Types.False ->
                    GHC.Integer.Type.andInteger
                      fRepI_swtk
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            (let {
                               <lvl_sww5,F<0,0>>
                               <lvl_sww5,F<0,0>> = __integer 2 } in
                             lvl_sww5)
                            nF_swti)
                         (let {
                            <lvl_sww6,F<0,0>>
                            <lvl_sww6,F<0,0>> = __integer 1 } in
                          lvl_sww6));
                  GHC.Types.True ->
                    GHC.Integer.Type.andInteger
                      fRepI_abs_swtj
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            (let {
                               <lvl_sww7,F<0,0>>
                               <lvl_sww7,F<0,0>> = __integer 2 } in
                             lvl_sww7)
                            nF_swti)
                         (let {
                            <lvl_sww8,F<0,0>>
                            <lvl_sww8,F<0,0>> = __integer 1 } in
                          lvl_sww8))
                })
               (GHC.Real.^
                  @ GHC.Integer.Type.Integer
                  @ GHC.Types.Int
                  GHC.Num.$fNumInteger
                  GHC.Real.$fIntegralInt
                  (let {
                     <lvl_sww9,F<0,0>>
                     <lvl_sww9,F<0,0>> = __integer 2 } in
                   lvl_sww9)
                  nF_swti))))
<$cshowsPrec_avFB,<0,0>>
<$cshowsPrec_avFB,<0,0>> =
  \ <frac_auHx,<1,0>>
    <rep_auHy,<1,0>>
    <size_auHz,<1,0>>
    <$dShow_avFv,<1,0>>
    <$dBits_avFw,<1,0>>
    <$dKnownNat_avFx,<1,0>>
    <$dIntegral_avFy,<1,0>>
    <ds_a2fX,<1,0>>
    <x_a2fY,<1,0>>
    <s_a2fZ,<1,0>> ->
    GHC.Base.augment
      @ GHC.Types.Char
      (\ <b_a2g3,<1,1>> <c_a2g4,<1,1>> <n_a2g5,<1,1>> ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a2g3
           c_a2g4
           n_a2g5
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY))
      s_a2fZ
<CLaSH.Sized.Fixed.$fShowFixed,<0,0>>
<CLaSH.Sized.Fixed.$fShowFixed,<0,0>> =
  \ <frac_auHx,<1,0>>
    <rep_auHy,<1,0>>
    <size_auHz,<1,0>>
    <$dShow_avFv,<1,0>>
    <$dBits_avFw,<1,0>>
    <$dKnownNat_avFx,<1,0>>
    <$dIntegral_avFy,<1,0>> ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy);
<$cshowList_avIE,<0,0>>
<$cshowList_avIE,<0,0>> =
  \ <frac_auHx,<1,0>>
    <rep_auHy,<1,0>>
    <size_auHz,<1,0>>
    <$dShow_avFv,<1,0>>
    <$dBits_avFw,<1,0>>
    <$dKnownNat_avFx,<1,0>>
    <$dIntegral_avFy,<1,0>> ->
    let {
      <$dShow_swtc,<1,1>>
      <$dShow_swtc,<1,1>> =
        CLaSH.Sized.Fixed.$fShowFixed
          @ frac_auHx
          @ rep_auHy
          @ size_auHz
          $dShow_avFv
          $dBits_avFw
          $dKnownNat_avFx
          $dIntegral_avFy } in
    \ <ls_a2fk,<2,0>> <s_a2fl,<2,0>> ->
      GHC.Show.showList__
        @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
        (let {
           <lvl_swwa,F<1,1>>
           <lvl_swwa,F<1,1>> =
             GHC.Show.shows
               @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
               $dShow_swtc } in
         lvl_swwa)
        ls_a2fk
        s_a2fl;
<a_swjx,<0,0>>
<a_swjx,<0,0>> =
  \ <frac1_auHq,<1,0>>
    <rep_auHr,<1,0>>
    <size1_auHs,<1,0>>
    <frac2_auHt,<1,0>>
    <size2_auHu,<1,0>>
    <tup_avFg,<1,0>>
    <eta_B2,<1,0>>
    <eta_B1,<1,0>> ->
    case case tup_avFg
         of <wild_X1y,<1,1>> { (<tpl_X1z,<1,1>>, <tpl_X1B,<1,1>>) ->
         tpl_X1B
         }
    of <cobox_XvFS,<1,1>> { GHC.Types.Eq# <cobox_dw3M,<1,1>> ->
    (CLaSH.Class.Num.mult
       @ (rep_auHr size1_auHs)
       @ (rep_auHr size2_auHu)
       (case tup_avFg
        of <wild_X1z,<1,2>> { (<tpl_X1C,<1,2>>, <tpl_X1E,<1,2>>) ->
        tpl_X1C
        })
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
<$cmult_avFi,<0,0>>
<$cmult_avFi,<0,0>> =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))
<CLaSH.Sized.Fixed.$fMultFixedFixed,<0,0>>
<CLaSH.Sized.Fixed.$fMultFixedFixed,<0,0>> =
  $cmult_avFi
  `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                 (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                 (size1_XuJ3 :: GHC.TypeLits.Nat)
                 (frac2_XuJ5 :: GHC.TypeLits.Nat)
                 (size2_XuJ7 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
          -> Sym
               (CLaSH.Class.Num.NTCo:Mult[0]
                  <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                  <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
          :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
              -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                   (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
               ~#
             (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))
<$cminus_avEx,<0,0>>
<$cminus_avEx,<0,0>> =
  \ <frac1_auHd,<1,0>>
    <rep_auHe,<1,0>>
    <size1_auHf,<1,0>>
    <frac2_auHg,<1,0>>
    <size2_auHh,<1,0>>
    <tup_avDN,<1,0>>
    <eta_X1I,<1,0>>
    <eta_X3p,<1,0>> ->
    letrec {
      <$dBits_swt2,<1,1>>
      <$dBits_swt2,<1,1>> =
        case tup_swt3
        of <wild_X26,<1,2>>
        { (<tpl_X21,<1,2>>, <tpl_X23,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B5
        };
      <tup_swt3,<1,1>>
      <tup_swt3,<1,1>> =
        case tup_avDN
        of <wild_X20,<1,2>>
        { (<tpl_X1Z,<1,2>>, <tpl_X21,<1,2>>, <tpl_B3,<1,2>>) ->
        tpl_X1Z
        }; } in
    letrec {
      <$dKnownNat_swt4,<1,2>>
      <$dKnownNat_swt4,<1,2>> =
        case tup_swta
        of <wild_X1U,<1,3>>
        { (<tpl_X1X,<1,3>>, <tpl_X1Z,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_Ba
        };
      <$dBits_swt5,<1,2>>
      <$dBits_swt5,<1,2>> =
        case tup_swta
        of <wild_X1S,<1,3>>
        { (<tpl_X1V,<1,3>>, <tpl_X1X,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B9
        };
      <$dKnownNat_swt6,<1,2>>
      <$dKnownNat_swt6,<1,2>> =
        case tup_swta
        of <wild_X1O,<1,3>>
        { (<tpl_X1T,<1,3>>, <tpl_X1V,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B7
        };
      <$dResize_swt7,<1,2>>
      <$dResize_swt7,<1,2>> =
        case tup_swta
        of <wild_X1M,<1,3>>
        { (<tpl_X1R,<1,3>>, <tpl_X1T,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B6
        };
      <$dBits_swt8,<1,2>>
      <$dBits_swt8,<1,2>> =
        case tup_swta
        of <wild_X3v,<1,3>>
        { (<tpl_X1P,<1,3>>, <tpl_X1R,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B5
        };
      <$dBounded_swt9,<1,2>>
      <$dBounded_swt9,<1,2>> =
        case tup_swta
        of <wild_X1C,<1,3>>
        { (<tpl_X1N,<1,3>>, <tpl_X1P,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_X1N
        };
      <tup_swta,<1,2>>
      <tup_swta,<1,2>> =
        case tup_avDN
        of <wild_X1A,<1,3>>
        { (<tpl_X1L,<1,3>>, <tpl_X1N,<1,3>>, <tpl_B3,<1,3>>) ->
        tpl_X1N
        }; } in
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN
        of <wild_X2g,<1,3>>
        { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>) ->
        tpl_B3
        })
       ((CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tup_swt3
            of <wild_X22,<1,3>>
            { (<tpl_X43,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B3
            },
            case tup_swt3
            of <wild_X24,<1,3>>
            { (<tpl_X22,<1,3>>, <tpl_X46,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swt3
            of <wild_X2a,<1,3>>
            { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swt3
            of <wild_X2c,<1,3>>
            { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_Bb
            },
            case tup_swt3
            of <wild_X2e,<1,3>>
            { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of <wild_X1E,<1,3>>
            { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B3
            },
            case tup_swta
            of <wild_X1G,<1,3>>
            { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of <wild_X1Q,<1,3>>
            { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of <wild_X1W,<1,3>>
            { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_Bb
            },
            case tup_swta
            of <wild_X1Y,<1,3>>
            { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
<$cplus_avDP,<0,0>>
<$cplus_avDP,<0,0>> =
  \ <frac1_auHd,<1,0>>
    <rep_auHe,<1,0>>
    <size1_auHf,<1,0>>
    <frac2_auHg,<1,0>>
    <size2_auHh,<1,0>>
    <tup_avDN,<1,0>>
    <eta_X1J,<1,0>>
    <eta_X3r,<1,0>> ->
    letrec {
      <$dBits_swsK,<1,1>>
      <$dBits_swsK,<1,1>> =
        case tup_swsL
        of <wild_X27,<1,2>>
        { (<tpl_X22,<1,2>>, <tpl_X24,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B5
        };
      <tup_swsL,<1,1>>
      <tup_swsL,<1,1>> =
        case tup_avDN
        of <wild_X21,<1,2>>
        { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>) ->
        tpl_X20
        }; } in
    letrec {
      <$dKnownNat_swsM,<1,2>>
      <$dKnownNat_swsM,<1,2>> =
        case tup_swsS
        of <wild_X1V,<1,3>>
        { (<tpl_X1Y,<1,3>>, <tpl_X20,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_Ba
        };
      <$dBits_swsN,<1,2>>
      <$dBits_swsN,<1,2>> =
        case tup_swsS
        of <wild_X1T,<1,3>>
        { (<tpl_X1W,<1,3>>, <tpl_X1Y,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B9
        };
      <$dKnownNat_swsO,<1,2>>
      <$dKnownNat_swsO,<1,2>> =
        case tup_swsS
        of <wild_X1P,<1,3>>
        { (<tpl_X1U,<1,3>>, <tpl_X1W,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B7
        };
      <$dResize_swsP,<1,2>>
      <$dResize_swsP,<1,2>> =
        case tup_swsS
        of <wild_X1N,<1,3>>
        { (<tpl_X1S,<1,3>>, <tpl_X1U,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B6
        };
      <$dBits_swsQ,<1,2>>
      <$dBits_swsQ,<1,2>> =
        case tup_swsS
        of <wild_X3x,<1,3>>
        { (<tpl_X1Q,<1,3>>, <tpl_X1S,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B5
        };
      <$dBounded_swsR,<1,2>>
      <$dBounded_swsR,<1,2>> =
        case tup_swsS
        of <wild_X1D,<1,3>>
        { (<tpl_X1O,<1,3>>, <tpl_X1Q,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_X1O
        };
      <tup_swsS,<1,2>>
      <tup_swsS,<1,2>> =
        case tup_avDN
        of <wild_X1B,<1,3>>
        { (<tpl_X1M,<1,3>>, <tpl_X1O,<1,3>>, <tpl_B3,<1,3>>) ->
        tpl_X1O
        }; } in
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN
        of <wild_X2h,<1,3>>
        { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>) ->
        tpl_B3
        })
       ((CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tup_swsL
            of <wild_X23,<1,3>>
            { (<tpl_X45,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B3
            },
            case tup_swsL
            of <wild_X25,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X48,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsL
            of <wild_X2b,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsL
            of <wild_X2d,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_Bb
            },
            case tup_swsL
            of <wild_X2f,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of <wild_X1F,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B3
            },
            case tup_swsS
            of <wild_X1H,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of <wild_X1R,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of <wild_X1X,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_Bb
            },
            case tup_swsS
            of <wild_X1Z,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
<CLaSH.Sized.Fixed.$fAddFixedFixed,<0,0>>
<CLaSH.Sized.Fixed.$fAddFixedFixed,<0,0>> =
  \ <frac1_auHd,<1,0>>
    <rep_auHe,<1,0>>
    <size1_auHf,<1,0>>
    <frac2_auHg,<1,0>>
    <size2_auHh,<1,0>>
    <tup_avDN,<1,0>> ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
<$cfromInteger_avDp,<0,0>>
<$cfromInteger_avDp,<0,0>> =
  \ <frac_auGY,<1,0>>
    <rep_auGZ,<1,0>>
    <size_auH0,<1,0>>
    <tup_avBm,<1,0>>
    <eta_X1I,<1,0>> ->
    let {
      <tup_swsA,<1,1>>
      <tup_swsA,<1,1>> =
        case tup_avBm
        of <wild_X1B,<1,1>>
        { (<tpl_X1L,<1,1>>, <tpl_X1N,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>) ->
        tpl_X1N
        } } in
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       (case tup_swsA
        of <wild_X1F,<1,2>>
        { (<tpl_X1M,<1,2>>, <tpl_X1O,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B9
        })
       (GHC.Num.fromInteger
          @ (rep_auGZ size_auH0)
          (case tup_avBm
           of <wild_X1D,<1,2>>
           { (<tpl_X1M,<1,2>>, <tpl_X1O,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>) ->
           tpl_B3
           })
          eta_X1I)
       (GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac_auGY
             @ Data.Proxy.Proxy
             (case tup_swsA
              of <wild_X1H,<1,2>>
              { (<tpl_X1M,<1,2>>, <tpl_X1O,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_auGY))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
<a_swkh,<0,0>>
<a_swkh,<0,0>> =
  \ <frac_auGY,<1,0>>
    <rep_auGZ,<1,0>>
    <size_auH0,<1,0>>
    <tup_avBm,<1,0>>
    <eta_X1J,<1,0>> ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      (case tup_avBm
       of <wild_X1C,<1,1>>
       { (<tpl_X1L,<1,1>>, <tpl_X1N,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>) ->
       tpl_B3
       })
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
<$csignum_avDg,<0,0>>
<$csignum_avDg,<0,0>> =
  a_swkh
  `cast` (forall (frac_auGY :: GHC.TypeLits.Nat)
                 (rep_auGZ :: GHC.TypeLits.Nat -> *)
                 (size_auH0 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
          :: (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> rep_auGZ size_auH0)
               ~#
             (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0))
<$cabs_avCW,<0,0>>
<$cabs_avCW,<0,0>> =
  \ <frac_XuIJ,<1,0>>
    <rep_XuIL,<1,0>>
    <size_XuIN,<1,0>>
    <tup_XvDa,<1,0>>
    <eta_X1Q,<1,0>> ->
    letrec {
      <$dKnownNat_swsv,<1,1>>
      <$dKnownNat_swsv,<1,1>> =
        case tup_swsw
        of <wild_X1X,<1,2>>
        { (<tpl_X1Z,<1,2>>, <tpl_X21,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>) ->
        tpl_B8
        };
      <tup_swsw,<1,1>>
      <tup_swsw,<1,1>> =
        case tup_XvDa
        of <wild_X3E,<1,2>>
        { (<tpl_X1X,<1,2>>, <tpl_X1Z,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>) ->
        tpl_X1X
        }; } in
    letrec {
      <$dKnownNat_swsx,<1,2>>
      <$dKnownNat_swsx,<1,2>> =
        case tup_swsy
        of <wild_X1H,<1,3>>
        { (<tpl_X1V,<1,3>>, <tpl_X1X,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B7
        };
      <tup_swsy,<1,2>>
      <tup_swsy,<1,2>> =
        case tup_XvDa
        of <wild_X1D,<1,3>>
        { (<tpl_X1T,<1,3>>, <tpl_X1V,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
        tpl_X1V
        }; } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of <wild_X1L,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_X20
        },
        case tup_swsw
        of <wild_X1N,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_X22
        },
        case tup_swsw
        of <wild_X1P,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_B3
        },
        case tup_swsw
        of <wild_X1R,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_B4
        },
        case tup_swsw
        of <wild_X1T,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_B5
        },
        case tup_swsw
        of <wild_X1V,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of <wild_X1F,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_X20
        },
        case tup_swsw
        of <wild_X1Z,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_Ba
        })
       (GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          (case tup_XvDa
           of <wild_X23,<1,3>>
           { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIL
             (case tup_swsy
              of <wild_X21,<1,3>>
              { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
              tpl_B6
              })
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)
<$cnegate_avCC,<0,0>>
<$cnegate_avCC,<0,0>> =
  \ <frac_XuIK,<1,0>>
    <rep_XuIM,<1,0>>
    <size_XuIO,<1,0>>
    <tup_XvDb,<1,0>>
    <eta_X1R,<1,0>> ->
    letrec {
      <$dKnownNat_swsn,<1,1>>
      <$dKnownNat_swsn,<1,1>> =
        case tup_swso
        of <wild_X1Y,<1,2>>
        { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>) ->
        tpl_B8
        };
      <tup_swso,<1,1>>
      <tup_swso,<1,1>> =
        case tup_XvDb
        of <wild_X1K,<1,2>>
        { (<tpl_X1Y,<1,2>>, <tpl_X20,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>) ->
        tpl_X1Y
        }; } in
    letrec {
      <$dKnownNat_swsp,<1,2>>
      <$dKnownNat_swsp,<1,2>> =
        case tup_swsq
        of <wild_X1I,<1,3>>
        { (<tpl_X1W,<1,3>>, <tpl_X1Y,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B7
        };
      <tup_swsq,<1,2>>
      <tup_swsq,<1,2>> =
        case tup_XvDb
        of <wild_X1E,<1,3>>
        { (<tpl_X1U,<1,3>>, <tpl_X1W,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
        tpl_X1W
        }; } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of <wild_X1M,<1,3>>
        { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_X21
        },
        case tup_swso
        of <wild_X1O,<1,3>>
        { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_X23
        },
        case tup_swso
        of <wild_X1Q,<1,3>>
        { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_B3
        },
        case tup_swso
        of <wild_X1S,<1,3>>
        { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_B4
        },
        case tup_swso
        of <wild_X1U,<1,3>>
        { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_B5
        },
        case tup_swso
        of <wild_X1W,<1,3>>
        { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of <wild_X1G,<1,3>>
        { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_X21
        },
        case tup_swso
        of <wild_X20,<1,3>>
        { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>) ->
        tpl_Ba
        })
       (GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          (case tup_XvDb
           of <wild_X24,<1,3>>
           { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIM
             (case tup_swsq
              of <wild_X22,<1,3>>
              { (<tpl_X21,<1,3>>, <tpl_X23,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
              tpl_B6
              })
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)
<$c-_avCb,<0,0>>
<$c-_avCb,<0,0>> =
  \ <frac_XuIL,<1,0>>
    <rep_XuIN,<1,0>>
    <size_XuIP,<1,0>>
    <tup_XvDc,<1,0>>
    <eta_X1T,<1,0>>
    <eta_X3L,<1,0>> ->
    letrec {
      <$dKnownNat_swse,<1,1>>
      <$dKnownNat_swse,<1,1>> =
        case tup_swsf
        of <wild_X21,<1,2>>
        { (<tpl_X24,<1,2>>, <tpl_X26,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>) ->
        tpl_B8
        };
      <tup_swsf,<1,1>>
      <tup_swsf,<1,1>> =
        case tup_XvDc
        of <wild_X1N,<1,2>>
        { (<tpl_X22,<1,2>>, <tpl_X24,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>) ->
        tpl_X22
        }; } in
    letrec {
      <$dKnownNat_swsg,<1,2>>
      <$dKnownNat_swsg,<1,2>> =
        case tup_swsi
        of <wild_X1L,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B7
        };
      <tup_swsi,<1,2>>
      <tup_swsi,<1,2>> =
        case tup_XvDc
        of <wild_X1F,<1,3>>
        { (<tpl_X1W,<1,3>>, <tpl_X1Y,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
        tpl_X1Y
        }; } in
    let {
      <$dResize_swsh,<1,3>>
      <$dResize_swsh,<1,3>> =
        case tup_swsi
        of <wild_X3F,<1,3>>
        { (<tpl_X1Y,<1,3>>, <tpl_X20,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B6
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of <wild_X1P,<1,4>>
        { (<tpl_X25,<1,4>>, <tpl_X27,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_X25
        },
        case tup_swsf
        of <wild_X1R,<1,4>>
        { (<tpl_X25,<1,4>>, <tpl_X27,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_X27
        },
        case tup_swsf
        of <wild_X3W,<1,4>>
        { (<tpl_X25,<1,4>>, <tpl_X27,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B3
        },
        case tup_swsf
        of <wild_X1V,<1,4>>
        { (<tpl_X25,<1,4>>, <tpl_X27,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B4
        },
        case tup_swsf
        of <wild_X1X,<1,4>>
        { (<tpl_X25,<1,4>>, <tpl_X27,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B5
        },
        case tup_swsf
        of <wild_X1Z,<1,4>>
        { (<tpl_X25,<1,4>>, <tpl_X27,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of <wild_X1H,<1,4>>
        { (<tpl_X25,<1,4>>, <tpl_X27,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>, <tpl_Bb,<1,4>>, <tpl_Bc,<1,4>>) ->
        tpl_X25
        },
        case tup_swsf
        of <wild_X23,<1,4>>
        { (<tpl_X25,<1,4>>, <tpl_X27,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_Ba
        })
       (GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          (case tup_XvDc
           of <wild_X25,<1,4>>
           { (<tpl_X49,<1,4>>, <tpl_X27,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_swsh
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_swsh
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
<$c*_avBP,<0,0>>
<$c*_avBP,<0,0>> =
  \ <frac_XuIM,<1,0>>
    <rep_XuIO,<1,0>>
    <size_XuIQ,<1,0>>
    <tup_XvDd,<1,0>>
    <eta_X1U,<1,0>>
    <eta_X3N,<1,0>> ->
    letrec {
      <$dBits_sws7,<1,1>>
      <$dBits_sws7,<1,1>> =
        case tup_sws8
        of <wild_X1O,<1,2>>
        { (<tpl_X1Z,<1,2>>, <tpl_X21,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B5
        };
      <tup_sws8,<1,1>>
      <tup_sws8,<1,1>> =
        case tup_XvDd
        of <wild_X1G,<1,2>>
        { (<tpl_X1X,<1,2>>, <tpl_X1Z,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>) ->
        tpl_X1Z
        }; } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of <wild_X1I,<1,2>>
       { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of <wild_X1K,<1,2>>
       { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_B3
       },
       case tup_sws8
       of <wild_X1M,<1,2>>
       { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of <wild_X1S,<1,2>>
       { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_B6
       },
       case tup_sws8
       of <wild_X3S,<1,2>>
       { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_B7
       },
       case tup_sws8
       of <wild_X1W,<1,2>>
       { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_B8
       },
       case tup_sws8
       of <wild_X1Y,<1,2>>
       { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_B9
       },
       case tup_sws8
       of <wild_X20,<1,2>>
       { (<tpl_X3Z,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_Ba
       },
       case tup_sws8
       of <wild_X22,<1,2>>
       { (<tpl_X20,<1,2>>, <tpl_X42,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_Bb
       },
       case tup_sws8
       of <wild_X24,<1,2>>
       { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
       tpl_Bc
       })
      ((case case tup_XvDd
             of <wild_X26,<1,2>>
             { (<tpl_Xk,<1,2>>, <tpl_Xm,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>) ->
             tpl_B6
             }
        of <cobox_XvCT,<1,2>> { GHC.Types.Eq# <cobox_dw1a,<1,2>> ->
        (CLaSH.Class.Num.mult
           @ (rep_XuIO size_XuIQ)
           @ (rep_XuIO size_XuIQ)
           (case tup_XvDd
            of <wild_X27,<1,3>>
            { (<tpl_X23,<1,3>>, <tpl_X25,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
            tpl_B5
            })
           (eta_X1U
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ))
           (eta_X3N
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ)))
        `cast` (Sub cobox_dw1a
                :: CLaSH.Class.Num.MResult
                     (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                     ~#
                   rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
        })
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                          GHC.TypeLits.+ size_XuIQ>_N
               :: rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ)))
<$c+_avBo,<0,0>>
<$c+_avBo,<0,0>> =
  \ <frac_XuIN,<1,0>>
    <rep_XuIP,<1,0>>
    <size_XuIR,<1,0>>
    <tup_XvDe,<1,0>>
    <eta_X1V,<1,0>>
    <eta_X3P,<1,0>> ->
    letrec {
      <$dKnownNat_sws0,<1,1>>
      <$dKnownNat_sws0,<1,1>> =
        case tup_sws1
        of <wild_X23,<1,2>>
        { (<tpl_X26,<1,2>>, <tpl_X28,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>) ->
        tpl_B8
        };
      <tup_sws1,<1,1>>
      <tup_sws1,<1,1>> =
        case tup_XvDe
        of <wild_X1P,<1,2>>
        { (<tpl_X24,<1,2>>, <tpl_X26,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>) ->
        tpl_X24
        }; } in
    letrec {
      <$dKnownNat_sws2,<1,2>>
      <$dKnownNat_sws2,<1,2>> =
        case tup_sws4
        of <wild_X1N,<1,3>>
        { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B7
        };
      <tup_sws4,<1,2>>
      <tup_sws4,<1,2>> =
        case tup_XvDe
        of <wild_X1H,<1,3>>
        { (<tpl_X1Y,<1,3>>, <tpl_X20,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
        tpl_X20
        }; } in
    let {
      <$dResize_sws3,<1,3>>
      <$dResize_sws3,<1,3>> =
        case tup_sws4
        of <wild_X1L,<1,3>>
        { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B6
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of <wild_X1R,<1,4>>
        { (<tpl_X27,<1,4>>, <tpl_X29,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_X27
        },
        case tup_sws1
        of <wild_X1T,<1,4>>
        { (<tpl_X27,<1,4>>, <tpl_X29,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_X29
        },
        case tup_sws1
        of <wild_X40,<1,4>>
        { (<tpl_X27,<1,4>>, <tpl_X29,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B3
        },
        case tup_sws1
        of <wild_X1X,<1,4>>
        { (<tpl_X27,<1,4>>, <tpl_X29,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B4
        },
        case tup_sws1
        of <wild_X1Z,<1,4>>
        { (<tpl_X27,<1,4>>, <tpl_X29,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B5
        },
        case tup_sws1
        of <wild_X21,<1,4>>
        { (<tpl_X27,<1,4>>, <tpl_X29,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of <wild_X3O,<1,4>>
        { (<tpl_X27,<1,4>>, <tpl_X29,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>, <tpl_Bb,<1,4>>, <tpl_Bc,<1,4>>) ->
        tpl_X27
        },
        case tup_sws1
        of <wild_X25,<1,4>>
        { (<tpl_X27,<1,4>>, <tpl_X29,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_Ba
        })
       (GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          (case tup_XvDe
           of <wild_X27,<1,4>>
           { (<tpl_X4d,<1,4>>, <tpl_X29,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_sws3
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_sws3
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
<CLaSH.Sized.Fixed.$fNumFixed,<0,0>>
<CLaSH.Sized.Fixed.$fNumFixed,<0,0>> =
  \ <frac_XuIO,<1,0>>
    <rep_XuIQ,<1,0>>
    <size_XuIS,<1,0>>
    <tup_XvDf,<1,0>> ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($csignum_avDg @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
<a_swhq,<0,0>>
<a_swhq,<0,0>> =
  \ <frac_auGT,<1,0>>
    <rep_auGU,<1,0>>
    <size_auGV,<1,0>>
    <$dBitVector_avAW,<1,0>>
    <$dKnownNat_avBa,<1,0>>
    <bv_auGX,<1,0>> ->
    CLaSH.Class.BitVector.fromBV
      @ (rep_auGU size_auGV)
      $dBitVector_avAW
      ($dKnownNat_avBa
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))))
      (bv_auGX
       `cast` ((CLaSH.Sized.Vector.Vec
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N)
                  <CLaSH.Bit.Bit>_R)_R
               :: CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    CLaSH.Bit.Bit
                    ~#
                  CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))
                    CLaSH.Bit.Bit))
<$cfromBV_avB8,<0,0>>
<$cfromBV_avB8,<0,0>> =
  a_swhq
  `cast` (forall (frac_auGT :: GHC.TypeLits.Nat)
                 (rep_auGU :: GHC.TypeLits.Nat -> *)
                 (size_auGV :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))>_R
          -> <CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGT>_P <rep_auGU>_R) <size_auGV>_N
          :: (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> rep_auGU size_auGV)
               ~#
             (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
<a_swhr,<0,0>>
<a_swhr,<0,0>> =
  \ <frac_XuIF,<1,0>>
    <rep_XuIH,<1,0>>
    <size_XuIJ,<1,0>>
    <$dBitVector_XvCL,<1,0>>
    <$dKnownNat_avB0,<1,0>>
    <ds_dw0H,<1,0>> ->
    CLaSH.Class.BitVector.toBV
      @ (rep_XuIH size_XuIJ)
      $dBitVector_XvCL
      ($dKnownNat_avB0
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ))))
      (ds_dw0H
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIF>_P <rep_XuIH>_R <size_XuIJ>_N
               :: CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
                    ~#
                  rep_XuIH size_XuIJ))
<$ctoBV_avAY,<0,0>>
<$ctoBV_avAY,<0,0>> =
  a_swhr
  `cast` (forall (frac_XuIF :: GHC.TypeLits.Nat)
                 (rep_XuIH :: GHC.TypeLits.Nat -> *)
                 (size_XuIJ :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ>_R
          -> (CLaSH.Sized.Vector.Vec
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                      <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))
                <CLaSH.Bit.Bit>_R)_R
          :: (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ)) CLaSH.Bit.Bit)
               ~#
             (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                   CLaSH.Bit.Bit))
<CLaSH.Sized.Fixed.$fBitVectorFixed,<0,0>>
<CLaSH.Sized.Fixed.$fBitVectorFixed,<0,0>> =
  \ <frac_XuIN,<1,0>>
    <rep_XuIP,<1,0>>
    <size_XuIR,<1,0>>
    <$dBitVector_XvCT,<1,0>> ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ($ctoBV_avAY @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)
      ($cfromBV_avB8 @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)
<a_swhs,<0,0>>
<a_swhs,<0,0>> =
  \ <frac_auGL,<1,0>>
    <rep_auGM,<1,0>>
    <size_auGN,<1,0>>
    <$dDefault_avAe,<1,0>> ->
    Data.Default.Class.def @ (rep_auGM size_auGN) $dDefault_avAe
<$cdef_avAg,<0,0>>
<$cdef_avAg,<0,0>> =
  a_swhs
  `cast` (forall (frac_auGL :: GHC.TypeLits.Nat)
                 (rep_auGM :: GHC.TypeLits.Nat -> *)
                 (size_auGN :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_auGM size_auGN)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGL>_P <rep_auGM>_R) <size_auGN>_N
          :: (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              rep_auGM size_auGN)
               ~#
             (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN))
<CLaSH.Sized.Fixed.$fDefaultFixed,<0,0>>
<CLaSH.Sized.Fixed.$fDefaultFixed,<0,0>> =
  $cdef_avAg
  `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                 (rep_XuIO :: GHC.TypeLits.Nat -> *)
                 (size_XuIQ :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
          -> Sym
               (Data.Default.Class.NTCo:Default[0]
                  <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
          :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
               ~#
             (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))
<a_swht,<0,0>>
<a_swht,<0,0>> =
  \ <frac_auGI,<1,0>>
    <rep_auGJ,<1,0>>
    <size_auGK,<1,0>>
    <$dBounded_avzT,<1,0>> ->
    GHC.Enum.maxBound @ (rep_auGJ size_auGK) $dBounded_avzT
<$cmaxBound_avA4,<0,0>>
<$cmaxBound_avA4,<0,0>> =
  a_swht
  `cast` (forall (frac_auGI :: GHC.TypeLits.Nat)
                 (rep_auGJ :: GHC.TypeLits.Nat -> *)
                 (size_auGK :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_auGJ size_auGK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGI>_P <rep_auGJ>_R) <size_auGK>_N
          :: (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              rep_auGJ size_auGK)
               ~#
             (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK))
<a_swhu,<0,0>>
<a_swhu,<0,0>> =
  \ <frac_XuIQ,<1,0>>
    <rep_XuIS,<1,0>>
    <size_XuIU,<1,0>>
    <$dBounded_XvC4,<1,0>> ->
    GHC.Enum.minBound @ (rep_XuIS size_XuIU) $dBounded_XvC4
<$cminBound_avzV,<0,0>>
<$cminBound_avzV,<0,0>> =
  a_swhu
  `cast` (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                 (rep_XuIS :: GHC.TypeLits.Nat -> *)
                 (size_XuIU :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_XuIS size_XuIU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIQ>_P <rep_XuIS>_R) <size_XuIU>_N
          :: (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              rep_XuIS size_XuIU)
               ~#
             (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIQ rep_XuIS size_XuIU))
<CLaSH.Sized.Fixed.$fBoundedFixed,<0,0>>
<CLaSH.Sized.Fixed.$fBoundedFixed,<0,0>> =
  \ <frac_XuIW,<1,0>>
    <rep_XuIY,<1,0>>
    <size_XuJ0,<1,0>>
    <$dBounded_XvCa,<1,0>> ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ($cminBound_avzV @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)
      ($cmaxBound_avA4 @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)
<a_swlr,<0,0>>
<a_swlr,<0,0>> =
  \ <frac_auFF,<1,0>>
    <rep_auFG,<1,0>>
    <size_auFH,<1,0>>
    <$dEq_avya,<1,0>>
    <$dOrd_avyb,<1,0>> ->
    GHC.Classes.min @ (rep_auFG size_auFH) $dOrd_avyb
<$cmin_avzC,<0,0>>
<$cmin_avzC,<0,0>> =
  a_swlr
  `cast` (forall (frac_auFF :: GHC.TypeLits.Nat)
                 (rep_auFG :: GHC.TypeLits.Nat -> *)
                 (size_auFH :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)>_R
          -> <GHC.Classes.Ord (rep_auFG size_auFH)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          :: (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH)
               ~#
             (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH))
<a_swls,<0,0>>
<a_swls,<0,0>> =
  \ <frac_XuHQ,<1,0>>
    <rep_XuHS,<1,0>>
    <size_XuHU,<1,0>>
    <$dEq_XvAo,<1,0>>
    <$dOrd_XvAq,<1,0>> ->
    GHC.Classes.max @ (rep_XuHS size_XuHU) $dOrd_XvAq
<$cmax_avzm,<0,0>>
<$cmax_avzm,<0,0>> =
  a_swls
  `cast` (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                 (rep_XuHS :: GHC.TypeLits.Nat -> *)
                 (size_XuHU :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU)>_R
          -> <GHC.Classes.Ord (rep_XuHS size_XuHU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          :: (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              rep_XuHS size_XuHU -> rep_XuHS size_XuHU -> rep_XuHS size_XuHU)
               ~#
             (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU))
<a_swhz,<0,0>>
<a_swhz,<0,0>> =
  \ <frac_XuHX,<1,0>>
    <rep_XuHZ,<1,0>>
    <size_XuI1,<1,0>>
    <$dEq_XvAv,<1,0>>
    <$dOrd_XvAx,<1,0>> ->
    GHC.Classes.<= @ (rep_XuHZ size_XuI1) $dOrd_XvAx
<$c<=_avz8,<0,0>>
<$c<=_avz8,<0,0>> =
  a_swhz
  `cast` (forall (frac_XuHY :: GHC.TypeLits.Nat)
                 (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                 (size_XuI2 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2)>_R
          -> <GHC.Classes.Ord (rep_XuI0 size_XuI2)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              rep_XuI0 size_XuI2 -> rep_XuI0 size_XuI2 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> GHC.Types.Bool))
<a_swhA,<0,0>>
<a_swhA,<0,0>> =
  \ <frac_XuI3,<1,0>>
    <rep_XuI5,<1,0>>
    <size_XuI7,<1,0>>
    <$dEq_XvAB,<1,0>>
    <$dOrd_XvAD,<1,0>> ->
    GHC.Classes.> @ (rep_XuI5 size_XuI7) $dOrd_XvAD
<$c>_avyU,<0,0>>
<$c>_avyU,<0,0>> =
  a_swhA
  `cast` (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                 (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                 (size_XuI7 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7)>_R
          -> <GHC.Classes.Ord (rep_XuI5 size_XuI7)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              rep_XuI5 size_XuI7 -> rep_XuI5 size_XuI7 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> GHC.Types.Bool))
<a_swhB,<0,0>>
<a_swhB,<0,0>> =
  \ <frac_XuIa,<1,0>>
    <rep_XuIc,<1,0>>
    <size_XuIe,<1,0>>
    <$dEq_XvAI,<1,0>>
    <$dOrd_XvAK,<1,0>> ->
    GHC.Classes.>= @ (rep_XuIc size_XuIe) $dOrd_XvAK
<$c>=_avyG,<0,0>>
<$c>=_avyG,<0,0>> =
  a_swhB
  `cast` (forall (frac_XuIa :: GHC.TypeLits.Nat)
                 (rep_XuIc :: GHC.TypeLits.Nat -> *)
                 (size_XuIe :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe)>_R
          -> <GHC.Classes.Ord (rep_XuIc size_XuIe)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              rep_XuIc size_XuIe -> rep_XuIc size_XuIe -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> GHC.Types.Bool))
<a_swhC,<0,0>>
<a_swhC,<0,0>> =
  \ <frac_XuIh,<1,0>>
    <rep_XuIj,<1,0>>
    <size_XuIl,<1,0>>
    <$dEq_XvAP,<1,0>>
    <$dOrd_XvAR,<1,0>> ->
    GHC.Classes.< @ (rep_XuIj size_XuIl) $dOrd_XvAR
<$c<_avys,<0,0>>
<$c<_avys,<0,0>> =
  a_swhC
  `cast` (forall (frac_XuIh :: GHC.TypeLits.Nat)
                 (rep_XuIj :: GHC.TypeLits.Nat -> *)
                 (size_XuIl :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl)>_R
          -> <GHC.Classes.Ord (rep_XuIj size_XuIl)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              rep_XuIj size_XuIl -> rep_XuIj size_XuIl -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> GHC.Types.Bool))
<a_swhD,<0,0>>
<a_swhD,<0,0>> =
  \ <frac_XuIo,<1,0>>
    <rep_XuIq,<1,0>>
    <size_XuIs,<1,0>>
    <$dEq_XvAW,<1,0>>
    <$dOrd_XvAY,<1,0>> ->
    GHC.Classes.compare @ (rep_XuIq size_XuIs) $dOrd_XvAY
<$ccompare_avye,<0,0>>
<$ccompare_avye,<0,0>> =
  a_swhD
  `cast` (forall (frac_XuIo :: GHC.TypeLits.Nat)
                 (rep_XuIq :: GHC.TypeLits.Nat -> *)
                 (size_XuIs :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs)>_R
          -> <GHC.Classes.Ord (rep_XuIq size_XuIs)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> <GHC.Types.Ordering>_R
          :: (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              rep_XuIq size_XuIs -> rep_XuIq size_XuIs -> GHC.Types.Ordering)
               ~#
             (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> GHC.Types.Ordering))
<CLaSH.Sized.Fixed.$fOrdFixed,<0,0>>
<CLaSH.Sized.Fixed.$fOrdFixed,<0,0>> =
  \ <frac_XuIv,<1,0>>
    <rep_XuIx,<1,0>>
    <size_XuIz,<1,0>>
    <$dEq_XvB3,<1,0>>
    <$dOrd_XvB5,<1,0>> ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ($ccompare_avye
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<_avys @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>=_avyG @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>_avyU @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<=_avz8 @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmax_avzm
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmin_avzC
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
<a_swhE,<0,0>>
<a_swhE,<0,0>> =
  \ <frac_XuIw,<1,0>>
    <rep_XuIy,<1,0>>
    <size_XuIA,<1,0>>
    <$dEq_avxF,<1,0>> ->
    GHC.Classes./= @ (rep_XuIy size_XuIA) $dEq_avxF
<$c/=_avxV,<0,0>>
<$c/=_avxV,<0,0>> =
  a_swhE
  `cast` (forall (frac_XuIw :: GHC.TypeLits.Nat)
                 (rep_XuIy :: GHC.TypeLits.Nat -> *)
                 (size_XuIA :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIy size_XuIA)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              rep_XuIy size_XuIA -> rep_XuIy size_XuIA -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> GHC.Types.Bool))
<a_swhF,<0,0>>
<a_swhF,<0,0>> =
  \ <frac_XuIC,<1,0>>
    <rep_XuIE,<1,0>>
    <size_XuIG,<1,0>>
    <$dEq_XvAF,<1,0>> ->
    GHC.Classes.== @ (rep_XuIE size_XuIG) $dEq_XvAF
<$c==_avxH,<0,0>>
<$c==_avxH,<0,0>> =
  a_swhF
  `cast` (forall (frac_XuIC :: GHC.TypeLits.Nat)
                 (rep_XuIE :: GHC.TypeLits.Nat -> *)
                 (size_XuIG :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIE size_XuIG)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              rep_XuIE size_XuIG -> rep_XuIE size_XuIG -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> GHC.Types.Bool))
<CLaSH.Sized.Fixed.$fEqFixed,<0,0>>
<CLaSH.Sized.Fixed.$fEqFixed,<0,0>> =
  \ <frac_XuII,<1,0>>
    <rep_XuIK,<1,0>>
    <size_XuIM,<1,0>>
    <$dEq_XvAL,<1,0>> ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ($c==_avxH @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)
      ($c/=_avxV @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)
<$clift_avAv,<0,0>>
<$clift_avAv,<0,0>> =
  \ <frac_auGO,<1,0>>
    <rep_auGP,<1,0>>
    <size_auGQ,<1,0>>
    <$dLift_avAq,<1,0>>
    <$dKnownNat_avAr,<1,0>>
    <$dKnownNat_avAs,<1,0>>
    <$dTypeable_avAt,<1,0>>
    <f_auGR,<1,0>> ->
    Language.Haskell.TH.Lib.sigE
      (Language.Haskell.TH.Lib.appE
         (let {
            <lvl_swwi,F<0,0>>
            <lvl_swwi,F<0,0>> =
              Language.Haskell.TH.Lib.conE
                (let {
                   <lvl_swwh,F<0,0>>
                   <lvl_swwh,F<0,0>> =
                     Language.Haskell.TH.Syntax.mkNameG_d
                       (let {
                          <lvl_swwc,F<0,0>>
                          <lvl_swwc,F<0,0>> =
                            GHC.Base.build
                              @ GHC.Types.Char
                              (let {
                                 <lvl_swwb,F<0,0>>
                                 <lvl_swwb,F<0,0>> =
                                   \ <b_a4Iy,<0,1>> ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b_a4Iy "clash-prelude-0.5"# } in
                               lvl_swwb) } in
                        lvl_swwc)
                       (let {
                          <lvl_swwe,F<0,0>>
                          <lvl_swwe,F<0,0>> =
                            GHC.Base.build
                              @ GHC.Types.Char
                              (let {
                                 <lvl_swwd,F<0,0>>
                                 <lvl_swwd,F<0,0>> =
                                   \ <b_a4Iy,<0,1>> ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b_a4Iy "CLaSH.Sized.Fixed"# } in
                               lvl_swwd) } in
                        lvl_swwe)
                       (let {
                          <lvl_swwg,F<0,0>>
                          <lvl_swwg,F<0,0>> =
                            GHC.Base.build
                              @ GHC.Types.Char
                              (let {
                                 <lvl_swwf,F<0,0>>
                                 <lvl_swwf,F<0,0>> =
                                   \ <b_a4Iy,<0,1>> ->
                                     GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"# } in
                               lvl_swwf) } in
                        lvl_swwg) } in
                 lvl_swwh) } in
          lvl_swwi)
         (Language.Haskell.TH.Syntax.lift
            @ (rep_auGP size_auGQ)
            $dLift_avAq
            (f_auGR
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                          ~#
                        rep_auGP size_auGQ))))
      (GHC.List.foldl
         @ Language.Haskell.TH.Lib.TypeQ
         @ Language.Haskell.TH.Lib.TypeQ
         Language.Haskell.TH.Lib.appT
         (let {
            <lvl_swwq,F<0,0>>
            <lvl_swwq,F<0,0>> =
              Language.Haskell.TH.Lib.conT
                (let {
                   <lvl_swwp,F<0,0>>
                   <lvl_swwp,F<0,0>> =
                     Language.Haskell.TH.Syntax.mkNameG_tc
                       (let {
                          <lvl_swwk,F<0,0>>
                          <lvl_swwk,F<0,0>> =
                            GHC.Base.build
                              @ GHC.Types.Char
                              (let {
                                 <lvl_swwj,F<0,0>>
                                 <lvl_swwj,F<0,0>> =
                                   \ <b_a4Iy,<0,1>> ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b_a4Iy "clash-prelude-0.5"# } in
                               lvl_swwj) } in
                        lvl_swwk)
                       (let {
                          <lvl_swwm,F<0,0>>
                          <lvl_swwm,F<0,0>> =
                            GHC.Base.build
                              @ GHC.Types.Char
                              (let {
                                 <lvl_swwl,F<0,0>>
                                 <lvl_swwl,F<0,0>> =
                                   \ <b_a4Iy,<0,1>> ->
                                     GHC.CString.unpackFoldrCString#
                                       @ b_a4Iy "CLaSH.Sized.Fixed"# } in
                               lvl_swwl) } in
                        lvl_swwm)
                       (let {
                          <lvl_swwo,F<0,0>>
                          <lvl_swwo,F<0,0>> =
                            GHC.Base.build
                              @ GHC.Types.Char
                              (let {
                                 <lvl_swwn,F<0,0>>
                                 <lvl_swwn,F<0,0>> =
                                   \ <b_a4Iy,<0,1>> ->
                                     GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"# } in
                               lvl_swwn) } in
                        lvl_swwo) } in
                 lvl_swwp) } in
          lvl_swwq)
         (GHC.Base.build
            @ Language.Haskell.TH.Lib.TypeQ
            (\ <a_dvZ6,<1,1>> <c_dvZ7,<1,1>> <n_dvZ8,<1,1>> ->
               c_dvZ7
                 (Language.Haskell.TH.Lib.litT
                    (Language.Haskell.TH.Lib.numTyLit
                       (GHC.TypeLits.natVal
                          @ frac_auGO
                          @ Data.Proxy.Proxy
                          $dKnownNat_avAr
                          (CLaSH.Sized.Fixed.asFracProxy
                             @ frac_auGO @ rep_auGP @ size_auGQ f_auGR))))
                 (c_dvZ7
                    (Language.Haskell.TH.Lib.conT
                       (Language.Haskell.TH.Syntax.mkName
                          (Data.Typeable.Internal.$fShowTypeRep_$cshow
                             (Data.Typeable.Internal.typeRep
                                @ (GHC.TypeLits.Nat -> *)
                                @ Data.Proxy.Proxy
                                @ rep_auGP
                                $dTypeable_avAt
                                (CLaSH.Sized.Fixed.asRepProxy
                                   @ frac_auGO @ rep_auGP @ size_auGQ f_auGR)))))
                    (c_dvZ7
                       (Language.Haskell.TH.Lib.litT
                          (Language.Haskell.TH.Lib.numTyLit
                             (GHC.TypeLits.natVal
                                @ size_auGQ
                                @ (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP)
                                $dKnownNat_avAs
                                f_auGR)))
                       n_dvZ8)))))
<CLaSH.Sized.Fixed.$fLiftFixed,<0,0>>
<CLaSH.Sized.Fixed.$fLiftFixed,<0,0>> =
  $clift_avAv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                  <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)))



==================== Float out(FOS {Lam = Just 0, Consts = True, PAPs = False}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              PAPs = False})
  = {terms: 2,164, types: 11,689, coercions: 844}

Rec {
$dReal_swuD :: GHC.Real.Real GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dReal_swuD =
  GHC.Real.$p1Integral
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

$dNum1_swuE :: GHC.Num.Num GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dNum1_swuE =
  GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal_swuD

$dOrd_swuF :: GHC.Classes.Ord GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dOrd_swuF =
  GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal_swuD

$dReal1_swuL :: GHC.Real.Real GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dReal1_swuL =
  GHC.Real.$p1Integral
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

a1_swuM :: GHC.Classes.Ord GHC.Integer.Type.Integer
[LclId, Str=DmdType]
a1_swuM = GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal1_swuL

$dEq_swuN [Occ=OnceL] :: GHC.Classes.Eq GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dEq_swuN = GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer a1_swuM

$dNum2_swuO :: GHC.Num.Num GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dNum2_swuO =
  GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal1_swuL

$dReal2_swuT :: GHC.Real.Real GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dReal2_swuT =
  GHC.Real.$p1Integral
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

a2_swuU :: GHC.Classes.Ord GHC.Integer.Type.Integer
[LclId, Str=DmdType]
a2_swuU = GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal2_swuT

$dEq1_swuV [Occ=OnceL] :: GHC.Classes.Eq GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dEq1_swuV = GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer a2_swuU

$dNum3_swuW :: GHC.Num.Num GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dNum3_swuW =
  GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal2_swuT

lvl_swv1 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv1 = __integer 1

lvl_swv2 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv2 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum3_swuW lvl_swv1

lvl_swv3 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv3 = __integer 2

lvl_swv4 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv4 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum3_swuW lvl_swv3

lvl_swuZ :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuZ = __integer 1

lvl_swv0 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv0 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum3_swuW lvl_swuZ

lvl_swv5 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv5 = __integer 2

lvl_swv6 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv6 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum3_swuW lvl_swv5

g1_swuY [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[LclId, Arity=3, Str=DmdType]
g1_swuY =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP [Occ=Once*] :: GHC.Types.Double) ->
    case GHC.Real.even
           @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger y1_akDO
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Classes.==
               @ GHC.Integer.Type.Integer $dEq1_swuV y1_akDO lvl_swv0
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Num.*
                 @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN x1_akDN)
              (GHC.Real.quot
                 @ GHC.Integer.Type.Integer
                 GHC.Real.$fIntegralInteger
                 (GHC.Num.- @ GHC.Integer.Type.Integer $dNum3_swuW y1_akDO lvl_swv2)
                 lvl_swv4)
              (GHC.Num.*
                 @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN z_akDP);
          GHC.Types.True ->
            GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN z_akDP
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Num.*
             @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN x1_akDN)
          (GHC.Real.quot
             @ GHC.Integer.Type.Integer
             GHC.Real.$fIntegralInteger
             y1_akDO
             lvl_swv6)
          z_akDP
    }

lvl_swv7 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv7 = __integer 1

lvl_swv8 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv8 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum2_swuO lvl_swv7

lvl_swv9 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv9 = __integer 2

lvl_swva :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swva =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum2_swuO lvl_swv9

lvl_swuR :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuR = __integer 1

lvl_swuS :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuS =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum2_swuO lvl_swuR

lvl_swvb :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvb = __integer 2

lvl_swvc :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvc =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum2_swuO lvl_swvb

f_swuQ [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId, Arity=2, Str=DmdType]
f_swuQ =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Real.even
           @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger y_akDB
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Classes.==
               @ GHC.Integer.Type.Integer $dEq_swuN y_akDB lvl_swuS
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x_akDA x_akDA)
              (GHC.Real.quot
                 @ GHC.Integer.Type.Integer
                 GHC.Real.$fIntegralInteger
                 (GHC.Num.- @ GHC.Integer.Type.Integer $dNum2_swuO y_akDB lvl_swv8)
                 lvl_swva)
              x_akDA;
          GHC.Types.True -> x_akDA
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x_akDA x_akDA)
          (GHC.Real.quot
             @ GHC.Integer.Type.Integer
             GHC.Real.$fIntegralInteger
             y_akDB
             lvl_swvc)
    }

lvl_swvd :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvd = __integer 1

lvl_swve :: GHC.Types.Double
[LclId, Str=DmdType]
lvl_swve =
  GHC.Num.fromInteger
    @ GHC.Types.Double GHC.Float.$fNumDouble lvl_swvd

lvl_swuI :: GHC.Classes.Eq GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuI = GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer $dOrd_swuF

lvl_swuJ :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuJ = __integer 0

lvl_swuK :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuK =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum1_swuE lvl_swuJ

lvl_swvf :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvf = GHC.CString.unpackCString# "Negative exponent"#

lvl_swvg :: GHC.Types.Double
[LclId, Str=DmdType b]
lvl_swvg = GHC.Err.error @ GHC.Types.Double lvl_swvf

lvl_swuG :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuG = __integer 0

lvl_swuH :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuH =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum1_swuE lvl_swuG

$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId, Arity=2, Str=DmdType]
$s^_swu6 =
  \ (eta_akDk [Occ=Once] :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Classes.<
           @ GHC.Integer.Type.Integer $dOrd_swuF eta1_akDl lvl_swuH
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Classes.==
               @ GHC.Integer.Type.Integer lvl_swuI eta1_akDl lvl_swuK
        of _ [Occ=Dead] {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        };
      GHC.Types.True -> lvl_swvg
    }
end Rec }

lvl_swvh :: GHC.Types.Double
[LclId, Str=DmdType]
lvl_swvh = GHC.Types.D# 2.0

lvl_swvi
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvi =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#

lvl_swvj :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvj = GHC.Base.build @ GHC.Types.Char lvl_swvi

lvl_swvk
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvk =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#

lvl_swvl :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvl = GHC.Base.build @ GHC.Types.Char lvl_swvk

lvl_swvm
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvm =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#

lvl_swvn :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvn = GHC.Base.build @ GHC.Types.Char lvl_swvm

lvl_swvo :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swvo =
  Language.Haskell.TH.Syntax.mkNameG_d lvl_swvj lvl_swvl lvl_swvn

lvl_swvp :: Language.Haskell.TH.Lib.ExpQ
[LclId, Str=DmdType]
lvl_swvp = Language.Haskell.TH.Lib.conE lvl_swvo

lvl_swvq
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvq =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "base"#

lvl_swvr :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvr = GHC.Base.build @ GHC.Types.Char lvl_swvq

lvl_swvs
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvs =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "GHC.Num"#

lvl_swvt :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvt = GHC.Base.build @ GHC.Types.Char lvl_swvs

lvl_swvu
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvu =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "fromInteger"#

lvl_swvv :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvv = GHC.Base.build @ GHC.Types.Char lvl_swvu

lvl_swvw :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swvw =
  Language.Haskell.TH.Syntax.mkNameG_v lvl_swvr lvl_swvt lvl_swvv

lvl_swvx :: Language.Haskell.TH.Lib.ExpQ
[LclId, Str=DmdType]
lvl_swvx = Language.Haskell.TH.Lib.varE lvl_swvw

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.fLit =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      truncated_swu2 :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      truncated_swu2 =
        GHC.Float.RealFracMethods.truncateDoubleInteger
          (GHC.Float.timesDouble
             a_auGC
             (GHC.Real.^
                @ GHC.Types.Double
                @ GHC.Integer.Type.Integer
                GHC.Float.$fNumDouble
                GHC.Real.$fIntegralInteger
                lvl_swvh
                (GHC.TypeLits.natVal
                   @ frac_avhM
                   @ Data.Proxy.Proxy
                   $dKnownNat_avlM
                   (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avhM)))) } in
    let {
      rMin_swu1 :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      rMin_swu1 =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    let {
      rMax_swu0 :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      rMax_swu0 =
        GHC.Real.toInteger
          @ (rep_avhN size_avhO)
          $dIntegral_avlP
          (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
    Language.Haskell.TH.Syntax.unsafeTExpCoerce
      @ (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)
      (Language.Haskell.TH.Lib.appE
         lvl_swvp
         (Language.Haskell.TH.Lib.appE
            lvl_swvx
            (Language.Haskell.TH.Syntax.lift
               @ GHC.Integer.Type.Integer
               Language.Haskell.TH.Syntax.$fLiftInteger
               (case GHC.Integer.Type.gtInteger truncated_swu2 rMax_swu0
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger truncated_swu2 rMin_swu1
                    of _ [Occ=Dead] {
                      GHC.Types.False -> truncated_swu2;
                      GHC.Types.True -> rMin_swu1
                    };
                  GHC.Types.True -> rMax_swu0
                }))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    let {
      cobox_swtW
        :: CLaSH.Class.BitVector.BitSize
             (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_swtW =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        } } in
    let {
      cobox_swtV
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId, Str=DmdType]
      cobox_swtV =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    let {
      cobox_swtU
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_swtU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      repBV_swtT =
        case case cobox_swtW of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
             GHC.Types.Eq#
               @ *
               @ (CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                    CLaSH.Bit.Bit)
               @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
               @~ (CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_N)_N
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6X ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of _ [Occ=Dead]
            { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
            tpl_B4
            })
           (case cobox_swtW of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Y ->
            (case tup_avmQ
             of _ [Occ=Dead]
             { (tpl_X1x, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
             tpl_B8
             })
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Y))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2))))
            })
           eta_B1)
        `cast` (Sub cobox_dw6X
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      s_swtS =
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (case case case cobox_swtU
                        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ (n_aviz GHC.TypeLits.+ 2)
                          @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                          @~ (Sym cobox_dw7d)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw75 ->
                   GHC.Types.Eq#
                     @ *
                     @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                     @ (CLaSH.Sized.Vector.Vec
                          ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                     @~ (CLaSH.Sized.Vector.Vec cobox_dw75 <CLaSH.Bit.Bit>_N)_N
                   }
              of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvY9 ->
              repBV_swtT
              `cast` (Sub cobox_dvY9
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
              })) } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of _ [Occ=Dead]
            { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
            tpl_Ba
            })
           eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          ds_swtR :: CLaSH.Bit.Bit
          [LclId, Str=DmdType]
          ds_swtR =
            CLaSH.Sized.Vector.vhead
              @ n_aviz
              @ CLaSH.Bit.Bit
              (CLaSH.Sized.Vector.vtail
                 @ (n_aviz GHC.TypeLits.+ 1)
                 @ CLaSH.Bit.Bit
                 (case case case cobox_swtU
                            of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7g ->
                            GHC.Types.Eq#
                              @ GHC.TypeLits.Nat
                              @ (n_aviz GHC.TypeLits.+ 2)
                              @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                              @~ (Sym cobox_dw7g)
                            }
                       of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw73 ->
                       GHC.Types.Eq#
                         @ *
                         @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                         @ (CLaSH.Sized.Vector.Vec
                              ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                         @~ (CLaSH.Sized.Vector.Vec cobox_dw73 <CLaSH.Bit.Bit>_N)_N
                       }
                  of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvYc ->
                  repBV_swtT
                  `cast` (Sub cobox_dvYc
                          :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                               ~#
                             CLaSH.Sized.Vector.Vec
                               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                  })) } in
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_swtU
                          of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw71 ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6W ->
                repBV_swtT
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case ds_swtR of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6T ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case ds_swtR of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6T ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        };
      GHC.Types.True ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_swtU
                          of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw71 ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6W ->
                repBV_swtT
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1p, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_X1p
                    })
                   s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6S ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1p, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_X1p
                    })
                   s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6S ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
    }

lvl_swvz :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvz = __integer 0

lvl_swvy :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvy = __integer 0

lvl_swvB :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvB = __integer 0

lvl_swvA :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvA = __integer 0

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_swtI =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat_swtH =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dResize_swtG :: CLaSH.Class.Num.Resize rep_avjs
      [LclId, Str=DmdType]
      $dResize_swtG =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dBits_swtF :: Data.Bits.Bits (rep_avjs size1_avjt)
      [LclId, Str=DmdType]
      $dBits_swtF =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1o, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dNum_swtE :: GHC.Num.Num (rep_avjs size1_avjt)
      [LclId, Str=DmdType]
      $dNum_swtE =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B4
        } } in
    let {
      $dBounded_swtD :: GHC.Enum.Bounded (rep_avjs size2_avju)
      [LclId, Str=DmdType]
      $dBounded_swtD =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1u
        } } in
    let {
      resFracSZ_swtC :: GHC.Types.Int
      [LclId, Str=DmdType]
      resFracSZ_swtC =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac2_avjr
             @ Data.Proxy.Proxy
             (case tup_avnK
              of _ [Occ=Dead]
              { (tpl_X1w, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac2_avjr)) } in
    let {
      argFracSZ_swtB :: GHC.Types.Int
      [LclId, Str=DmdType]
      argFracSZ_swtB =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac1_avjq
             @ Data.Proxy.Proxy
             (case tup_avnK
              of _ [Occ=Dead]
              { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Bb
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac1_avjq)) } in
    case GHC.Integer.Type.leInteger
           (GHC.TypeLits.natVal
              @ size1_avjt
              @ Data.Proxy.Proxy
              $dKnownNat_swtI
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size1_avjt))
           (GHC.TypeLits.natVal
              @ size2_avju
              @ Data.Proxy.Proxy
              $dKnownNat_swtH
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size2_avju))
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId, Str=DmdType]
          fMax_swtA =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId, Str=DmdType]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (CLaSH.Class.Num.resize
                 @ rep_avjs
                 $dResize_swtG
                 @ size2_avju
                 @ size1_avjt
                 $dKnownNat_swtH
                 $dKnownNat_swtI
                 fMax_swtA) } in
        case GHC.Classes.leInt argFracSZ_swtB resFracSZ_swtC
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- argFracSZ_swtB resFracSZ_swtC) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of _ [Occ=Dead]
                    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvy)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvz)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- resFracSZ_swtC argFracSZ_swtB) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of _ [Occ=Dead]
                    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvA)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvB)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        };
      GHC.Types.True ->
        case GHC.Classes.leInt argFracSZ_swtB resFracSZ_swtC
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of _ [Occ=Dead]
                { (tpl_X1h, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_swtG
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- argFracSZ_swtB resFracSZ_swtC))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of _ [Occ=Dead]
                { (tpl_X1h, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_swtG
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- resFracSZ_swtC argFracSZ_swtB))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 70 0}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    (f_auGd :: CLaSH.Sized.Fixed.Fixed frac_avjN rep_avjO size_avjP) ->
    GHC.Num.$fNumInt_$cfromInteger
      (GHC.TypeLits.natVal
         @ frac_avjN
         @ Data.Proxy.Proxy
         $dKnownNat_avxa
         (CLaSH.Sized.Fixed.asFracProxy
            @ frac_avjN @ rep_avjO @ size_avjP f_auGd))

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

lvl_swvD :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvD = GHC.Types.C# '-'

lvl_swvC :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvC = __integer 0

lvl_swvE :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvE = GHC.Types.C# '.'

lvl_swvF
  :: forall b_X4Kn.
     (GHC.Types.Char -> b_X4Kn -> b_X4Kn) -> b_X4Kn -> b_X4Kn
[LclId, Str=DmdType]
lvl_swvF =
  \ (@ b_X4Kn)
    (c_X4Kp [OS=OneShot] :: GHC.Types.Char -> b_X4Kn -> b_X4Kn)
    (n_X4Kr [OS=OneShot] :: b_X4Kn) ->
    c_X4Kp lvl_swvE n_X4Kr

lvl_swvG :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvG = GHC.Types.C# '0'

lvl_swvH :: GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvH =
  \ (n_auHJ [OS=ProbOneShot] :: GHC.Types.Int)
    (str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]) ->
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_X4M9)
         (c_X4Mc [OS=OneShot] :: GHC.Types.Char -> b_X4M9 -> b_X4M9)
         (n_X4Kt [OS=OneShot] :: b_X4M9) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_X4M9
           c_X4Mc
           n_X4Kt
           (GHC.List.replicate
              @ GHC.Types.Char
              (GHC.Num.$fNumInt_$c-
                 n_auHJ
                 (GHC.Base.foldr
                    @ GHC.Types.Char
                    @ (GHC.Prim.Int# -> GHC.Types.Int)
                    (GHC.List.incLen @ GHC.Types.Char)
                    GHC.Types.I#
                    str_auHK
                    0))
              lvl_swvG))
      str_auHK

lvl_swvI :: (GHC.Types.Int, [GHC.Types.Char]) -> [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvI =
  Data.Tuple.uncurry
    @ GHC.Types.Int @ [GHC.Types.Char] @ [GHC.Types.Char] lvl_swvH

lvl_swvJ
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvJ =
  GHC.Real.numerator
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

lvl_swvK
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Base.String
[LclId, Str=DmdType]
lvl_swvK =
  GHC.Base..
    @ GHC.Integer.Type.Integer
    @ GHC.Base.String
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    GHC.Show.$fShowInteger_$cshow
    lvl_swvJ

lvl_swvL
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, [GHC.Types.Char])
[LclId, Str=DmdType]
lvl_swvL =
  Control.Arrow.$fArrow(->)_$csecond
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ [GHC.Types.Char]
    @ GHC.Types.Int
    lvl_swvK

ds_swvM :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
ds_swvM = __integer 1

lvl_swvN :: GHC.Integer.Type.Integer -> GHC.Types.Bool
[LclId, Str=DmdType]
lvl_swvN =
  \ (ds_dw44 [OS=ProbOneShot] :: GHC.Integer.Type.Integer) ->
    GHC.Integer.Type.eqInteger ds_dw44 ds_swvM

lvl_swvO
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvO =
  GHC.Real.denominator
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

lvl_swvP
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvP =
  GHC.Base..
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ GHC.Integer.Type.Integer
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvO
    (Data.Tuple.snd
       @ GHC.Types.Int @ (GHC.Real.Ratio GHC.Integer.Type.Integer))

lvl_swvQ
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> GHC.Types.Bool
[LclId, Str=DmdType]
lvl_swvQ =
  GHC.Base..
    @ GHC.Integer.Type.Integer
    @ GHC.Types.Bool
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvN
    lvl_swvP

lvl_swvR
  :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
     -> Data.Maybe.Maybe
          (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_swvR =
  Data.List.find
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer) lvl_swvQ

lvl_swvS :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvS = __integer 10

ds_swvT :: GHC.Real.Ratio GHC.Integer.Type.Integer
[LclId, Str=DmdType]
ds_swvT = GHC.Real.$fNumRatio_$s$cfromInteger lvl_swvS

lvl_swvU
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvU =
  \ (ds_dw47 [OS=ProbOneShot]
       :: GHC.Real.Ratio GHC.Integer.Type.Integer) ->
    GHC.Real.$fNumRatio_$s$c* ds_dw47 ds_swvT

lvl_swvV
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_swvV =
  Control.Arrow.$fArrow(->)_$c***
    @ GHC.Types.Int
    @ GHC.Types.Int
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    GHC.Enum.$fEnumInt_$csucc
    lvl_swvU

lvl_swvW
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[LclId, Str=DmdType]
lvl_swvW =
  GHC.List.iterate
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer) lvl_swvV

lvl_swvX :: GHC.Types.Int
[LclId, Str=DmdType]
lvl_swvX = GHC.Types.I# 0

lvl_swvY
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_swvY =
  GHC.Tuple.(,)
    @ GHC.Types.Int
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvX

lvl_swvZ
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[LclId, Str=DmdType]
lvl_swvZ =
  GHC.Base..
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvW
    lvl_swvY

lvl_sww0
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> Data.Maybe.Maybe
          (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_sww0 =
  GHC.Base..
    @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
    @ (Data.Maybe.Maybe
         (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvR
    lvl_swvZ

lvl_sww1
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_sww1 =
  GHC.Base..
    @ (Data.Maybe.Maybe
         (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    (Data.Maybe.fromJust
       @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    lvl_sww0

lvl_sww2
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (GHC.Types.Int, [GHC.Types.Char])
[LclId, Str=DmdType]
lvl_sww2 =
  GHC.Base..
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ (GHC.Types.Int, [GHC.Types.Char])
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvL
    lvl_sww1

lvl_sww3
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_sww3 =
  GHC.Base..
    @ (GHC.Types.Int, [GHC.Types.Char])
    @ [GHC.Types.Char]
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvI
    lvl_sww2

lvl_sww5 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww5 = __integer 2

lvl_sww6 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww6 = __integer 1

lvl_sww7 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww7 = __integer 2

lvl_sww8 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww8 = __integer 1

lvl_sww4 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww4 = __integer 0

lvl_sww9 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww9 = __integer 2

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      nF_swti :: GHC.Types.Int
      [LclId, Str=DmdType]
      nF_swti =
        CLaSH.Sized.Fixed.fracShift
          @ frac_auHx @ rep_auHy @ size_auHz $dKnownNat_avFx f_auHA } in
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a4II)
         (c_a4IJ [OS=OneShot] :: GHC.Types.Char -> b_a4II -> b_a4II)
         (n_a4IK [OS=OneShot] :: b_a4II) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a4II
           c_a4IJ
           n_a4IK
           (case GHC.Integer.Type.ltInteger fRepI_swtk lvl_swvC
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Show.$fShowInteger_$cshow
                  (Data.Bits.$fBitsInteger_$cshiftR fRepI_swtk nF_swti);
              GHC.Types.True ->
                GHC.Types.:
                  @ GHC.Types.Char
                  lvl_swvD
                  (GHC.Show.$fShowInteger_$cshow
                     (Data.Bits.$fBitsInteger_$cshiftR fRepI_abs_swtj nF_swti))
            }))
      (GHC.Base.augment
         @ GHC.Types.Char
         lvl_swvF
         (GHC.Base.$
            @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
            @ [GHC.Types.Char]
            lvl_sww3
            (GHC.Real.%_$s%
               (case GHC.Integer.Type.ltInteger fRepI_swtk lvl_sww4
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    GHC.Integer.Type.andInteger
                      fRepI_swtk
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            lvl_sww5
                            nF_swti)
                         lvl_sww6);
                  GHC.Types.True ->
                    GHC.Integer.Type.andInteger
                      fRepI_abs_swtj
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            lvl_sww7
                            nF_swti)
                         lvl_sww8)
                })
               (GHC.Real.^
                  @ GHC.Integer.Type.Integer
                  @ GHC.Types.Int
                  GHC.Num.$fNumInteger
                  GHC.Real.$fIntegralInt
                  lvl_sww9
                  nF_swti))))

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 120 40}]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a2g3)
         (c_a2g4 [OS=OneShot] :: GHC.Types.Char -> b_a2g3 -> b_a2g3)
         (n_a2g5 [OS=OneShot] :: b_a2g3) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a2g3
           c_a2g4
           n_a2g5
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY))
      s_a2fZ

Rec {
CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

$cshowList_avIE [Occ=LoopBreaker]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId,
 Arity=4,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0] 140 60}]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    let {
      $dShow_swtc
        :: GHC.Show.Show
             (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      [LclId, Str=DmdType]
      $dShow_swtc =
        CLaSH.Sized.Fixed.$fShowFixed
          @ frac_auHx
          @ rep_auHy
          @ size_auHz
          $dShow_avFv
          $dBits_avFw
          $dKnownNat_avFx
          $dIntegral_avFy } in
    let {
      lvl_swwa
        :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
           -> GHC.Show.ShowS
      [LclId, Str=DmdType]
      lvl_swwa =
        GHC.Show.shows
          @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
          $dShow_swtc } in
    \ (ls_a2fk
         :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
      (s_a2fl :: GHC.Base.String) ->
      GHC.Show.showList__
        @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
        lvl_swwa
        ls_a2fk
        s_a2fl
end Rec }

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 70 0}]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl_X1B) ->
         tpl_X1B
         }
    of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
    (CLaSH.Class.Num.mult
       @ (rep_auHr size1_auHs)
       @ (rep_auHr size2_auHu)
       (case tup_avFg of _ [Occ=Dead] { (tpl_X1C, tpl_X1E) -> tpl_X1C })
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  $cmult_avFi
  `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                 (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                 (size1_XuJ3 :: GHC.TypeLits.Nat)
                 (frac2_XuJ5 :: GHC.TypeLits.Nat)
                 (size2_XuJ7 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
          -> Sym
               (CLaSH.Class.Num.NTCo:Mult[0]
                  <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                  <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
          :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
              -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                   (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
               ~#
             (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 450 0}]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    letrec {
      $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dBits_swt2 =
        case tup_swt3
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      tup_swt3
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swt3 =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1Z, tpl_X21, tpl_B3) ->
        tpl_X1Z
        }; } in
    letrec {
      $dKnownNat_swt4
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swt4 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        };
      $dBits_swt5
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swt5 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        };
      $dKnownNat_swt6
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_swt6 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swt7 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        };
      $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_swt8 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      $dBounded_swt9
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swt9 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1N
        };
      tup_swta
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swta =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1L, tpl_X1N, tpl_B3) ->
        tpl_X1N
        }; } in
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl_X24, tpl_B3) ->
        tpl_B3
        })
       ((CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X43, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X46, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swt3
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 450 0}]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    letrec {
      $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
      [LclId, Str=DmdType]
      $dBits_swsK =
        case tup_swsL
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      tup_swsL
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac1_auHd
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size1_auHf
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swsL =
        case tup_avDN of _ [Occ=Dead] { (tpl_X20, tpl_X22, tpl_B3) ->
        tpl_X20
        }; } in
    letrec {
      $dKnownNat_swsM
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swsM =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        };
      $dBits_swsN
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swsN =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        };
      $dKnownNat_swsO
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_swsO =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swsP =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        };
      $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_swsQ =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      $dBounded_swsR
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swsR =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1O
        };
      tup_swsS
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swsS =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1M, tpl_X1O, tpl_B3) ->
        tpl_X1O
        }; } in
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl_X25, tpl_B3) ->
        tpl_B3
        })
       ((CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X45, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X48, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsL
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0] 170 0}]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    let {
      tup_swsA
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auGZ
             (frac_auGY GHC.TypeLits.+ frac_auGY)
             frac_auGY
             (size_auH0 GHC.TypeLits.+ size_auH0)
             size_auH0
      [LclId, Str=DmdType]
      tup_swsA =
        case tup_avBm
        of _ [Occ=Dead]
        { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1N
        } } in
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       (case tup_swsA
        of _ [Occ=Dead]
        { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        })
       (GHC.Num.fromInteger
          @ (rep_auGZ size_auH0)
          (case tup_avBm
           of _ [Occ=Dead]
           { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B3
           })
          eta_X1I)
       (GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac_auGY
             @ Data.Proxy.Proxy
             (case tup_swsA
              of _ [Occ=Dead]
              { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_auGY))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      (case tup_avBm
       of _ [Occ=Dead]
       { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       tpl_B3
       })
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))

$csignum_avDg
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$csignum_avDg =
  a_swkh
  `cast` (forall (frac_auGY :: GHC.TypeLits.Nat)
                 (rep_auGZ :: GHC.TypeLits.Nat -> *)
                 (size_auH0 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
          :: (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> rep_auGZ size_auH0)
               ~#
             (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0))

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 300 0}]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    letrec {
      $dKnownNat_swsv
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsv =
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        };
      tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId, Str=DmdType]
      tup_swsw =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1X
        }; } in
    letrec {
      $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
      [LclId, Str=DmdType]
      $dKnownNat_swsx =
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      tup_swsy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId, Str=DmdType]
      tup_swsy =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1V
        }; } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          (case tup_XvDa
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIL
             (case tup_swsy
              of _ [Occ=Dead]
              { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B6
              })
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 300 0}]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    letrec {
      $dKnownNat_swsn
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsn =
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        };
      tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId, Str=DmdType]
      tup_swso =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        }; } in
    letrec {
      $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
      [LclId, Str=DmdType]
      $dKnownNat_swsp =
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      tup_swsq
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId, Str=DmdType]
      tup_swsq =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1W
        }; } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          (case tup_XvDb
           of _ [Occ=Dead]
           { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIM
             (case tup_swsq
              of _ [Occ=Dead]
              { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B6
              })
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 370 0}]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    letrec {
      $dKnownNat_swse
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swse =
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        };
      tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId, Str=DmdType]
      tup_swsf =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X22
        }; } in
    letrec {
      $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
      [LclId, Str=DmdType]
      $dKnownNat_swsg =
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      tup_swsi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId, Str=DmdType]
      tup_swsi =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        }; } in
    let {
      $dResize_swsh :: CLaSH.Class.Num.Resize rep_XuIN
      [LclId, Str=DmdType]
      $dResize_swsh =
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          (case tup_XvDc
           of _ [Occ=Dead]
           { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_swsh
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_swsh
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 270 0}]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    letrec {
      $dBits_sws7
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      $dBits_sws7 =
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        };
      tup_sws8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId, Str=DmdType]
      tup_sws8 =
        case tup_XvDd
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Z
        }; } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B3
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B6
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B7
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B8
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B9
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Ba
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bb
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bc
       })
      ((case case tup_XvDd
             of _ [Occ=Dead]
             { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
             tpl_B6
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
        (CLaSH.Class.Num.mult
           @ (rep_XuIO size_XuIQ)
           @ (rep_XuIO size_XuIQ)
           (case tup_XvDd
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
            tpl_B5
            })
           (eta_X1U
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ))
           (eta_X3N
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ)))
        `cast` (Sub cobox_dw1a
                :: CLaSH.Class.Num.MResult
                     (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                     ~#
                   rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
        })
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                          GHC.TypeLits.+ size_XuIQ>_N
               :: rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ)))

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 370 0}]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    letrec {
      $dKnownNat_sws0
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_sws0 =
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        };
      tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      tup_sws1 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X24
        }; } in
    letrec {
      $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
      [LclId, Str=DmdType]
      $dKnownNat_sws2 =
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        };
      tup_sws4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId, Str=DmdType]
      tup_sws4 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X20
        }; } in
    let {
      $dResize_sws3 :: CLaSH.Class.Num.Resize rep_XuIP
      [LclId, Str=DmdType]
      $dResize_sws3 =
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          (case tup_XvDe
           of _ [Occ=Dead]
           { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_sws3
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_sws3
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $csignum_avDg @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($csignum_avDg @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

a_swhq
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Vector.Vec
       (CLaSH.Class.BitVector.BitSize
          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
       CLaSH.Bit.Bit
     -> rep_auGU size_auGV
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhq =
  \ (@ (frac_auGT :: GHC.TypeLits.Nat))
    (@ (rep_auGU :: GHC.TypeLits.Nat -> *))
    (@ (size_auGV :: GHC.TypeLits.Nat))
    ($dBitVector_avAW
       :: CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV))
    ($dKnownNat_avBa
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)))
    (bv_auGX
       :: CLaSH.Sized.Vector.Vec
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
            CLaSH.Bit.Bit) ->
    CLaSH.Class.BitVector.fromBV
      @ (rep_auGU size_auGV)
      $dBitVector_avAW
      ($dKnownNat_avBa
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))))
      (bv_auGX
       `cast` ((CLaSH.Sized.Vector.Vec
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N)
                  <CLaSH.Bit.Bit>_R)_R
               :: CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    CLaSH.Bit.Bit
                    ~#
                  CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))
                    CLaSH.Bit.Bit))

$cfromBV_avB8
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Vector.Vec
       (CLaSH.Class.BitVector.BitSize
          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
       CLaSH.Bit.Bit
     -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cfromBV_avB8 =
  a_swhq
  `cast` (forall (frac_auGT :: GHC.TypeLits.Nat)
                 (rep_auGU :: GHC.TypeLits.Nat -> *)
                 (size_auGV :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))>_R
          -> <CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGT>_P <rep_auGU>_R) <size_auGV>_N
          :: (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> rep_auGU size_auGV)
               ~#
             (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))

a_swhr
  :: forall (frac_XuIF :: GHC.TypeLits.Nat)
            (rep_XuIH :: GHC.TypeLits.Nat -> *)
            (size_XuIJ :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
     CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
     -> CLaSH.Sized.Vector.Vec
          (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ)) CLaSH.Bit.Bit
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhr =
  \ (@ (frac_XuIF :: GHC.TypeLits.Nat))
    (@ (rep_XuIH :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIJ :: GHC.TypeLits.Nat))
    ($dBitVector_XvCL
       :: CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ))
    ($dKnownNat_avB0
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ)))
    (ds_dw0H
       :: CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ) ->
    CLaSH.Class.BitVector.toBV
      @ (rep_XuIH size_XuIJ)
      $dBitVector_XvCL
      ($dKnownNat_avB0
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ))))
      (ds_dw0H
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIF>_P <rep_XuIH>_R <size_XuIJ>_N
               :: CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
                    ~#
                  rep_XuIH size_XuIJ))

$ctoBV_avAY
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
     -> CLaSH.Sized.Vector.Vec
          (CLaSH.Class.BitVector.BitSize
             (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
          CLaSH.Bit.Bit
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$ctoBV_avAY =
  a_swhr
  `cast` (forall (frac_XuIF :: GHC.TypeLits.Nat)
                 (rep_XuIH :: GHC.TypeLits.Nat -> *)
                 (size_XuIJ :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ>_R
          -> (CLaSH.Sized.Vector.Vec
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                      <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))
                <CLaSH.Bit.Bit>_R)_R
          :: (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ)) CLaSH.Bit.Bit)
               ~#
             (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                   CLaSH.Bit.Bit))

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         $ctoBV_avAY
                                           @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT
                                         $cfromBV_avB8
                                           @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ($ctoBV_avAY @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)
      ($cfromBV_avB8 @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)

a_swhs
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhs =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    Data.Default.Class.def @ (rep_auGM size_auGN) $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cdef_avAg =
  a_swhs
  `cast` (forall (frac_auGL :: GHC.TypeLits.Nat)
                 (rep_auGM :: GHC.TypeLits.Nat -> *)
                 (size_auGN :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_auGM size_auGN)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGL>_P <rep_auGM>_R) <size_auGN>_N
          :: (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              rep_auGM size_auGN)
               ~#
             (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  $cdef_avAg
  `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                 (rep_XuIO :: GHC.TypeLits.Nat -> *)
                 (size_XuIQ :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
          -> Sym
               (Data.Default.Class.NTCo:Default[0]
                  <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
          :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
               ~#
             (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))

a_swht
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swht =
  \ (@ (frac_auGI :: GHC.TypeLits.Nat))
    (@ (rep_auGJ :: GHC.TypeLits.Nat -> *))
    (@ (size_auGK :: GHC.TypeLits.Nat))
    ($dBounded_avzT :: GHC.Enum.Bounded (rep_auGJ size_auGK)) ->
    GHC.Enum.maxBound @ (rep_auGJ size_auGK) $dBounded_avzT

$cmaxBound_avA4
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmaxBound_avA4 =
  a_swht
  `cast` (forall (frac_auGI :: GHC.TypeLits.Nat)
                 (rep_auGJ :: GHC.TypeLits.Nat -> *)
                 (size_auGK :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_auGJ size_auGK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGI>_P <rep_auGJ>_R) <size_auGK>_N
          :: (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              rep_auGJ size_auGK)
               ~#
             (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK))

a_swhu
  :: forall (frac_XuIQ :: GHC.TypeLits.Nat)
            (rep_XuIS :: GHC.TypeLits.Nat -> *)
            (size_XuIU :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
     rep_XuIS size_XuIU
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhu =
  \ (@ (frac_XuIQ :: GHC.TypeLits.Nat))
    (@ (rep_XuIS :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIU :: GHC.TypeLits.Nat))
    ($dBounded_XvC4 :: GHC.Enum.Bounded (rep_XuIS size_XuIU)) ->
    GHC.Enum.minBound @ (rep_XuIS size_XuIU) $dBounded_XvC4

$cminBound_avzV
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cminBound_avzV =
  a_swhu
  `cast` (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                 (rep_XuIS :: GHC.TypeLits.Nat -> *)
                 (size_XuIU :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_XuIS size_XuIU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIQ>_P <rep_XuIS>_R) <size_XuIU>_N
          :: (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              rep_XuIS size_XuIU)
               ~#
             (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIQ rep_XuIS size_XuIU))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          $cminBound_avzV @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa
                          $cmaxBound_avA4 @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ($cminBound_avzV @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)
      ($cmaxBound_avA4 @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)

a_swlr
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swlr =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Classes.min @ (rep_auFG size_auFH) $dOrd_avyb

$cmin_avzC
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmin_avzC =
  a_swlr
  `cast` (forall (frac_auFF :: GHC.TypeLits.Nat)
                 (rep_auFG :: GHC.TypeLits.Nat -> *)
                 (size_auFH :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)>_R
          -> <GHC.Classes.Ord (rep_auFG size_auFH)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          :: (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH)
               ~#
             (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH))

a_swls
  :: forall (frac_XuHQ :: GHC.TypeLits.Nat)
            (rep_XuHS :: GHC.TypeLits.Nat -> *)
            (size_XuHU :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
      GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
     rep_XuHS size_XuHU -> rep_XuHS size_XuHU -> rep_XuHS size_XuHU
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swls =
  \ (@ (frac_XuHQ :: GHC.TypeLits.Nat))
    (@ (rep_XuHS :: GHC.TypeLits.Nat -> *))
    (@ (size_XuHU :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAq :: GHC.Classes.Ord (rep_XuHS size_XuHU)) ->
    GHC.Classes.max @ (rep_XuHS size_XuHU) $dOrd_XvAq

$cmax_avzm
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmax_avzm =
  a_swls
  `cast` (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                 (rep_XuHS :: GHC.TypeLits.Nat -> *)
                 (size_XuHU :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU)>_R
          -> <GHC.Classes.Ord (rep_XuHS size_XuHU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          :: (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              rep_XuHS size_XuHU -> rep_XuHS size_XuHU -> rep_XuHS size_XuHU)
               ~#
             (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU))

a_swhz
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhz =
  \ (@ (frac_XuHX :: GHC.TypeLits.Nat))
    (@ (rep_XuHZ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuI1 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAx :: GHC.Classes.Ord (rep_XuHZ size_XuI1)) ->
    GHC.Classes.<= @ (rep_XuHZ size_XuI1) $dOrd_XvAx

$c<=_avz8
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c<=_avz8 =
  a_swhz
  `cast` (forall (frac_XuHY :: GHC.TypeLits.Nat)
                 (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                 (size_XuI2 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2)>_R
          -> <GHC.Classes.Ord (rep_XuI0 size_XuI2)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              rep_XuI0 size_XuI2 -> rep_XuI0 size_XuI2 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> GHC.Types.Bool))

a_swhA
  :: forall (frac_XuI3 :: GHC.TypeLits.Nat)
            (rep_XuI5 :: GHC.TypeLits.Nat -> *)
            (size_XuI7 :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
      GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
     rep_XuI5 size_XuI7 -> rep_XuI5 size_XuI7 -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhA =
  \ (@ (frac_XuI3 :: GHC.TypeLits.Nat))
    (@ (rep_XuI5 :: GHC.TypeLits.Nat -> *))
    (@ (size_XuI7 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAD :: GHC.Classes.Ord (rep_XuI5 size_XuI7)) ->
    GHC.Classes.> @ (rep_XuI5 size_XuI7) $dOrd_XvAD

$c>_avyU
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c>_avyU =
  a_swhA
  `cast` (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                 (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                 (size_XuI7 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7)>_R
          -> <GHC.Classes.Ord (rep_XuI5 size_XuI7)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              rep_XuI5 size_XuI7 -> rep_XuI5 size_XuI7 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> GHC.Types.Bool))

a_swhB
  :: forall (frac_XuIa :: GHC.TypeLits.Nat)
            (rep_XuIc :: GHC.TypeLits.Nat -> *)
            (size_XuIe :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
      GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
     rep_XuIc size_XuIe -> rep_XuIc size_XuIe -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhB =
  \ (@ (frac_XuIa :: GHC.TypeLits.Nat))
    (@ (rep_XuIc :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIe :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAK :: GHC.Classes.Ord (rep_XuIc size_XuIe)) ->
    GHC.Classes.>= @ (rep_XuIc size_XuIe) $dOrd_XvAK

$c>=_avyG
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c>=_avyG =
  a_swhB
  `cast` (forall (frac_XuIa :: GHC.TypeLits.Nat)
                 (rep_XuIc :: GHC.TypeLits.Nat -> *)
                 (size_XuIe :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe)>_R
          -> <GHC.Classes.Ord (rep_XuIc size_XuIe)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              rep_XuIc size_XuIe -> rep_XuIc size_XuIe -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> GHC.Types.Bool))

a_swhC
  :: forall (frac_XuIh :: GHC.TypeLits.Nat)
            (rep_XuIj :: GHC.TypeLits.Nat -> *)
            (size_XuIl :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
      GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
     rep_XuIj size_XuIl -> rep_XuIj size_XuIl -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhC =
  \ (@ (frac_XuIh :: GHC.TypeLits.Nat))
    (@ (rep_XuIj :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIl :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAR :: GHC.Classes.Ord (rep_XuIj size_XuIl)) ->
    GHC.Classes.< @ (rep_XuIj size_XuIl) $dOrd_XvAR

$c<_avys
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c<_avys =
  a_swhC
  `cast` (forall (frac_XuIh :: GHC.TypeLits.Nat)
                 (rep_XuIj :: GHC.TypeLits.Nat -> *)
                 (size_XuIl :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl)>_R
          -> <GHC.Classes.Ord (rep_XuIj size_XuIl)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              rep_XuIj size_XuIl -> rep_XuIj size_XuIl -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> GHC.Types.Bool))

a_swhD
  :: forall (frac_XuIo :: GHC.TypeLits.Nat)
            (rep_XuIq :: GHC.TypeLits.Nat -> *)
            (size_XuIs :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
      GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
     rep_XuIq size_XuIs -> rep_XuIq size_XuIs -> GHC.Types.Ordering
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhD =
  \ (@ (frac_XuIo :: GHC.TypeLits.Nat))
    (@ (rep_XuIq :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIs :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAY :: GHC.Classes.Ord (rep_XuIq size_XuIs)) ->
    GHC.Classes.compare @ (rep_XuIq size_XuIs) $dOrd_XvAY

$ccompare_avye
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Ordering
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$ccompare_avye =
  a_swhD
  `cast` (forall (frac_XuIo :: GHC.TypeLits.Nat)
                 (rep_XuIq :: GHC.TypeLits.Nat -> *)
                 (size_XuIs :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs)>_R
          -> <GHC.Classes.Ord (rep_XuIq size_XuIs)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> <GHC.Types.Ordering>_R
          :: (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              rep_XuIq size_XuIs -> rep_XuIq size_XuIs -> GHC.Types.Ordering)
               ~#
             (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> GHC.Types.Ordering))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         $ccompare_avye
                           @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c<_avys @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c>=_avyG @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c>_avyU @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c<=_avz8 @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $cmax_avzm @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $cmin_avzC @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ($ccompare_avye
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<_avys @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>=_avyG @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>_avyU @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<=_avz8 @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmax_avzm
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmin_avzC
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)

a_swhE
  :: forall (frac_XuIw :: GHC.TypeLits.Nat)
            (rep_XuIy :: GHC.TypeLits.Nat -> *)
            (size_XuIA :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_XuIy size_XuIA) =>
     rep_XuIy size_XuIA -> rep_XuIy size_XuIA -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhE =
  \ (@ (frac_XuIw :: GHC.TypeLits.Nat))
    (@ (rep_XuIy :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIA :: GHC.TypeLits.Nat))
    ($dEq_avxF :: GHC.Classes.Eq (rep_XuIy size_XuIA)) ->
    GHC.Classes./= @ (rep_XuIy size_XuIA) $dEq_avxF

$c/=_avxV
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c/=_avxV =
  a_swhE
  `cast` (forall (frac_XuIw :: GHC.TypeLits.Nat)
                 (rep_XuIy :: GHC.TypeLits.Nat -> *)
                 (size_XuIA :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIy size_XuIA)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              rep_XuIy size_XuIA -> rep_XuIy size_XuIA -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> GHC.Types.Bool))

a_swhF
  :: forall (frac_XuIC :: GHC.TypeLits.Nat)
            (rep_XuIE :: GHC.TypeLits.Nat -> *)
            (size_XuIG :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_XuIE size_XuIG) =>
     rep_XuIE size_XuIG -> rep_XuIE size_XuIG -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhF =
  \ (@ (frac_XuIC :: GHC.TypeLits.Nat))
    (@ (rep_XuIE :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIG :: GHC.TypeLits.Nat))
    ($dEq_XvAF :: GHC.Classes.Eq (rep_XuIE size_XuIG)) ->
    GHC.Classes.== @ (rep_XuIE size_XuIG) $dEq_XvAF

$c==_avxH
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c==_avxH =
  a_swhF
  `cast` (forall (frac_XuIC :: GHC.TypeLits.Nat)
                 (rep_XuIE :: GHC.TypeLits.Nat -> *)
                 (size_XuIG :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIE size_XuIG)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              rep_XuIE size_XuIG -> rep_XuIE size_XuIG -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> GHC.Types.Bool))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        $c==_avxH @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL
                        $c/=_avxV @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ($c==_avxH @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)
      ($c/=_avxV @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)

lvl_swwb
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwb =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#

lvl_swwc :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwc = GHC.Base.build @ GHC.Types.Char lvl_swwb

lvl_swwd
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwd =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#

lvl_swwe :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwe = GHC.Base.build @ GHC.Types.Char lvl_swwd

lvl_swwf
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwf =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#

lvl_swwg :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwg = GHC.Base.build @ GHC.Types.Char lvl_swwf

lvl_swwh :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swwh =
  Language.Haskell.TH.Syntax.mkNameG_d lvl_swwc lvl_swwe lvl_swwg

lvl_swwi :: Language.Haskell.TH.Lib.ExpQ
[LclId, Str=DmdType]
lvl_swwi = Language.Haskell.TH.Lib.conE lvl_swwh

lvl_swwj
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwj =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#

lvl_swwk :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwk = GHC.Base.build @ GHC.Types.Char lvl_swwj

lvl_swwl
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwl =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#

lvl_swwm :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwm = GHC.Base.build @ GHC.Types.Char lvl_swwl

lvl_swwn
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwn =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#

lvl_swwo :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwo = GHC.Base.build @ GHC.Types.Char lvl_swwn

lvl_swwp :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swwp =
  Language.Haskell.TH.Syntax.mkNameG_tc lvl_swwk lvl_swwm lvl_swwo

lvl_swwq :: Language.Haskell.TH.Lib.TypeQ
[LclId, Str=DmdType]
lvl_swwq = Language.Haskell.TH.Lib.conT lvl_swwp

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$clift_avAv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    Language.Haskell.TH.Lib.sigE
      (Language.Haskell.TH.Lib.appE
         lvl_swwi
         (Language.Haskell.TH.Syntax.lift
            @ (rep_auGP size_auGQ)
            $dLift_avAq
            (f_auGR
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                          ~#
                        rep_auGP size_auGQ))))
      (GHC.List.foldl
         @ Language.Haskell.TH.Lib.TypeQ
         @ Language.Haskell.TH.Lib.TypeQ
         Language.Haskell.TH.Lib.appT
         lvl_swwq
         (GHC.Base.build
            @ Language.Haskell.TH.Lib.TypeQ
            (\ (@ a_dvZ6)
               (c_dvZ7 [OS=OneShot]
                  :: Language.Haskell.TH.Lib.TypeQ -> a_dvZ6 -> a_dvZ6)
               (n_dvZ8 [OS=OneShot] :: a_dvZ6) ->
               c_dvZ7
                 (Language.Haskell.TH.Lib.litT
                    (Language.Haskell.TH.Lib.numTyLit
                       (GHC.TypeLits.natVal
                          @ frac_auGO
                          @ Data.Proxy.Proxy
                          $dKnownNat_avAr
                          (CLaSH.Sized.Fixed.asFracProxy
                             @ frac_auGO @ rep_auGP @ size_auGQ f_auGR))))
                 (c_dvZ7
                    (Language.Haskell.TH.Lib.conT
                       (Language.Haskell.TH.Syntax.mkName
                          (Data.Typeable.Internal.$fShowTypeRep_$cshow
                             (Data.Typeable.Internal.typeRep
                                @ (GHC.TypeLits.Nat -> *)
                                @ Data.Proxy.Proxy
                                @ rep_auGP
                                $dTypeable_avAt
                                (CLaSH.Sized.Fixed.asRepProxy
                                   @ frac_auGO @ rep_auGP @ size_auGQ f_auGR)))))
                    (c_dvZ7
                       (Language.Haskell.TH.Lib.litT
                          (Language.Haskell.TH.Lib.numTyLit
                             (GHC.TypeLits.natVal
                                @ size_auGQ
                                @ (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP)
                                $dKnownNat_avAs
                                f_auGR)))
                       n_dvZ8)))))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                              (rep_auGP :: GHC.TypeLits.Nat -> *)
                              (size_auGQ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
                       -> <GHC.TypeLits.KnownNat frac_auGO>_R
                       -> <GHC.TypeLits.KnownNat size_auGQ>_R
                       -> <Data.Typeable.Internal.Typeable rep_auGP>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_N)
                       :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                                  (rep_auGP :: GHC.TypeLits.Nat -> *)
                                  (size_auGQ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
                            GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
                            Data.Typeable.Internal.Typeable rep_auGP) =>
                           CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_auGO :: GHC.TypeLits.Nat)
                                  (rep_auGP :: GHC.TypeLits.Nat -> *)
                                  (size_auGQ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
                            GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
                            Data.Typeable.Internal.Typeable rep_auGP) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  $clift_avAv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                  <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Float inwards:

==================== Float inwards ====================
Result size of Float inwards
  = {terms: 2,164, types: 11,689, coercions: 844}

Rec {
$dReal_swuD :: GHC.Real.Real GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dReal_swuD =
  GHC.Real.$p1Integral
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

$dNum1_swuE :: GHC.Num.Num GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dNum1_swuE =
  GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal_swuD

$dOrd_swuF :: GHC.Classes.Ord GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dOrd_swuF =
  GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal_swuD

$dReal1_swuL :: GHC.Real.Real GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dReal1_swuL =
  GHC.Real.$p1Integral
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

a1_swuM :: GHC.Classes.Ord GHC.Integer.Type.Integer
[LclId, Str=DmdType]
a1_swuM = GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal1_swuL

$dEq_swuN [Occ=OnceL] :: GHC.Classes.Eq GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dEq_swuN = GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer a1_swuM

$dNum2_swuO :: GHC.Num.Num GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dNum2_swuO =
  GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal1_swuL

$dReal2_swuT :: GHC.Real.Real GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dReal2_swuT =
  GHC.Real.$p1Integral
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

a2_swuU :: GHC.Classes.Ord GHC.Integer.Type.Integer
[LclId, Str=DmdType]
a2_swuU = GHC.Real.$p2Real @ GHC.Integer.Type.Integer $dReal2_swuT

$dEq1_swuV [Occ=OnceL] :: GHC.Classes.Eq GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dEq1_swuV = GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer a2_swuU

$dNum3_swuW :: GHC.Num.Num GHC.Integer.Type.Integer
[LclId, Str=DmdType]
$dNum3_swuW =
  GHC.Real.$p1Real @ GHC.Integer.Type.Integer $dReal2_swuT

lvl_swv1 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv1 = __integer 1

lvl_swv2 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv2 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum3_swuW lvl_swv1

lvl_swv3 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv3 = __integer 2

lvl_swv4 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv4 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum3_swuW lvl_swv3

lvl_swuZ :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuZ = __integer 1

lvl_swv0 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv0 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum3_swuW lvl_swuZ

lvl_swv5 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv5 = __integer 2

lvl_swv6 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv6 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum3_swuW lvl_swv5

g1_swuY [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[LclId, Arity=3, Str=DmdType]
g1_swuY =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP [Occ=Once*] :: GHC.Types.Double) ->
    case GHC.Real.even
           @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger y1_akDO
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Classes.==
               @ GHC.Integer.Type.Integer $dEq1_swuV y1_akDO lvl_swv0
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Num.*
                 @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN x1_akDN)
              (GHC.Real.quot
                 @ GHC.Integer.Type.Integer
                 GHC.Real.$fIntegralInteger
                 (GHC.Num.- @ GHC.Integer.Type.Integer $dNum3_swuW y1_akDO lvl_swv2)
                 lvl_swv4)
              (GHC.Num.*
                 @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN z_akDP);
          GHC.Types.True ->
            GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN z_akDP
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Num.*
             @ GHC.Types.Double GHC.Float.$fNumDouble x1_akDN x1_akDN)
          (GHC.Real.quot
             @ GHC.Integer.Type.Integer
             GHC.Real.$fIntegralInteger
             y1_akDO
             lvl_swv6)
          z_akDP
    }

lvl_swv7 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv7 = __integer 1

lvl_swv8 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv8 =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum2_swuO lvl_swv7

lvl_swv9 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv9 = __integer 2

lvl_swva :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swva =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum2_swuO lvl_swv9

lvl_swuR :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuR = __integer 1

lvl_swuS :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuS =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum2_swuO lvl_swuR

lvl_swvb :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvb = __integer 2

lvl_swvc :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvc =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum2_swuO lvl_swvb

f_swuQ [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId, Arity=2, Str=DmdType]
f_swuQ =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Real.even
           @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger y_akDB
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Classes.==
               @ GHC.Integer.Type.Integer $dEq_swuN y_akDB lvl_swuS
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x_akDA x_akDA)
              (GHC.Real.quot
                 @ GHC.Integer.Type.Integer
                 GHC.Real.$fIntegralInteger
                 (GHC.Num.- @ GHC.Integer.Type.Integer $dNum2_swuO y_akDB lvl_swv8)
                 lvl_swva)
              x_akDA;
          GHC.Types.True -> x_akDA
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Num.* @ GHC.Types.Double GHC.Float.$fNumDouble x_akDA x_akDA)
          (GHC.Real.quot
             @ GHC.Integer.Type.Integer
             GHC.Real.$fIntegralInteger
             y_akDB
             lvl_swvc)
    }

lvl_swvd :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvd = __integer 1

lvl_swve :: GHC.Types.Double
[LclId, Str=DmdType]
lvl_swve =
  GHC.Num.fromInteger
    @ GHC.Types.Double GHC.Float.$fNumDouble lvl_swvd

lvl_swuI :: GHC.Classes.Eq GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuI = GHC.Classes.$p1Ord @ GHC.Integer.Type.Integer $dOrd_swuF

lvl_swuJ :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuJ = __integer 0

lvl_swuK :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuK =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum1_swuE lvl_swuJ

lvl_swvf :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvf = GHC.CString.unpackCString# "Negative exponent"#

lvl_swvg :: GHC.Types.Double
[LclId, Str=DmdType b]
lvl_swvg = GHC.Err.error @ GHC.Types.Double lvl_swvf

lvl_swuG :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuG = __integer 0

lvl_swuH :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuH =
  GHC.Num.fromInteger @ GHC.Integer.Type.Integer $dNum1_swuE lvl_swuG

$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId, Arity=2, Str=DmdType]
$s^_swu6 =
  \ (eta_akDk [Occ=Once] :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Classes.<
           @ GHC.Integer.Type.Integer $dOrd_swuF eta1_akDl lvl_swuH
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Classes.==
               @ GHC.Integer.Type.Integer lvl_swuI eta1_akDl lvl_swuK
        of _ [Occ=Dead] {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        };
      GHC.Types.True -> lvl_swvg
    }
end Rec }

lvl_swvh :: GHC.Types.Double
[LclId, Str=DmdType]
lvl_swvh = GHC.Types.D# 2.0

lvl_swvi
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvi =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#

lvl_swvj :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvj = GHC.Base.build @ GHC.Types.Char lvl_swvi

lvl_swvk
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvk =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#

lvl_swvl :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvl = GHC.Base.build @ GHC.Types.Char lvl_swvk

lvl_swvm
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvm =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#

lvl_swvn :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvn = GHC.Base.build @ GHC.Types.Char lvl_swvm

lvl_swvo :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swvo =
  Language.Haskell.TH.Syntax.mkNameG_d lvl_swvj lvl_swvl lvl_swvn

lvl_swvp :: Language.Haskell.TH.Lib.ExpQ
[LclId, Str=DmdType]
lvl_swvp = Language.Haskell.TH.Lib.conE lvl_swvo

lvl_swvq
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvq =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "base"#

lvl_swvr :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvr = GHC.Base.build @ GHC.Types.Char lvl_swvq

lvl_swvs
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvs =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "GHC.Num"#

lvl_swvt :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvt = GHC.Base.build @ GHC.Types.Char lvl_swvs

lvl_swvu
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swvu =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "fromInteger"#

lvl_swvv :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvv = GHC.Base.build @ GHC.Types.Char lvl_swvu

lvl_swvw :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swvw =
  Language.Haskell.TH.Syntax.mkNameG_v lvl_swvr lvl_swvt lvl_swvv

lvl_swvx :: Language.Haskell.TH.Lib.ExpQ
[LclId, Str=DmdType]
lvl_swvx = Language.Haskell.TH.Lib.varE lvl_swvw

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.fLit =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    Language.Haskell.TH.Syntax.unsafeTExpCoerce
      @ (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)
      (Language.Haskell.TH.Lib.appE
         lvl_swvp
         (Language.Haskell.TH.Lib.appE
            lvl_swvx
            (Language.Haskell.TH.Syntax.lift
               @ GHC.Integer.Type.Integer
               Language.Haskell.TH.Syntax.$fLiftInteger
               (let {
                  rMax_swu0 :: GHC.Integer.Type.Integer
                  [LclId, Str=DmdType]
                  rMax_swu0 =
                    GHC.Real.toInteger
                      @ (rep_avhN size_avhO)
                      $dIntegral_avlP
                      (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
                let {
                  truncated_swu2 :: GHC.Integer.Type.Integer
                  [LclId, Str=DmdType]
                  truncated_swu2 =
                    GHC.Float.RealFracMethods.truncateDoubleInteger
                      (GHC.Float.timesDouble
                         a_auGC
                         (GHC.Real.^
                            @ GHC.Types.Double
                            @ GHC.Integer.Type.Integer
                            GHC.Float.$fNumDouble
                            GHC.Real.$fIntegralInteger
                            lvl_swvh
                            (GHC.TypeLits.natVal
                               @ frac_avhM
                               @ Data.Proxy.Proxy
                               $dKnownNat_avlM
                               (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avhM)))) } in
                case GHC.Integer.Type.gtInteger truncated_swu2 rMax_swu0
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    let {
                      rMin_swu1 :: GHC.Integer.Type.Integer
                      [LclId, Str=DmdType]
                      rMin_swu1 =
                        GHC.Real.toInteger
                          @ (rep_avhN size_avhO)
                          $dIntegral_avlP
                          (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
                    case GHC.Integer.Type.ltInteger truncated_swu2 rMin_swu1
                    of _ [Occ=Dead] {
                      GHC.Types.False -> truncated_swu2;
                      GHC.Types.True -> rMin_swu1
                    };
                  GHC.Types.True -> rMax_swu0
                }))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      repBV_swtT =
        let {
          cobox_swtW
            :: CLaSH.Class.BitVector.BitSize
                 (rep_aviy (n_aviz GHC.TypeLits.+ 2))
               ~ (n_aviz GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          cobox_swtW =
            case tup_avmQ
            of _ [Occ=Dead]
            { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
            tpl_B6
            } } in
        case case cobox_swtW of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
             GHC.Types.Eq#
               @ *
               @ (CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                    CLaSH.Bit.Bit)
               @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
               @~ (CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_N)_N
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6X ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of _ [Occ=Dead]
            { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
            tpl_B4
            })
           (case cobox_swtW of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Y ->
            (case tup_avmQ
             of _ [Occ=Dead]
             { (tpl_X1x, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
             tpl_B8
             })
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Y))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2))))
            })
           eta_B1)
        `cast` (Sub cobox_dw6X
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        } } in
    let {
      cobox_swtU
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_swtU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      s_swtS =
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (case case case cobox_swtU
                        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ (n_aviz GHC.TypeLits.+ 2)
                          @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                          @~ (Sym cobox_dw7d)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw75 ->
                   GHC.Types.Eq#
                     @ *
                     @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                     @ (CLaSH.Sized.Vector.Vec
                          ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                     @~ (CLaSH.Sized.Vector.Vec cobox_dw75 <CLaSH.Bit.Bit>_N)_N
                   }
              of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvY9 ->
              repBV_swtT
              `cast` (Sub cobox_dvY9
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
              })) } in
    let {
      cobox_swtV
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId, Str=DmdType]
      cobox_swtV =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           (case tup_avmQ
            of _ [Occ=Dead]
            { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
            tpl_Ba
            })
           eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          ds_swtR :: CLaSH.Bit.Bit
          [LclId, Str=DmdType]
          ds_swtR =
            CLaSH.Sized.Vector.vhead
              @ n_aviz
              @ CLaSH.Bit.Bit
              (CLaSH.Sized.Vector.vtail
                 @ (n_aviz GHC.TypeLits.+ 1)
                 @ CLaSH.Bit.Bit
                 (case case case cobox_swtU
                            of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7g ->
                            GHC.Types.Eq#
                              @ GHC.TypeLits.Nat
                              @ (n_aviz GHC.TypeLits.+ 2)
                              @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                              @~ (Sym cobox_dw7g)
                            }
                       of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw73 ->
                       GHC.Types.Eq#
                         @ *
                         @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                         @ (CLaSH.Sized.Vector.Vec
                              ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                         @~ (CLaSH.Sized.Vector.Vec cobox_dw73 <CLaSH.Bit.Bit>_N)_N
                       }
                  of _ [Occ=Dead] { GHC.Types.Eq# cobox_dvYc ->
                  repBV_swtT
                  `cast` (Sub cobox_dvYc
                          :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                               ~#
                             CLaSH.Sized.Vector.Vec
                               ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                  })) } in
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_swtU
                          of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw71 ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6W ->
                repBV_swtT
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case ds_swtR of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6T ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case ds_swtR of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7c)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6T ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6T <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        };
      GHC.Types.True ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (case case case cobox_swtU
                          of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
                          GHC.Types.Eq#
                            @ GHC.TypeLits.Nat
                            @ (n_aviz GHC.TypeLits.+ 2)
                            @ ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
                            @~ (Sym cobox_dw7j)
                          }
                     of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw71 ->
                     GHC.Types.Eq#
                       @ *
                       @ (CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
                       @ (CLaSH.Sized.Vector.Vec
                            ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                       @~ (CLaSH.Sized.Vector.Vec cobox_dw71 <CLaSH.Bit.Bit>_N)_N
                     }
                of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6W ->
                repBV_swtT
                `cast` (Sub cobox_dw6W
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)
                })
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1p, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_X1p
                    })
                   s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6S ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L ->
                GHC.Enum.minBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1p, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_X1p
                    })
                   s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                GHC.Enum.maxBound
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1d, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B9
                   });
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  (case tup_avmQ
                   of _ [Occ=Dead]
                   { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                   tpl_B3
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   (case tup_avmQ
                    of _ [Occ=Dead]
                    { (tpl_X1e, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
                    tpl_B7
                    })
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                        GHC.Types.Eq#
                          @ GHC.TypeLits.Nat
                          @ n_aviz
                          @ (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                          @~ (Sym cobox_dw7a)
                        }
                   of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6S ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6S <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
    }

lvl_swvz :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvz = __integer 0

lvl_swvy :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvy = __integer 0

lvl_swvB :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvB = __integer 0

lvl_swvA :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvA = __integer 0

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat_swtH =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_swtI =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    let {
      argFracSZ_swtB :: GHC.Types.Int
      [LclId, Str=DmdType]
      argFracSZ_swtB =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac1_avjq
             @ Data.Proxy.Proxy
             (case tup_avnK
              of _ [Occ=Dead]
              { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Bb
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac1_avjq)) } in
    let {
      resFracSZ_swtC :: GHC.Types.Int
      [LclId, Str=DmdType]
      resFracSZ_swtC =
        GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac2_avjr
             @ Data.Proxy.Proxy
             (case tup_avnK
              of _ [Occ=Dead]
              { (tpl_X1w, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac2_avjr)) } in
    let {
      $dResize_swtG :: CLaSH.Class.Num.Resize rep_avjs
      [LclId, Str=DmdType]
      $dResize_swtG =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    case GHC.Integer.Type.leInteger
           (GHC.TypeLits.natVal
              @ size1_avjt
              @ Data.Proxy.Proxy
              $dKnownNat_swtI
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size1_avjt))
           (GHC.TypeLits.natVal
              @ size2_avju
              @ Data.Proxy.Proxy
              $dKnownNat_swtH
              (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ size2_avju))
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          $dBounded_swtD :: GHC.Enum.Bounded (rep_avjs size2_avju)
          [LclId, Str=DmdType]
          $dBounded_swtD =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X1u
            } } in
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId, Str=DmdType]
          fMax_swtA =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          $dBits_swtF :: Data.Bits.Bits (rep_avjs size1_avjt)
          [LclId, Str=DmdType]
          $dBits_swtF =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1o, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId, Str=DmdType]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (CLaSH.Class.Num.resize
                 @ rep_avjs
                 $dResize_swtG
                 @ size2_avju
                 @ size1_avjt
                 $dKnownNat_swtH
                 $dKnownNat_swtI
                 fMax_swtA) } in
        let {
          $dNum_swtE :: GHC.Num.Num (rep_avjs size1_avjt)
          [LclId, Str=DmdType]
          $dNum_swtE =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            } } in
        case GHC.Classes.leInt argFracSZ_swtB resFracSZ_swtC
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- argFracSZ_swtB resFracSZ_swtC) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of _ [Occ=Dead]
                    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvy)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvz)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Num.$fNumInt_$c- resFracSZ_swtC argFracSZ_swtB) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   (case tup_avnK
                    of _ [Occ=Dead]
                    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                    tpl_B3
                    })
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvA)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvB)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    (CLaSH.Class.Num.resize
                       @ rep_avjs
                       $dResize_swtG
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        };
      GHC.Types.True ->
        case GHC.Classes.leInt argFracSZ_swtB resFracSZ_swtC
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of _ [Occ=Dead]
                { (tpl_X1h, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_swtG
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- argFracSZ_swtB resFracSZ_swtC))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               (case tup_avnK
                of _ [Occ=Dead]
                { (tpl_X1h, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
                tpl_B9
                })
               (CLaSH.Class.Num.resize
                  @ rep_avjs
                  $dResize_swtG
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Num.$fNumInt_$c- resFracSZ_swtC argFracSZ_swtB))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 70 0}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    (f_auGd :: CLaSH.Sized.Fixed.Fixed frac_avjN rep_avjO size_avjP) ->
    GHC.Num.$fNumInt_$cfromInteger
      (GHC.TypeLits.natVal
         @ frac_avjN
         @ Data.Proxy.Proxy
         $dKnownNat_avxa
         (CLaSH.Sized.Fixed.asFracProxy
            @ frac_avjN @ rep_avjO @ size_avjP f_auGd))

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

lvl_swvD :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvD = GHC.Types.C# '-'

lvl_swvC :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvC = __integer 0

lvl_swvE :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvE = GHC.Types.C# '.'

lvl_swvF
  :: forall b_X4Kn.
     (GHC.Types.Char -> b_X4Kn -> b_X4Kn) -> b_X4Kn -> b_X4Kn
[LclId, Str=DmdType]
lvl_swvF =
  \ (@ b_X4Kn)
    (c_X4Kp [OS=OneShot] :: GHC.Types.Char -> b_X4Kn -> b_X4Kn)
    (n_X4Kr [OS=OneShot] :: b_X4Kn) ->
    c_X4Kp lvl_swvE n_X4Kr

lvl_swvG :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvG = GHC.Types.C# '0'

lvl_swvH :: GHC.Types.Int -> [GHC.Types.Char] -> [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvH =
  \ (n_auHJ [OS=ProbOneShot] :: GHC.Types.Int)
    (str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]) ->
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_X4M9)
         (c_X4Mc [OS=OneShot] :: GHC.Types.Char -> b_X4M9 -> b_X4M9)
         (n_X4Kt [OS=OneShot] :: b_X4M9) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_X4M9
           c_X4Mc
           n_X4Kt
           (GHC.List.replicate
              @ GHC.Types.Char
              (GHC.Num.$fNumInt_$c-
                 n_auHJ
                 (GHC.Base.foldr
                    @ GHC.Types.Char
                    @ (GHC.Prim.Int# -> GHC.Types.Int)
                    (GHC.List.incLen @ GHC.Types.Char)
                    GHC.Types.I#
                    str_auHK
                    0))
              lvl_swvG))
      str_auHK

lvl_swvI :: (GHC.Types.Int, [GHC.Types.Char]) -> [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swvI =
  Data.Tuple.uncurry
    @ GHC.Types.Int @ [GHC.Types.Char] @ [GHC.Types.Char] lvl_swvH

lvl_swvJ
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvJ =
  GHC.Real.numerator
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

lvl_swvK
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> GHC.Base.String
[LclId, Str=DmdType]
lvl_swvK =
  GHC.Base..
    @ GHC.Integer.Type.Integer
    @ GHC.Base.String
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    GHC.Show.$fShowInteger_$cshow
    lvl_swvJ

lvl_swvL
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, [GHC.Types.Char])
[LclId, Str=DmdType]
lvl_swvL =
  Control.Arrow.$fArrow(->)_$csecond
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ [GHC.Types.Char]
    @ GHC.Types.Int
    lvl_swvK

ds_swvM :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
ds_swvM = __integer 1

lvl_swvN :: GHC.Integer.Type.Integer -> GHC.Types.Bool
[LclId, Str=DmdType]
lvl_swvN =
  \ (ds_dw44 [OS=ProbOneShot] :: GHC.Integer.Type.Integer) ->
    GHC.Integer.Type.eqInteger ds_dw44 ds_swvM

lvl_swvO
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvO =
  GHC.Real.denominator
    @ GHC.Integer.Type.Integer GHC.Real.$fIntegralInteger

lvl_swvP
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvP =
  GHC.Base..
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ GHC.Integer.Type.Integer
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvO
    (Data.Tuple.snd
       @ GHC.Types.Int @ (GHC.Real.Ratio GHC.Integer.Type.Integer))

lvl_swvQ
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> GHC.Types.Bool
[LclId, Str=DmdType]
lvl_swvQ =
  GHC.Base..
    @ GHC.Integer.Type.Integer
    @ GHC.Types.Bool
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvN
    lvl_swvP

lvl_swvR
  :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
     -> Data.Maybe.Maybe
          (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_swvR =
  Data.List.find
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer) lvl_swvQ

lvl_swvS :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvS = __integer 10

ds_swvT :: GHC.Real.Ratio GHC.Integer.Type.Integer
[LclId, Str=DmdType]
ds_swvT = GHC.Real.$fNumRatio_$s$cfromInteger lvl_swvS

lvl_swvU
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> GHC.Real.Ratio GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvU =
  \ (ds_dw47 [OS=ProbOneShot]
       :: GHC.Real.Ratio GHC.Integer.Type.Integer) ->
    GHC.Real.$fNumRatio_$s$c* ds_dw47 ds_swvT

lvl_swvV
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_swvV =
  Control.Arrow.$fArrow(->)_$c***
    @ GHC.Types.Int
    @ GHC.Types.Int
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    GHC.Enum.$fEnumInt_$csucc
    lvl_swvU

lvl_swvW
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[LclId, Str=DmdType]
lvl_swvW =
  GHC.List.iterate
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer) lvl_swvV

lvl_swvX :: GHC.Types.Int
[LclId, Str=DmdType]
lvl_swvX = GHC.Types.I# 0

lvl_swvY
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_swvY =
  GHC.Tuple.(,)
    @ GHC.Types.Int
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvX

lvl_swvZ
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[LclId, Str=DmdType]
lvl_swvZ =
  GHC.Base..
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvW
    lvl_swvY

lvl_sww0
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> Data.Maybe.Maybe
          (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_sww0 =
  GHC.Base..
    @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
    @ (Data.Maybe.Maybe
         (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvR
    lvl_swvZ

lvl_sww1
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Str=DmdType]
lvl_sww1 =
  GHC.Base..
    @ (Data.Maybe.Maybe
         (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    (Data.Maybe.fromJust
       @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    lvl_sww0

lvl_sww2
  :: GHC.Real.Ratio GHC.Integer.Type.Integer
     -> (GHC.Types.Int, [GHC.Types.Char])
[LclId, Str=DmdType]
lvl_sww2 =
  GHC.Base..
    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
    @ (GHC.Types.Int, [GHC.Types.Char])
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvL
    lvl_sww1

lvl_sww3
  :: GHC.Real.Ratio GHC.Integer.Type.Integer -> [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_sww3 =
  GHC.Base..
    @ (GHC.Types.Int, [GHC.Types.Char])
    @ [GHC.Types.Char]
    @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
    lvl_swvI
    lvl_sww2

lvl_sww5 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww5 = __integer 2

lvl_sww6 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww6 = __integer 1

lvl_sww7 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww7 = __integer 2

lvl_sww8 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww8 = __integer 1

lvl_sww4 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww4 = __integer 0

lvl_sww9 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww9 = __integer 2

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      nF_swti :: GHC.Types.Int
      [LclId, Str=DmdType]
      nF_swti =
        CLaSH.Sized.Fixed.fracShift
          @ frac_auHx @ rep_auHy @ size_auHz $dKnownNat_avFx f_auHA } in
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a4II)
         (c_a4IJ [OS=OneShot] :: GHC.Types.Char -> b_a4II -> b_a4II)
         (n_a4IK [OS=OneShot] :: b_a4II) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a4II
           c_a4IJ
           n_a4IK
           (case GHC.Integer.Type.ltInteger fRepI_swtk lvl_swvC
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Show.$fShowInteger_$cshow
                  (Data.Bits.$fBitsInteger_$cshiftR fRepI_swtk nF_swti);
              GHC.Types.True ->
                GHC.Types.:
                  @ GHC.Types.Char
                  lvl_swvD
                  (GHC.Show.$fShowInteger_$cshow
                     (Data.Bits.$fBitsInteger_$cshiftR fRepI_abs_swtj nF_swti))
            }))
      (GHC.Base.augment
         @ GHC.Types.Char
         lvl_swvF
         (GHC.Base.$
            @ (GHC.Real.Ratio GHC.Integer.Type.Integer)
            @ [GHC.Types.Char]
            lvl_sww3
            (GHC.Real.%_$s%
               (case GHC.Integer.Type.ltInteger fRepI_swtk lvl_sww4
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    GHC.Integer.Type.andInteger
                      fRepI_swtk
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            lvl_sww5
                            nF_swti)
                         lvl_sww6);
                  GHC.Types.True ->
                    GHC.Integer.Type.andInteger
                      fRepI_abs_swtj
                      (GHC.Integer.Type.minusInteger
                         (GHC.Real.^
                            @ GHC.Integer.Type.Integer
                            @ GHC.Types.Int
                            GHC.Num.$fNumInteger
                            GHC.Real.$fIntegralInt
                            lvl_sww7
                            nF_swti)
                         lvl_sww8)
                })
               (GHC.Real.^
                  @ GHC.Integer.Type.Integer
                  @ GHC.Types.Int
                  GHC.Num.$fNumInteger
                  GHC.Real.$fIntegralInt
                  lvl_sww9
                  nF_swti))))

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 120 40}]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a2g3)
         (c_a2g4 [OS=OneShot] :: GHC.Types.Char -> b_a2g3 -> b_a2g3)
         (n_a2g5 [OS=OneShot] :: b_a2g3) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a2g3
           c_a2g4
           n_a2g5
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY))
      s_a2fZ

Rec {
CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

$cshowList_avIE [Occ=LoopBreaker]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId,
 Arity=4,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0] 140 60}]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    let {
      $dShow_swtc
        :: GHC.Show.Show
             (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      [LclId, Str=DmdType]
      $dShow_swtc =
        CLaSH.Sized.Fixed.$fShowFixed
          @ frac_auHx
          @ rep_auHy
          @ size_auHz
          $dShow_avFv
          $dBits_avFw
          $dKnownNat_avFx
          $dIntegral_avFy } in
    let {
      lvl_swwa
        :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
           -> GHC.Show.ShowS
      [LclId, Str=DmdType]
      lvl_swwa =
        GHC.Show.shows
          @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
          $dShow_swtc } in
    \ (ls_a2fk
         :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
      (s_a2fl :: GHC.Base.String) ->
      GHC.Show.showList__
        @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
        lvl_swwa
        ls_a2fk
        s_a2fl
end Rec }

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 70 0}]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl_X1B) ->
         tpl_X1B
         }
    of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
    (CLaSH.Class.Num.mult
       @ (rep_auHr size1_auHs)
       @ (rep_auHr size2_auHu)
       (case tup_avFg of _ [Occ=Dead] { (tpl_X1C, tpl_X1E) -> tpl_X1C })
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  $cmult_avFi
  `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                 (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                 (size1_XuJ3 :: GHC.TypeLits.Nat)
                 (frac2_XuJ5 :: GHC.TypeLits.Nat)
                 (size2_XuJ7 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
          -> Sym
               (CLaSH.Class.Num.NTCo:Mult[0]
                  <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                  <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
          :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
              -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                   (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
               ~#
             (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                     (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                     (size1_XuJ3 :: GHC.TypeLits.Nat)
                     (frac2_XuJ5 :: GHC.TypeLits.Nat)
                     (size2_XuJ7 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 450 0}]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    (letrec {
       $dKnownNat_swt4
         :: GHC.TypeLits.KnownNat
              (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
       [LclId, Str=DmdType]
       $dKnownNat_swt4 =
         case tup_swta
         of _ [Occ=Dead]
         { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_Ba
         };
       $dBits_swt5
         :: Data.Bits.Bits
              (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
       [LclId, Str=DmdType]
       $dBits_swt5 =
         case tup_swta
         of _ [Occ=Dead]
         { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B9
         };
       $dKnownNat_swt6
         :: GHC.TypeLits.KnownNat
              (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
       [LclId, Str=DmdType]
       $dKnownNat_swt6 =
         case tup_swta
         of _ [Occ=Dead]
         { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         };
       $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
       [LclId, Str=DmdType]
       $dResize_swt7 =
         case tup_swta
         of _ [Occ=Dead]
         { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B6
         };
       $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
       [LclId, Str=DmdType]
       $dBits_swt8 =
         case tup_swta
         of _ [Occ=Dead]
         { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B5
         };
       $dBounded_swt9
         :: GHC.Enum.Bounded
              (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
       [LclId, Str=DmdType]
       $dBounded_swt9 =
         case tup_swta
         of _ [Occ=Dead]
         { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_X1N
         };
       tup_swta
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_auHe
              frac2_auHg
              (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
              size2_auHh
              (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
       [LclId, Str=DmdType]
       tup_swta =
         case tup_avDN of _ [Occ=Dead] { (tpl_X1L, tpl_X1N, tpl_B3) ->
         tpl_X1N
         }; } in
     GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl_X24, tpl_B3) ->
        tpl_B3
        })
       (((letrec {
            $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
            [LclId, Str=DmdType]
            $dBits_swt2 =
              case tup_swt3
              of _ [Occ=Dead]
              { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B5
              };
            tup_swt3
              :: CLaSH.Sized.Fixed.ResizeFC
                   rep_auHe
                   frac1_auHd
                   (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                   size1_auHf
                   (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            [LclId, Str=DmdType]
            tup_swt3 =
              case tup_avDN of _ [Occ=Dead] { (tpl_X1Z, tpl_X21, tpl_B3) ->
              tpl_X1Z
              }; } in
          CLaSH.Sized.Fixed.resizeF
            @ frac1_auHd
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size1_auHf
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            ($dBounded_swt9,
             Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
             case tup_swt3
             of _ [Occ=Dead]
             { (tpl_X43, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B3
             },
             case tup_swt3
             of _ [Occ=Dead]
             { (tpl_X22, tpl_X46, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B4
             },
             $dBits_swt2,
             $dResize_swt7,
             $dKnownNat_swt6,
             case tup_swt3
             of _ [Occ=Dead]
             { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B8
             },
             $dBits_swt5,
             $dKnownNat_swt4,
             case tup_swt3
             of _ [Occ=Dead]
             { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bb
             },
             case tup_swt3
             of _ [Occ=Dead]
             { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bc
             }))
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 450 0}]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    (letrec {
       $dKnownNat_swsM
         :: GHC.TypeLits.KnownNat
              (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
       [LclId, Str=DmdType]
       $dKnownNat_swsM =
         case tup_swsS
         of _ [Occ=Dead]
         { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_Ba
         };
       $dBits_swsN
         :: Data.Bits.Bits
              (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
       [LclId, Str=DmdType]
       $dBits_swsN =
         case tup_swsS
         of _ [Occ=Dead]
         { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B9
         };
       $dKnownNat_swsO
         :: GHC.TypeLits.KnownNat
              (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
       [LclId, Str=DmdType]
       $dKnownNat_swsO =
         case tup_swsS
         of _ [Occ=Dead]
         { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         };
       $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
       [LclId, Str=DmdType]
       $dResize_swsP =
         case tup_swsS
         of _ [Occ=Dead]
         { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B6
         };
       $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
       [LclId, Str=DmdType]
       $dBits_swsQ =
         case tup_swsS
         of _ [Occ=Dead]
         { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B5
         };
       $dBounded_swsR
         :: GHC.Enum.Bounded
              (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
       [LclId, Str=DmdType]
       $dBounded_swsR =
         case tup_swsS
         of _ [Occ=Dead]
         { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_X1O
         };
       tup_swsS
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_auHe
              frac2_auHg
              (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
              size2_auHh
              (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
       [LclId, Str=DmdType]
       tup_swsS =
         case tup_avDN of _ [Occ=Dead] { (tpl_X1M, tpl_X1O, tpl_B3) ->
         tpl_X1O
         }; } in
     GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       (case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl_X25, tpl_B3) ->
        tpl_B3
        })
       (((letrec {
            $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
            [LclId, Str=DmdType]
            $dBits_swsK =
              case tup_swsL
              of _ [Occ=Dead]
              { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B5
              };
            tup_swsL
              :: CLaSH.Sized.Fixed.ResizeFC
                   rep_auHe
                   frac1_auHd
                   (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                   size1_auHf
                   (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            [LclId, Str=DmdType]
            tup_swsL =
              case tup_avDN of _ [Occ=Dead] { (tpl_X20, tpl_X22, tpl_B3) ->
              tpl_X20
              }; } in
          CLaSH.Sized.Fixed.resizeF
            @ frac1_auHd
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size1_auHf
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            ($dBounded_swsR,
             Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
             case tup_swsL
             of _ [Occ=Dead]
             { (tpl_X45, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B3
             },
             case tup_swsL
             of _ [Occ=Dead]
             { (tpl_X23, tpl_X48, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B4
             },
             $dBits_swsK,
             $dResize_swsP,
             $dKnownNat_swsO,
             case tup_swsL
             of _ [Occ=Dead]
             { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B8
             },
             $dBits_swsN,
             $dKnownNat_swsM,
             case tup_swsL
             of _ [Occ=Dead]
             { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bb
             },
             case tup_swsL
             of _ [Occ=Dead]
             { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bc
             }))
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B3
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0] 170 0}]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    (let {
       tup_swsA
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_auGZ
              (frac_auGY GHC.TypeLits.+ frac_auGY)
              frac_auGY
              (size_auH0 GHC.TypeLits.+ size_auH0)
              size_auH0
       [LclId, Str=DmdType]
       tup_swsA =
         case tup_avBm
         of _ [Occ=Dead]
         { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1N
         } } in
     Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       (case tup_swsA
        of _ [Occ=Dead]
        { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        })
       (GHC.Num.fromInteger
          @ (rep_auGZ size_auH0)
          (case tup_avBm
           of _ [Occ=Dead]
           { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B3
           })
          eta_X1I)
       (GHC.Num.$fNumInt_$cfromInteger
          (GHC.TypeLits.natVal
             @ frac_auGY
             @ Data.Proxy.Proxy
             (case tup_swsA
              of _ [Occ=Dead]
              { (tpl_X1M, tpl_X1O, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_Ba
              })
             (Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_auGY))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      (case tup_avBm
       of _ [Occ=Dead]
       { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       tpl_B3
       })
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))

$csignum_avDg
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$csignum_avDg =
  a_swkh
  `cast` (forall (frac_auGY :: GHC.TypeLits.Nat)
                 (rep_auGZ :: GHC.TypeLits.Nat -> *)
                 (size_auH0 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
          :: (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> rep_auGZ size_auH0)
               ~#
             (forall (frac_auGY :: GHC.TypeLits.Nat)
                     (rep_auGZ :: GHC.TypeLits.Nat -> *)
                     (size_auH0 :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
              CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
              -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0))

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 300 0}]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    (letrec {
       $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
       [LclId, Str=DmdType]
       $dKnownNat_swsx =
         case tup_swsy
         of _ [Occ=Dead]
         { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         };
       tup_swsy
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIL
              (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
              frac_XuIJ
              (size_XuIN GHC.TypeLits.+ size_XuIN)
              size_XuIN
       [LclId, Str=DmdType]
       tup_swsy =
         case tup_XvDa
         of _ [Occ=Dead]
         { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1V
         }; } in
     letrec {
       $dKnownNat_swsv
         :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
       [LclId, Str=DmdType]
       $dKnownNat_swsv =
         case tup_swsw
         of _ [Occ=Dead]
         { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
         tpl_B8
         };
       tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
       [LclId, Str=DmdType]
       tup_swsw =
         case tup_XvDa
         of _ [Occ=Dead]
         { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1X
         }; } in
     CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          (case tup_XvDa
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIL
             (case tup_swsy
              of _ [Occ=Dead]
              { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B6
              })
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 300 0}]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    (letrec {
       $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
       [LclId, Str=DmdType]
       $dKnownNat_swsp =
         case tup_swsq
         of _ [Occ=Dead]
         { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         };
       tup_swsq
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIM
              (frac_XuIK GHC.TypeLits.+ frac_XuIK)
              frac_XuIK
              (size_XuIO GHC.TypeLits.+ size_XuIO)
              size_XuIO
       [LclId, Str=DmdType]
       tup_swsq =
         case tup_XvDb
         of _ [Occ=Dead]
         { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1W
         }; } in
     letrec {
       $dKnownNat_swsn
         :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
       [LclId, Str=DmdType]
       $dKnownNat_swsn =
         case tup_swso
         of _ [Occ=Dead]
         { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
         tpl_B8
         };
       tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
       [LclId, Str=DmdType]
       tup_swso =
         case tup_XvDb
         of _ [Occ=Dead]
         { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1Y
         }; } in
     CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          (case tup_XvDb
           of _ [Occ=Dead]
           { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIM
             (case tup_swsq
              of _ [Occ=Dead]
              { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B6
              })
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 370 0}]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    (letrec {
       $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
       [LclId, Str=DmdType]
       $dKnownNat_swsg =
         case tup_swsi
         of _ [Occ=Dead]
         { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         };
       tup_swsi
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIN
              (frac_XuIL GHC.TypeLits.+ frac_XuIL)
              frac_XuIL
              (size_XuIP GHC.TypeLits.+ size_XuIP)
              size_XuIP
       [LclId, Str=DmdType]
       tup_swsi =
         case tup_XvDc
         of _ [Occ=Dead]
         { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1Y
         }; } in
     letrec {
       $dKnownNat_swse
         :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
       [LclId, Str=DmdType]
       $dKnownNat_swse =
         case tup_swsf
         of _ [Occ=Dead]
         { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
         tpl_B8
         };
       tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
       [LclId, Str=DmdType]
       tup_swsf =
         case tup_XvDc
         of _ [Occ=Dead]
         { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X22
         }; } in
     CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (let {
          $dResize_swsh :: CLaSH.Class.Num.Resize rep_XuIN
          [LclId, Str=DmdType]
          $dResize_swsh =
            case tup_swsi
            of _ [Occ=Dead]
            { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B6
            } } in
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          (case tup_XvDc
           of _ [Occ=Dead]
           { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_swsh
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))
          (CLaSH.Class.Num.resize
             @ rep_XuIN
             $dResize_swsh
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 270 0}]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    (letrec {
       $dBits_sws7
         :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       [LclId, Str=DmdType]
       $dBits_sws7 =
         case tup_sws8
         of _ [Occ=Dead]
         { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B5
         };
       tup_sws8
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIO
              (frac_XuIM GHC.TypeLits.+ frac_XuIM)
              frac_XuIM
              (size_XuIQ GHC.TypeLits.+ size_XuIQ)
              size_XuIQ
       [LclId, Str=DmdType]
       tup_sws8 =
         case tup_XvDd
         of _ [Occ=Dead]
         { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1Z
         }; } in
     CLaSH.Sized.Fixed.resizeF
       @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
       @ frac_XuIM
       @ rep_XuIO
       @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
       @ size_XuIQ
       (case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        Data.Bits.$p1Bits
          @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B3
        },
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B4
        },
        $dBits_sws7,
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        },
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        },
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        },
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        },
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        },
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Bb
        },
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Bc
        }))
      ((case case tup_XvDd
             of _ [Occ=Dead]
             { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
             tpl_B6
             }
        of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
        (CLaSH.Class.Num.mult
           @ (rep_XuIO size_XuIQ)
           @ (rep_XuIO size_XuIQ)
           (case tup_XvDd
            of _ [Occ=Dead]
            { (tpl_X23, tpl_X25, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
            tpl_B5
            })
           (eta_X1U
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ))
           (eta_X3N
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ)))
        `cast` (Sub cobox_dw1a
                :: CLaSH.Class.Num.MResult
                     (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                     ~#
                   rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
        })
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                          GHC.TypeLits.+ size_XuIQ>_N
               :: rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ)))

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 370 0}]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    (letrec {
       $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
       [LclId, Str=DmdType]
       $dKnownNat_sws2 =
         case tup_sws4
         of _ [Occ=Dead]
         { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         };
       tup_sws4
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIP
              (frac_XuIN GHC.TypeLits.+ frac_XuIN)
              frac_XuIN
              (size_XuIR GHC.TypeLits.+ size_XuIR)
              size_XuIR
       [LclId, Str=DmdType]
       tup_sws4 =
         case tup_XvDe
         of _ [Occ=Dead]
         { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X20
         }; } in
     letrec {
       $dKnownNat_sws0
         :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
       [LclId, Str=DmdType]
       $dKnownNat_sws0 =
         case tup_sws1
         of _ [Occ=Dead]
         { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
         tpl_B8
         };
       tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
       [LclId, Str=DmdType]
       tup_sws1 =
         case tup_XvDe
         of _ [Occ=Dead]
         { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X24
         }; } in
     CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (let {
          $dResize_sws3 :: CLaSH.Class.Num.Resize rep_XuIP
          [LclId, Str=DmdType]
          $dResize_sws3 =
            case tup_sws4
            of _ [Occ=Dead]
            { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B6
            } } in
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          (case tup_XvDe
           of _ [Occ=Dead]
           { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
           tpl_B4
           })
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_sws3
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))
          (CLaSH.Class.Num.resize
             @ rep_XuIP
             $dResize_sws3
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $csignum_avDg @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($csignum_avDg @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

a_swhq
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Vector.Vec
       (CLaSH.Class.BitVector.BitSize
          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
       CLaSH.Bit.Bit
     -> rep_auGU size_auGV
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhq =
  \ (@ (frac_auGT :: GHC.TypeLits.Nat))
    (@ (rep_auGU :: GHC.TypeLits.Nat -> *))
    (@ (size_auGV :: GHC.TypeLits.Nat))
    ($dBitVector_avAW
       :: CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV))
    ($dKnownNat_avBa
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)))
    (bv_auGX
       :: CLaSH.Sized.Vector.Vec
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
            CLaSH.Bit.Bit) ->
    CLaSH.Class.BitVector.fromBV
      @ (rep_auGU size_auGV)
      $dBitVector_avAW
      ($dKnownNat_avBa
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))))
      (bv_auGX
       `cast` ((CLaSH.Sized.Vector.Vec
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_auGT>_N <rep_auGU>_N <size_auGV>_N)
                  <CLaSH.Bit.Bit>_R)_R
               :: CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                    CLaSH.Bit.Bit
                    ~#
                  CLaSH.Sized.Vector.Vec
                    (CLaSH.Class.BitVector.BitSize (rep_auGU size_auGV))
                    CLaSH.Bit.Bit))

$cfromBV_avB8
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Vector.Vec
       (CLaSH.Class.BitVector.BitSize
          (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
       CLaSH.Bit.Bit
     -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cfromBV_avB8 =
  a_swhq
  `cast` (forall (frac_auGT :: GHC.TypeLits.Nat)
                 (rep_auGU :: GHC.TypeLits.Nat -> *)
                 (size_auGV :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))>_R
          -> <CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGT>_P <rep_auGU>_R) <size_auGV>_N
          :: (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> rep_auGU size_auGV)
               ~#
             (forall (frac_auGT :: GHC.TypeLits.Nat)
                     (rep_auGU :: GHC.TypeLits.Nat -> *)
                     (size_auGV :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
              CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
                CLaSH.Bit.Bit
              -> CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))

a_swhr
  :: forall (frac_XuIF :: GHC.TypeLits.Nat)
            (rep_XuIH :: GHC.TypeLits.Nat -> *)
            (size_XuIJ :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
     CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
     -> CLaSH.Sized.Vector.Vec
          (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ)) CLaSH.Bit.Bit
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhr =
  \ (@ (frac_XuIF :: GHC.TypeLits.Nat))
    (@ (rep_XuIH :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIJ :: GHC.TypeLits.Nat))
    ($dBitVector_XvCL
       :: CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ))
    ($dKnownNat_avB0
       :: GHC.TypeLits.KnownNat
            (CLaSH.Class.BitVector.BitSize
               (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ)))
    (ds_dw0H
       :: CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ) ->
    CLaSH.Class.BitVector.toBV
      @ (rep_XuIH size_XuIJ)
      $dBitVector_XvCL
      ($dKnownNat_avB0
       `cast` ((GHC.TypeLits.KnownNat
                  (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                     <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))_R
               :: GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize
                       (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                    ~#
                  GHC.TypeLits.KnownNat
                    (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ))))
      (ds_dw0H
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIF>_P <rep_XuIH>_R <size_XuIJ>_N
               :: CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
                    ~#
                  rep_XuIH size_XuIJ))

$ctoBV_avAY
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     (CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV),
      GHC.TypeLits.KnownNat
        (CLaSH.Class.BitVector.BitSize
           (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))) =>
     CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV
     -> CLaSH.Sized.Vector.Vec
          (CLaSH.Class.BitVector.BitSize
             (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV))
          CLaSH.Bit.Bit
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$ctoBV_avAY =
  a_swhr
  `cast` (forall (frac_XuIF :: GHC.TypeLits.Nat)
                 (rep_XuIH :: GHC.TypeLits.Nat -> *)
                 (size_XuIJ :: GHC.TypeLits.Nat).
          <CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ)>_R
          -> <GHC.TypeLits.KnownNat
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ>_R
          -> (CLaSH.Sized.Vector.Vec
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                      <frac_XuIF>_N <rep_XuIH>_N <size_XuIJ>_N))
                <CLaSH.Bit.Bit>_R)_R
          :: (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize (rep_XuIH size_XuIJ)) CLaSH.Bit.Bit)
               ~#
             (forall (frac_XuIF :: GHC.TypeLits.Nat)
                     (rep_XuIH :: GHC.TypeLits.Nat -> *)
                     (size_XuIJ :: GHC.TypeLits.Nat).
              (CLaSH.Class.BitVector.BitVector (rep_XuIH size_XuIJ),
               GHC.TypeLits.KnownNat
                 (CLaSH.Class.BitVector.BitSize
                    (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ
              -> CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIF rep_XuIH size_XuIJ))
                   CLaSH.Bit.Bit))

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         $ctoBV_avAY
                                           @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT
                                         $cfromBV_avB8
                                           @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ($ctoBV_avAY @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)
      ($cfromBV_avB8 @ frac_XuIN @ rep_XuIP @ size_XuIR $dBitVector_XvCT)

a_swhs
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhs =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    Data.Default.Class.def @ (rep_auGM size_auGN) $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cdef_avAg =
  a_swhs
  `cast` (forall (frac_auGL :: GHC.TypeLits.Nat)
                 (rep_auGM :: GHC.TypeLits.Nat -> *)
                 (size_auGN :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_auGM size_auGN)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGL>_P <rep_auGM>_R) <size_auGN>_N
          :: (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              rep_auGM size_auGN)
               ~#
             (forall (frac_auGL :: GHC.TypeLits.Nat)
                     (rep_auGM :: GHC.TypeLits.Nat -> *)
                     (size_auGN :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_auGM size_auGN) =>
              CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  $cdef_avAg
  `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                 (rep_XuIO :: GHC.TypeLits.Nat -> *)
                 (size_XuIQ :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
          -> Sym
               (Data.Default.Class.NTCo:Default[0]
                  <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
          :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
               ~#
             (forall (frac_XuIM :: GHC.TypeLits.Nat)
                     (rep_XuIO :: GHC.TypeLits.Nat -> *)
                     (size_XuIQ :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))

a_swht
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swht =
  \ (@ (frac_auGI :: GHC.TypeLits.Nat))
    (@ (rep_auGJ :: GHC.TypeLits.Nat -> *))
    (@ (size_auGK :: GHC.TypeLits.Nat))
    ($dBounded_avzT :: GHC.Enum.Bounded (rep_auGJ size_auGK)) ->
    GHC.Enum.maxBound @ (rep_auGJ size_auGK) $dBounded_avzT

$cmaxBound_avA4
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmaxBound_avA4 =
  a_swht
  `cast` (forall (frac_auGI :: GHC.TypeLits.Nat)
                 (rep_auGJ :: GHC.TypeLits.Nat -> *)
                 (size_auGK :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_auGJ size_auGK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auGI>_P <rep_auGJ>_R) <size_auGK>_N
          :: (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              rep_auGJ size_auGK)
               ~#
             (forall (frac_auGI :: GHC.TypeLits.Nat)
                     (rep_auGJ :: GHC.TypeLits.Nat -> *)
                     (size_auGK :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_auGJ size_auGK) =>
              CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK))

a_swhu
  :: forall (frac_XuIQ :: GHC.TypeLits.Nat)
            (rep_XuIS :: GHC.TypeLits.Nat -> *)
            (size_XuIU :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
     rep_XuIS size_XuIU
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhu =
  \ (@ (frac_XuIQ :: GHC.TypeLits.Nat))
    (@ (rep_XuIS :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIU :: GHC.TypeLits.Nat))
    ($dBounded_XvC4 :: GHC.Enum.Bounded (rep_XuIS size_XuIU)) ->
    GHC.Enum.minBound @ (rep_XuIS size_XuIU) $dBounded_XvC4

$cminBound_avzV
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cminBound_avzV =
  a_swhu
  `cast` (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                 (rep_XuIS :: GHC.TypeLits.Nat -> *)
                 (size_XuIU :: GHC.TypeLits.Nat).
          <GHC.Enum.Bounded (rep_XuIS size_XuIU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIQ>_P <rep_XuIS>_R) <size_XuIU>_N
          :: (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              rep_XuIS size_XuIU)
               ~#
             (forall (frac_XuIQ :: GHC.TypeLits.Nat)
                     (rep_XuIS :: GHC.TypeLits.Nat -> *)
                     (size_XuIU :: GHC.TypeLits.Nat).
              GHC.Enum.Bounded (rep_XuIS size_XuIU) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIQ rep_XuIS size_XuIU))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          $cminBound_avzV @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa
                          $cmaxBound_avA4 @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ($cminBound_avzV @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)
      ($cmaxBound_avA4 @ frac_XuIW @ rep_XuIY @ size_XuJ0 $dBounded_XvCa)

a_swlr
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swlr =
  \ (@ (frac_auFF :: GHC.TypeLits.Nat))
    (@ (rep_auFG :: GHC.TypeLits.Nat -> *))
    (@ (size_auFH :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_avyb :: GHC.Classes.Ord (rep_auFG size_auFH)) ->
    GHC.Classes.min @ (rep_auFG size_auFH) $dOrd_avyb

$cmin_avzC
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmin_avzC =
  a_swlr
  `cast` (forall (frac_auFF :: GHC.TypeLits.Nat)
                 (rep_auFG :: GHC.TypeLits.Nat -> *)
                 (size_auFH :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)>_R
          -> <GHC.Classes.Ord (rep_auFG size_auFH)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_auFF>_P <rep_auFG>_R) <size_auFH>_N
          :: (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              rep_auFG size_auFH -> rep_auFG size_auFH -> rep_auFG size_auFH)
               ~#
             (forall (frac_auFF :: GHC.TypeLits.Nat)
                     (rep_auFG :: GHC.TypeLits.Nat -> *)
                     (size_auFH :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
               GHC.Classes.Ord (rep_auFG size_auFH)) =>
              CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
              -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH))

a_swls
  :: forall (frac_XuHQ :: GHC.TypeLits.Nat)
            (rep_XuHS :: GHC.TypeLits.Nat -> *)
            (size_XuHU :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
      GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
     rep_XuHS size_XuHU -> rep_XuHS size_XuHU -> rep_XuHS size_XuHU
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swls =
  \ (@ (frac_XuHQ :: GHC.TypeLits.Nat))
    (@ (rep_XuHS :: GHC.TypeLits.Nat -> *))
    (@ (size_XuHU :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAq :: GHC.Classes.Ord (rep_XuHS size_XuHU)) ->
    GHC.Classes.max @ (rep_XuHS size_XuHU) $dOrd_XvAq

$cmax_avzm
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmax_avzm =
  a_swls
  `cast` (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                 (rep_XuHS :: GHC.TypeLits.Nat -> *)
                 (size_XuHU :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU)>_R
          -> <GHC.Classes.Ord (rep_XuHS size_XuHU)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHQ>_P <rep_XuHS>_R) <size_XuHU>_N
          :: (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              rep_XuHS size_XuHU -> rep_XuHS size_XuHU -> rep_XuHS size_XuHU)
               ~#
             (forall (frac_XuHQ :: GHC.TypeLits.Nat)
                     (rep_XuHS :: GHC.TypeLits.Nat -> *)
                     (size_XuHU :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU),
               GHC.Classes.Ord (rep_XuHS size_XuHU)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU
              -> CLaSH.Sized.Fixed.Fixed frac_XuHQ rep_XuHS size_XuHU))

a_swhz
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     rep_auFG size_auFH -> rep_auFG size_auFH -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhz =
  \ (@ (frac_XuHX :: GHC.TypeLits.Nat))
    (@ (rep_XuHZ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuI1 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAx :: GHC.Classes.Ord (rep_XuHZ size_XuI1)) ->
    GHC.Classes.<= @ (rep_XuHZ size_XuI1) $dOrd_XvAx

$c<=_avz8
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c<=_avz8 =
  a_swhz
  `cast` (forall (frac_XuHY :: GHC.TypeLits.Nat)
                 (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                 (size_XuI2 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2)>_R
          -> <GHC.Classes.Ord (rep_XuI0 size_XuI2)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuHY>_P <rep_XuI0>_R) <size_XuI2>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              rep_XuI0 size_XuI2 -> rep_XuI0 size_XuI2 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuHY :: GHC.TypeLits.Nat)
                     (rep_XuI0 :: GHC.TypeLits.Nat -> *)
                     (size_XuI2 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2),
               GHC.Classes.Ord (rep_XuI0 size_XuI2)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> CLaSH.Sized.Fixed.Fixed frac_XuHY rep_XuI0 size_XuI2
              -> GHC.Types.Bool))

a_swhA
  :: forall (frac_XuI3 :: GHC.TypeLits.Nat)
            (rep_XuI5 :: GHC.TypeLits.Nat -> *)
            (size_XuI7 :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
      GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
     rep_XuI5 size_XuI7 -> rep_XuI5 size_XuI7 -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhA =
  \ (@ (frac_XuI3 :: GHC.TypeLits.Nat))
    (@ (rep_XuI5 :: GHC.TypeLits.Nat -> *))
    (@ (size_XuI7 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAD :: GHC.Classes.Ord (rep_XuI5 size_XuI7)) ->
    GHC.Classes.> @ (rep_XuI5 size_XuI7) $dOrd_XvAD

$c>_avyU
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c>_avyU =
  a_swhA
  `cast` (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                 (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                 (size_XuI7 :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7)>_R
          -> <GHC.Classes.Ord (rep_XuI5 size_XuI7)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuI3>_P <rep_XuI5>_R) <size_XuI7>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              rep_XuI5 size_XuI7 -> rep_XuI5 size_XuI7 -> GHC.Types.Bool)
               ~#
             (forall (frac_XuI3 :: GHC.TypeLits.Nat)
                     (rep_XuI5 :: GHC.TypeLits.Nat -> *)
                     (size_XuI7 :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7),
               GHC.Classes.Ord (rep_XuI5 size_XuI7)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> CLaSH.Sized.Fixed.Fixed frac_XuI3 rep_XuI5 size_XuI7
              -> GHC.Types.Bool))

a_swhB
  :: forall (frac_XuIa :: GHC.TypeLits.Nat)
            (rep_XuIc :: GHC.TypeLits.Nat -> *)
            (size_XuIe :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
      GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
     rep_XuIc size_XuIe -> rep_XuIc size_XuIe -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhB =
  \ (@ (frac_XuIa :: GHC.TypeLits.Nat))
    (@ (rep_XuIc :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIe :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAK :: GHC.Classes.Ord (rep_XuIc size_XuIe)) ->
    GHC.Classes.>= @ (rep_XuIc size_XuIe) $dOrd_XvAK

$c>=_avyG
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c>=_avyG =
  a_swhB
  `cast` (forall (frac_XuIa :: GHC.TypeLits.Nat)
                 (rep_XuIc :: GHC.TypeLits.Nat -> *)
                 (size_XuIe :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe)>_R
          -> <GHC.Classes.Ord (rep_XuIc size_XuIe)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIa>_P <rep_XuIc>_R) <size_XuIe>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              rep_XuIc size_XuIe -> rep_XuIc size_XuIe -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIa :: GHC.TypeLits.Nat)
                     (rep_XuIc :: GHC.TypeLits.Nat -> *)
                     (size_XuIe :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe),
               GHC.Classes.Ord (rep_XuIc size_XuIe)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> CLaSH.Sized.Fixed.Fixed frac_XuIa rep_XuIc size_XuIe
              -> GHC.Types.Bool))

a_swhC
  :: forall (frac_XuIh :: GHC.TypeLits.Nat)
            (rep_XuIj :: GHC.TypeLits.Nat -> *)
            (size_XuIl :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
      GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
     rep_XuIj size_XuIl -> rep_XuIj size_XuIl -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhC =
  \ (@ (frac_XuIh :: GHC.TypeLits.Nat))
    (@ (rep_XuIj :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIl :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAR :: GHC.Classes.Ord (rep_XuIj size_XuIl)) ->
    GHC.Classes.< @ (rep_XuIj size_XuIl) $dOrd_XvAR

$c<_avys
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c<_avys =
  a_swhC
  `cast` (forall (frac_XuIh :: GHC.TypeLits.Nat)
                 (rep_XuIj :: GHC.TypeLits.Nat -> *)
                 (size_XuIl :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl)>_R
          -> <GHC.Classes.Ord (rep_XuIj size_XuIl)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIh>_P <rep_XuIj>_R) <size_XuIl>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              rep_XuIj size_XuIl -> rep_XuIj size_XuIl -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIh :: GHC.TypeLits.Nat)
                     (rep_XuIj :: GHC.TypeLits.Nat -> *)
                     (size_XuIl :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl),
               GHC.Classes.Ord (rep_XuIj size_XuIl)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> CLaSH.Sized.Fixed.Fixed frac_XuIh rep_XuIj size_XuIl
              -> GHC.Types.Bool))

a_swhD
  :: forall (frac_XuIo :: GHC.TypeLits.Nat)
            (rep_XuIq :: GHC.TypeLits.Nat -> *)
            (size_XuIs :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
      GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
     rep_XuIq size_XuIs -> rep_XuIq size_XuIs -> GHC.Types.Ordering
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhD =
  \ (@ (frac_XuIo :: GHC.TypeLits.Nat))
    (@ (rep_XuIq :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIs :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    ($dOrd_XvAY :: GHC.Classes.Ord (rep_XuIq size_XuIs)) ->
    GHC.Classes.compare @ (rep_XuIq size_XuIs) $dOrd_XvAY

$ccompare_avye
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Ordering
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$ccompare_avye =
  a_swhD
  `cast` (forall (frac_XuIo :: GHC.TypeLits.Nat)
                 (rep_XuIq :: GHC.TypeLits.Nat -> *)
                 (size_XuIs :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq
             (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs)>_R
          -> <GHC.Classes.Ord (rep_XuIq size_XuIs)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIo>_P <rep_XuIq>_R) <size_XuIs>_N
          -> <GHC.Types.Ordering>_R
          :: (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              rep_XuIq size_XuIs -> rep_XuIq size_XuIs -> GHC.Types.Ordering)
               ~#
             (forall (frac_XuIo :: GHC.TypeLits.Nat)
                     (rep_XuIq :: GHC.TypeLits.Nat -> *)
                     (size_XuIs :: GHC.TypeLits.Nat).
              (GHC.Classes.Eq
                 (CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs),
               GHC.Classes.Ord (rep_XuIq size_XuIs)) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> CLaSH.Sized.Fixed.Fixed frac_XuIo rep_XuIq size_XuIs
              -> GHC.Types.Ordering))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         $ccompare_avye
                           @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c<_avys @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c>=_avyG @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c>_avyU @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $c<=_avz8 @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $cmax_avzm @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5
                         $cmin_avzC @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ($ccompare_avye
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<_avys @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>=_avyG @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c>_avyU @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($c<=_avz8 @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmax_avzm
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)
      ($cmin_avzC
         @ frac_XuIv @ rep_XuIx @ size_XuIz $dEq_XvB3 $dOrd_XvB5)

a_swhE
  :: forall (frac_XuIw :: GHC.TypeLits.Nat)
            (rep_XuIy :: GHC.TypeLits.Nat -> *)
            (size_XuIA :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_XuIy size_XuIA) =>
     rep_XuIy size_XuIA -> rep_XuIy size_XuIA -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhE =
  \ (@ (frac_XuIw :: GHC.TypeLits.Nat))
    (@ (rep_XuIy :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIA :: GHC.TypeLits.Nat))
    ($dEq_avxF :: GHC.Classes.Eq (rep_XuIy size_XuIA)) ->
    GHC.Classes./= @ (rep_XuIy size_XuIA) $dEq_avxF

$c/=_avxV
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c/=_avxV =
  a_swhE
  `cast` (forall (frac_XuIw :: GHC.TypeLits.Nat)
                 (rep_XuIy :: GHC.TypeLits.Nat -> *)
                 (size_XuIA :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIy size_XuIA)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIw>_P <rep_XuIy>_R) <size_XuIA>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              rep_XuIy size_XuIA -> rep_XuIy size_XuIA -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIw :: GHC.TypeLits.Nat)
                     (rep_XuIy :: GHC.TypeLits.Nat -> *)
                     (size_XuIA :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIy size_XuIA) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> CLaSH.Sized.Fixed.Fixed frac_XuIw rep_XuIy size_XuIA
              -> GHC.Types.Bool))

a_swhF
  :: forall (frac_XuIC :: GHC.TypeLits.Nat)
            (rep_XuIE :: GHC.TypeLits.Nat -> *)
            (size_XuIG :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_XuIE size_XuIG) =>
     rep_XuIE size_XuIG -> rep_XuIE size_XuIG -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swhF =
  \ (@ (frac_XuIC :: GHC.TypeLits.Nat))
    (@ (rep_XuIE :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIG :: GHC.TypeLits.Nat))
    ($dEq_XvAF :: GHC.Classes.Eq (rep_XuIE size_XuIG)) ->
    GHC.Classes.== @ (rep_XuIE size_XuIG) $dEq_XvAF

$c==_avxH
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$c==_avxH =
  a_swhF
  `cast` (forall (frac_XuIC :: GHC.TypeLits.Nat)
                 (rep_XuIE :: GHC.TypeLits.Nat -> *)
                 (size_XuIG :: GHC.TypeLits.Nat).
          <GHC.Classes.Eq (rep_XuIE size_XuIG)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_XuIC>_P <rep_XuIE>_R) <size_XuIG>_N
          -> <GHC.Types.Bool>_R
          :: (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              rep_XuIE size_XuIG -> rep_XuIE size_XuIG -> GHC.Types.Bool)
               ~#
             (forall (frac_XuIC :: GHC.TypeLits.Nat)
                     (rep_XuIE :: GHC.TypeLits.Nat -> *)
                     (size_XuIG :: GHC.TypeLits.Nat).
              GHC.Classes.Eq (rep_XuIE size_XuIG) =>
              CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> CLaSH.Sized.Fixed.Fixed frac_XuIC rep_XuIE size_XuIG
              -> GHC.Types.Bool))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        $c==_avxH @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL
                        $c/=_avxV @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ($c==_avxH @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)
      ($c/=_avxV @ frac_XuII @ rep_XuIK @ size_XuIM $dEq_XvAL)

lvl_swwb
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwb =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#

lvl_swwc :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwc = GHC.Base.build @ GHC.Types.Char lvl_swwb

lvl_swwd
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwd =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#

lvl_swwe :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwe = GHC.Base.build @ GHC.Types.Char lvl_swwd

lvl_swwf
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwf =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#

lvl_swwg :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwg = GHC.Base.build @ GHC.Types.Char lvl_swwf

lvl_swwh :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swwh =
  Language.Haskell.TH.Syntax.mkNameG_d lvl_swwc lvl_swwe lvl_swwg

lvl_swwi :: Language.Haskell.TH.Lib.ExpQ
[LclId, Str=DmdType]
lvl_swwi = Language.Haskell.TH.Lib.conE lvl_swwh

lvl_swwj
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwj =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#

lvl_swwk :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwk = GHC.Base.build @ GHC.Types.Char lvl_swwj

lvl_swwl
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwl =
  \ (@ b_a4Iy) ->
    GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#

lvl_swwm :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwm = GHC.Base.build @ GHC.Types.Char lvl_swwl

lvl_swwn
  :: forall b_a4Iy.
     (GHC.Types.Char -> b_a4Iy -> b_a4Iy) -> b_a4Iy -> b_a4Iy
[LclId, Str=DmdType]
lvl_swwn =
  \ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#

lvl_swwo :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_swwo = GHC.Base.build @ GHC.Types.Char lvl_swwn

lvl_swwp :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swwp =
  Language.Haskell.TH.Syntax.mkNameG_tc lvl_swwk lvl_swwm lvl_swwo

lvl_swwq :: Language.Haskell.TH.Lib.TypeQ
[LclId, Str=DmdType]
lvl_swwq = Language.Haskell.TH.Lib.conT lvl_swwp

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$clift_avAv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    Language.Haskell.TH.Lib.sigE
      (Language.Haskell.TH.Lib.appE
         lvl_swwi
         (Language.Haskell.TH.Syntax.lift
            @ (rep_auGP size_auGQ)
            $dLift_avAq
            (f_auGR
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                          ~#
                        rep_auGP size_auGQ))))
      (GHC.List.foldl
         @ Language.Haskell.TH.Lib.TypeQ
         @ Language.Haskell.TH.Lib.TypeQ
         Language.Haskell.TH.Lib.appT
         lvl_swwq
         (GHC.Base.build
            @ Language.Haskell.TH.Lib.TypeQ
            (\ (@ a_dvZ6)
               (c_dvZ7 [OS=OneShot]
                  :: Language.Haskell.TH.Lib.TypeQ -> a_dvZ6 -> a_dvZ6)
               (n_dvZ8 [OS=OneShot] :: a_dvZ6) ->
               c_dvZ7
                 (Language.Haskell.TH.Lib.litT
                    (Language.Haskell.TH.Lib.numTyLit
                       (GHC.TypeLits.natVal
                          @ frac_auGO
                          @ Data.Proxy.Proxy
                          $dKnownNat_avAr
                          (CLaSH.Sized.Fixed.asFracProxy
                             @ frac_auGO @ rep_auGP @ size_auGQ f_auGR))))
                 (c_dvZ7
                    (Language.Haskell.TH.Lib.conT
                       (Language.Haskell.TH.Syntax.mkName
                          (Data.Typeable.Internal.$fShowTypeRep_$cshow
                             (Data.Typeable.Internal.typeRep
                                @ (GHC.TypeLits.Nat -> *)
                                @ Data.Proxy.Proxy
                                @ rep_auGP
                                $dTypeable_avAt
                                (CLaSH.Sized.Fixed.asRepProxy
                                   @ frac_auGO @ rep_auGP @ size_auGQ f_auGR)))))
                    (c_dvZ7
                       (Language.Haskell.TH.Lib.litT
                          (Language.Haskell.TH.Lib.numTyLit
                             (GHC.TypeLits.natVal
                                @ size_auGQ
                                @ (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP)
                                $dKnownNat_avAs
                                f_auGR)))
                       n_dvZ8)))))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                              (rep_auGP :: GHC.TypeLits.Nat -> *)
                              (size_auGQ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
                       -> <GHC.TypeLits.KnownNat frac_auGO>_R
                       -> <GHC.TypeLits.KnownNat size_auGQ>_R
                       -> <Data.Typeable.Internal.Typeable rep_auGP>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_N)
                       :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                                  (rep_auGP :: GHC.TypeLits.Nat -> *)
                                  (size_auGQ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
                            GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
                            Data.Typeable.Internal.Typeable rep_auGP) =>
                           CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_auGO :: GHC.TypeLits.Nat)
                                  (rep_auGP :: GHC.TypeLits.Nat -> *)
                                  (size_auGQ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
                            GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
                            Data.Typeable.Internal.Typeable rep_auGP) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  $clift_avAv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                  <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Simplifier:
SimplBind [lvl_swvf{v} [lid]]
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swvd{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swvb{v} [lid]]
SimplBind [lvl_swv9{v} [lid]]
SimplBind [lvl_swv7{v} [lid]]
SimplBind [lvl_swv5{v} [lid]]
SimplBind [lvl_swv3{v} [lid]]
SimplBind [lvl_swv1{v} [lid]]
SimplBind [lvl_swuZ{v} [lid]]
SimplBind [$dReal2{v swuT} [lid]]
SimplBind [a2{v swuU} [lid]]
SimplBind [$dEq1{v swuV} [lid]]
SimplBind [$dNum3{v swuW} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuR{v} [lid]]
SimplBind [$dReal1{v swuL} [lid]]
SimplBind [a1{v swuM} [lid]]
SimplBind [$dEq{v swuN} [lid]]
SimplBind [$dNum2{v swuO} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuJ{v} [lid]]
SimplBind [lvl_swuG{v} [lid]]
SimplBind [$dReal{v swuD} [lid]]
SimplBind [$dNum1{v swuE} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$dOrd{v swuF} [lid]]
SimplBind [lvl_swuI{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [lvl_swvi{v} [lid]]
SimplBind [lvl_swvj{v} [lid]]
SimplBind [lvl_swvk{v} [lid]]
SimplBind [lvl_swvl{v} [lid]]
SimplBind [lvl_swvm{v} [lid]]
SimplBind [lvl_swvn{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [lvl_swvp{v} [lid]]
SimplBind [lvl_swvq{v} [lid]]
SimplBind [lvl_swvr{v} [lid]]
SimplBind [lvl_swvs{v} [lid]]
SimplBind [lvl_swvt{v} [lid]]
SimplBind [lvl_swvu{v} [lid]]
SimplBind [lvl_swvv{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [lvl_swvx{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvE{v} [lid]]
SimplBind [lvl_swvF{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [lvl_swvH{v} [lid]]
SimplBind [lvl_swvI{v} [lid]]
SimplBind [lvl_swvJ{v} [lid]]
SimplBind [lvl_swvK{v} [lid]]
SimplBind [lvl_swvL{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [lvl_swvN{v} [lid]]
SimplBind [lvl_swvO{v} [lid]]
SimplBind [lvl_swvP{v} [lid]]
SimplBind [lvl_swvQ{v} [lid]]
SimplBind [lvl_swvR{v} [lid]]
SimplBind [lvl_swvS{v} [lid]]
SimplBind [ds_swvT{v} [lid]]
SimplBind [lvl_swvU{v} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvW{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_swvY{v} [lid]]
SimplBind [lvl_swvZ{v} [lid]]
SimplBind [lvl_sww0{v} [lid]]
SimplBind [lvl_sww1{v} [lid]]
SimplBind [lvl_sww2{v} [lid]]
SimplBind [lvl_sww3{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]],
     $cshowList{v avIE} [lid]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$csignum{v avDg} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind [a_swhq{v} [lid]]
SimplBind [$cfromBV{v avB8} [lid]]
SimplBind [a_swhr{v} [lid]]
SimplBind [$ctoBV{v avAY} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swhs{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind [a_swht{v} [lid]]
SimplBind [$cmaxBound{v avA4} [lid]]
SimplBind [a_swhu{v} [lid]]
SimplBind [$cminBound{v avzV} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind [a_swlr{v} [lid]]
SimplBind [$cmin{v avzC} [lid]]
SimplBind [a_swls{v} [lid]]
SimplBind [$cmax{v avzm} [lid]]
SimplBind [a_swhz{v} [lid]]
SimplBind [$c<={v avz8} [lid]]
SimplBind [a_swhA{v} [lid]]
SimplBind [$c>{v avyU} [lid]]
SimplBind [a_swhB{v} [lid]]
SimplBind [$c>={v avyG} [lid]]
SimplBind [a_swhC{v} [lid]]
SimplBind [$c<{v avys} [lid]]
SimplBind [a_swhD{v} [lid]]
SimplBind [$ccompare{v avye} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind [a_swhE{v} [lid]]
SimplBind [$c/={v avxV} [lid]]
SimplBind [a_swhF{v} [lid]]
SimplBind [$c=={v avxH} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [lvl_swwb{v} [lid]]
SimplBind [lvl_swwc{v} [lid]]
SimplBind [lvl_swwd{v} [lid]]
SimplBind [lvl_swwe{v} [lid]]
SimplBind [lvl_swwf{v} [lid]]
SimplBind [lvl_swwg{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [lvl_swwi{v} [lid]]
SimplBind [lvl_swwj{v} [lid]]
SimplBind [lvl_swwk{v} [lid]]
SimplBind [lvl_swwl{v} [lid]]
SimplBind [lvl_swwm{v} [lid]]
SimplBind [lvl_swwn{v} [lid]]
SimplBind [lvl_swwo{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [lvl_swwq{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=1
  = {terms: 2,381, types: 10,754, coercions: 1,806}
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swwY{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [a_swx6{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvF{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [lvl_swvH{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [lvl_swvQ{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [ds_swvT{v} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sww1{v} [lid]]
SimplBind [lvl_sww3{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swC6{v} [lid]]
SimplBind [a_swC9{v} [lid]]
SimplBind [a_swCb{v} [lid]]
SimplBind [a_swC7{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [a_swCc{v} [lid]]
SimplBind [a_swCe{v} [lid]]
SimplBind [a_swCh{v} [lid]]
SimplBind [a_swCj{v} [lid]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=2
  = {terms: 2,007, types: 9,355, coercions: 962}
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swwY{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [a_swx6{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvF{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [lvl_swvQ{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [ds_swvT{v} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swC6{v} [lid]]
SimplBind [a_swC9{v} [lid]]
SimplBind [a_swCb{v} [lid]]
SimplBind [a_swC7{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [a_swCc{v} [lid]]
SimplBind [a_swCe{v} [lid]]
SimplBind [a_swCh{v} [lid]]
SimplBind [a_swCj{v} [lid]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=3
  = {terms: 2,005, types: 9,350, coercions: 962}
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swwY{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [a_swx6{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvF{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [lvl_swvQ{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [ds_swvT{v} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swC6{v} [lid]]
SimplBind [a_swC9{v} [lid]]
SimplBind [a_swCb{v} [lid]]
SimplBind [a_swC7{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [a_swCc{v} [lid]]
SimplBind [a_swCe{v} [lid]]
SimplBind [a_swCh{v} [lid]]
SimplBind [a_swCj{v} [lid]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]

==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 2 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 2,005, types: 9,350, coercions: 962}

lvl_swvg :: GHC.Types.Double
[LclId, Str=DmdType b]
lvl_swvg =
  GHC.Err.error
    @ GHC.Types.Double
    (GHC.Base.build
       @ GHC.Types.Char
       (\ (@ b_a4Iy) ->
          GHC.CString.unpackFoldrCString# @ b_a4Iy "Negative exponent"#))

lvl_swve :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swve = GHC.Types.D# 1.0

lvl_swv0 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv0 = __integer 1

lvl_swv2 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv2 = __integer 1

lvl_swv4 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv4 = __integer 2

lvl_swv6 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv6 = __integer 2

Rec {
g1_swuY [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 442 0}]
g1_swuY =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP :: GHC.Types.Double) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y1_akDO GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y1_akDO lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x1_akDN x1_akDN)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y1_akDO lvl_swv2) lvl_swv4)
              (GHC.Float.timesDouble x1_akDN z_akDP);
          GHC.Types.True -> GHC.Float.timesDouble x1_akDN z_akDP
        }
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Float.timesDouble x1_akDN x1_akDN)
          (GHC.Integer.Type.quotInteger y1_akDO lvl_swv6)
          z_akDP
    }
    }
end Rec }

lvl_swuS :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuS = __integer 1

lvl_swv8 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv8 = __integer 1

lvl_swva :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swva = __integer 2

lvl_swvc :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvc = __integer 2

Rec {
f_swuQ [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 372 0}]
f_swuQ =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y_akDB GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y_akDB lvl_swuS
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x_akDA x_akDA)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y_akDB lvl_swv8) lvl_swva)
              x_akDA;
          GHC.Types.True -> x_akDA
        }
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Float.timesDouble x_akDA x_akDA)
          (GHC.Integer.Type.quotInteger y_akDB lvl_swvc)
    }
    }
end Rec }

lvl_swuH :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuH = __integer 0

lvl_swuK :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuK = __integer 0

$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 152 0}]
$s^_swu6 =
  \ (eta_akDk :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger# eta1_akDl lvl_swuH
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# eta1_akDl lvl_swuK
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        }
        };
      GHC.Types.True -> lvl_swvg
    }
    }

lvl_swvh :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvh = GHC.Types.D# 2.0

a_swwS :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 40}]
a_swwS =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#)

a_swwV :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 40}]
a_swwV =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) ->
       GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#)

a_swwX :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 40}]
a_swwX =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) ->
       GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#)

a_swwT :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swwT =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvo :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvo =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swwT

a_swwY
  :: forall (m_afx5 :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_afx5 =>
     m_afx5 Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swwY =
  \ (@ (m_afx5 :: * -> *))
    (eta_afx6 :: Language.Haskell.TH.Syntax.Quasi m_afx5) ->
    GHC.Base.return
      @ m_afx5
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_afx5 eta_afx6)
      @ Language.Haskell.TH.Syntax.Exp
      (Language.Haskell.TH.Syntax.ConE lvl_swvo)

a_swx0 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 60 40}]
a_swx0 =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) ->
       GHC.CString.unpackFoldrCString# @ b_a4Iy "fromInteger"#)

a_swx3 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 40 40}]
a_swx3 =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "base"#)

a_swx5 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 40}]
a_swx5 =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) ->
       GHC.CString.unpackFoldrCString# @ b_a4Iy "GHC.Num"#)

a_swx1 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swx1 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (a_swx3
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swx5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvw :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvw =
  Language.Haskell.TH.Syntax.Name
    (a_swx0
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swx1

a_swx6
  :: forall (m_a5ye :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a5ye =>
     m_a5ye Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swx6 =
  \ (@ (m_a5ye :: * -> *))
    (eta_a5yf :: Language.Haskell.TH.Syntax.Quasi m_a5ye) ->
    GHC.Base.return
      @ m_a5ye
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a5ye eta_a5yf)
      @ Language.Haskell.TH.Syntax.Exp
      (Language.Haskell.TH.Syntax.VarE lvl_swvw)

a_swxS
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
a_swxS =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    Language.Haskell.TH.Syntax.unsafeTExpCoerce1
      @ (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)
      ((Language.Haskell.TH.Lib.appE1
          (a_swwY
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Exp)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))
          ((Language.Haskell.TH.Lib.appE1
              (a_swx6
               `cast` (Sym
                         (Language.Haskell.TH.Syntax.NTCo:Q[0]
                            <Language.Haskell.TH.Syntax.Exp>_N)
                       :: (forall (m_a4LE :: * -> *).
                           Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                           m_a4LE Language.Haskell.TH.Syntax.Exp)
                            ~#
                          Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))
              (let {
                 x_akVD :: GHC.Integer.Type.Integer
                 [LclId,
                  Str=DmdType,
                  Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                          ConLike=False, WorkFree=False, Expandable=False, Guidance=NEVER}]
                 x_akVD =
                   let {
                     rMax_swu0 :: GHC.Integer.Type.Integer
                     [LclId,
                      Str=DmdType,
                      Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                              ConLike=False, WorkFree=False, Expandable=False,
                              Guidance=IF_ARGS [] 50 0}]
                     rMax_swu0 =
                       GHC.Real.toInteger
                         @ (rep_avhN size_avhO)
                         $dIntegral_avlP
                         (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
                   let {
                     truncated_swu2 :: GHC.Integer.Type.Integer
                     [LclId,
                      Str=DmdType,
                      Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                              ConLike=False, WorkFree=False, Expandable=False,
                              Guidance=IF_ARGS [] 560 0}]
                     truncated_swu2 =
                       case a_auGC of _ [Occ=Dead] { GHC.Types.D# x_aw80 ->
                       case GHC.Real.^
                              @ GHC.Types.Double
                              @ GHC.Integer.Type.Integer
                              GHC.Float.$fNumDouble
                              GHC.Real.$fIntegralInteger
                              lvl_swvh
                              ($dKnownNat_avlM
                               `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                                       ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                                       :: GHC.TypeLits.KnownNat frac_avhM
                                            ~#
                                          GHC.Integer.Type.Integer))
                       of _ [Occ=Dead] { GHC.Types.D# y_aw84 ->
                       case GHC.Integer.Type.decodeDoubleInteger
                              (GHC.Prim.*## x_aw80 y_aw84)
                       of _ [Occ=Dead] { (# ipv_aw8Q, ipv1_aw8R #) ->
                       case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ipv1_aw8R 0)
                       of _ [Occ=Dead] {
                         GHC.Types.False ->
                           GHC.Integer.Type.shiftLInteger ipv_aw8Q ipv1_aw8R;
                         GHC.Types.True ->
                           let {
                             s_aw8X :: GHC.Prim.Int#
                             [LclId,
                              Str=DmdType,
                              Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                      ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 1 0}]
                             s_aw8X = GHC.Prim.negateInt# ipv1_aw8R } in
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># s_aw8X 52)
                           of _ [Occ=Dead] {
                             GHC.Types.False ->
                               case GHC.Integer.Type.ltInteger# ipv_aw8Q (__integer 0)
                               of wild3_aw92 { __DEFAULT ->
                               case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild3_aw92
                               of _ [Occ=Dead] {
                                 GHC.Types.False ->
                                   case GHC.Integer.Type.integerToInt ipv_aw8Q
                                   of n_aw96 { __DEFAULT ->
                                   GHC.Integer.Type.smallInteger
                                     (GHC.Prim.uncheckedIShiftRA# n_aw96 s_aw8X)
                                   };
                                 GHC.Types.True ->
                                   case GHC.Integer.Type.integerToInt
                                          (GHC.Integer.Type.negateInteger ipv_aw8Q)
                                   of n_aw99 { __DEFAULT ->
                                   GHC.Integer.Type.smallInteger
                                     (GHC.Prim.negateInt#
                                        (GHC.Prim.uncheckedIShiftRA# n_aw99 s_aw8X))
                                   }
                               }
                               };
                             GHC.Types.True -> __integer 0
                           }
                       }
                       }
                       }
                       } } in
                   case GHC.Integer.Type.gtInteger# truncated_swu2 rMax_swu0
                   of wild_akJ6 { __DEFAULT ->
                   case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ6
                   of _ [Occ=Dead] {
                     GHC.Types.False ->
                       let {
                         rMin_swu1 :: GHC.Integer.Type.Integer
                         [LclId,
                          Str=DmdType,
                          Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                  ConLike=False, WorkFree=False, Expandable=False,
                                  Guidance=IF_ARGS [] 50 0}]
                         rMin_swu1 =
                           GHC.Real.toInteger
                             @ (rep_avhN size_avhO)
                             $dIntegral_avlP
                             (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
                       case GHC.Integer.Type.ltInteger# truncated_swu2 rMin_swu1
                       of wild_a4It { __DEFAULT ->
                       case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
                       of _ [Occ=Dead] {
                         GHC.Types.False -> truncated_swu2;
                         GHC.Types.True -> rMin_swu1
                       }
                       };
                     GHC.Types.True -> rMax_swu0
                   }
                   } } in
               (\ (@ (m_akVE :: * -> *))
                  (eta_akVF :: Language.Haskell.TH.Syntax.Quasi m_akVE) ->
                  GHC.Base.return
                    @ m_akVE
                    (Language.Haskell.TH.Syntax.$p1Quasi @ m_akVE eta_akVF)
                    @ Language.Haskell.TH.Syntax.Exp
                    (Language.Haskell.TH.Syntax.LitE
                       (Language.Haskell.TH.Syntax.IntegerL x_akVD)))
               `cast` (Sym
                         (Language.Haskell.TH.Syntax.NTCo:Q[0]
                            <Language.Haskell.TH.Syntax.Exp>_N)
                       :: (forall (m_a4LE :: * -> *).
                           Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                           m_a4LE Language.Haskell.TH.Syntax.Exp)
                            ~#
                          Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Exp)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
       `cast` (Sym
                 (Language.Haskell.TH.Syntax.NTCo:Q[0]
                    <Language.Haskell.TH.Syntax.Exp>_N)
               :: (forall (m_a4LE :: * -> *).
                   Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                   m_a4LE Language.Haskell.TH.Syntax.Exp)
                    ~#
                  Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.fLit =
  a_swxS
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 60 0}]
      repBV_swtT =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl_B4
           (tpl_B8
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_B1)
        `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        }
        } } in
    let {
      cobox_swtU
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      cobox_swtU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 50 0}]
      s_swtS =
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (repBV_swtT
              `cast` ((CLaSH.Sized.Vector.Vec
                         (Sym cobox_dw7d) <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
        } } in
    let {
      cobox_swtV
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      cobox_swtV =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    case tup_avmQ
    of _ [Occ=Dead]
    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl_Ba eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        };
      GHC.Types.True ->
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        }
    }
    }

lvl_swvz :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvz = __integer 0

lvl_swvy :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvy = __integer 0

lvl_swvB :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvB = __integer 0

lvl_swvA :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvA = __integer 0

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swtH =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swtI =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_swtI
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat_swtH
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_akJ3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ3
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          $dBounded_swtD :: GHC.Enum.Bounded (rep_avjs size2_avju)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBounded_swtD =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X1u
            } } in
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          fMax_swtA =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          $dBits_swtF :: Data.Bits.Bits (rep_avjs size1_avjt)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swtF =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X5L, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 43 0}]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (case tup_avnK
               of _ [Occ=Dead]
               { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
               (tpl_B6
                `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                        :: CLaSH.Class.Num.Resize rep_avjs
                             ~#
                           (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                            (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                            rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                 @ size2_avju @ size1_avjt $dKnownNat_swtH $dKnownNat_swtI fMax_swtA
               }) } in
        let {
          $dNum_swtE :: GHC.Num.Num (rep_avjs size1_avjt)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dNum_swtE =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            } } in
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFQ { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFQ)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 51 0}]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFQ)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvy)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvz)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 51 0}]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_XkFQ wild_akCB)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvA)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvB)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFG { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFG)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFG)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_XkFG wild_akCB)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 40 20}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_avxa
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_akCB { __DEFAULT ->
    GHC.Types.I# wild_akCB
    }

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

lvl_swvD :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvD = GHC.Types.C# '-'

lvl_swvC :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvC = __integer 0

lvl_swvF
  :: forall b_X4Kn.
     (GHC.Types.Char -> b_X4Kn -> b_X4Kn) -> b_X4Kn -> b_X4Kn
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 40 0}]
lvl_swvF =
  \ (@ b_X4Kn)
    (c_X4Kp [OS=OneShot] :: GHC.Types.Char -> b_X4Kn -> b_X4Kn)
    (n_X4Kr [OS=OneShot] :: b_X4Kn) ->
    c_X4Kp (GHC.Types.C# '.') n_X4Kr

lvl_swvG :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvG = GHC.Types.C# '0'

ds_swvM :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
ds_swvM = __integer 1

lvl_swvQ
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20] 61 0}]
lvl_swvQ =
  \ (x_acXI
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    case x_acXI of _ [Occ=Dead] { (ds1_afnD, y_afnE) ->
    case y_afnE of _ [Occ=Dead] { GHC.Real.:% ds1_awdp y_awdq ->
    case GHC.Integer.Type.eqInteger# y_awdq ds_swvM
    of wild_a2f3 { __DEFAULT ->
    GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
    }
    }
    }

dt_akMa :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
dt_akMa = __integer 10

ds_swvT :: GHC.Real.Ratio GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
ds_swvT =
  GHC.Real.:%
    @ GHC.Integer.Type.Integer dt_akMa GHC.Real.$fEnumRatio1

lvl_swvV
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40] 101 30}]
lvl_swvV =
  \ (ds_awe3
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    (case ds_awe3 of _ [Occ=Dead] { (x_awe6, y_awe7) ->
     case x_awe6 of _ [Occ=Dead] { GHC.Types.I# x1_awdC ->
     case x1_awdC of wild1_awdE {
       __DEFAULT -> GHC.Types.I# (GHC.Prim.+# wild1_awdE 1);
       9223372036854775807 -> GHC.Enum.$fEnumInt2
     }
     }
     },
     case ds_awe3 of _ [Occ=Dead] { (x_aweb, y_awec) ->
     GHC.Real.$fNumRatio_$s$c* y_awec ds_swvT
     })

lvl_swvX :: GHC.Types.Int
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvX = GHC.Types.I# 0

lvl_sww5 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww5 = __integer 2

lvl_sww6 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww6 = __integer 1

lvl_sww7 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww7 = __integer 2

lvl_sww8 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww8 = __integer 1

lvl_sww4 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww4 = __integer 0

lvl_sww9 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww9 = __integer 2

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      nF_swti :: GHC.Types.Int
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 40 20}]
      nF_swti =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_avFx
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        } } in
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 30 0}]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 20 0}]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a4II)
         (c_a4IJ [OS=OneShot] :: GHC.Types.Char -> b_a4II -> b_a4II)
         (n_a4IK [OS=OneShot] :: b_a4II) ->
         case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swvC
         of wild_a4It { __DEFAULT ->
         case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
         of _ [Occ=Dead] {
           GHC.Types.False ->
             case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
             GHC.Base.foldr
               @ GHC.Types.Char
               @ b_a4II
               c_a4IJ
               n_a4IK
               (GHC.Show.$fShowInteger_$cshowsPrec
                  GHC.Show.shows27
                  (Data.Bits.$fBitsInteger_$cshift
                     fRepI_swtk (GHC.Types.I# (GHC.Prim.negateInt# x_aiKN)))
                  (GHC.Types.[] @ GHC.Types.Char))
             };
           GHC.Types.True ->
             GHC.Base.foldr
               @ GHC.Types.Char
               @ b_a4II
               c_a4IJ
               n_a4IK
               (GHC.Types.:
                  @ GHC.Types.Char
                  lvl_swvD
                  (case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
                   GHC.Show.$fShowInteger_$cshowsPrec
                     GHC.Show.shows27
                     (Data.Bits.$fBitsInteger_$cshift
                        fRepI_abs_swtj (GHC.Types.I# (GHC.Prim.negateInt# x_aiKN)))
                     (GHC.Types.[] @ GHC.Types.Char)
                   }))
         }
         })
      (GHC.Base.augment
         @ GHC.Types.Char
         lvl_swvF
         (let {
            eta_awcR
              :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
            [LclId,
             Str=DmdType,
             Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                     ConLike=False, WorkFree=False, Expandable=False,
                     Guidance=IF_ARGS [] 561 0}]
            eta_awcR =
              case GHC.Base.build
                     @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                     (\ (@ b_awzp)
                        (c_awzq [OS=OneShot]
                           :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                              -> b_awzp -> b_awzp)
                        _ [Occ=Dead, OS=OneShot] ->
                        GHC.List.iterateFB
                          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                          @ b_awzp
                          (GHC.List.filterFB
                             @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                             @ b_awzp
                             c_awzq
                             lvl_swvQ)
                          lvl_swvV
                          (lvl_swvX,
                           case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_sww4
                           of wild_a4It { __DEFAULT ->
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
                           of _ [Occ=Dead] {
                             GHC.Types.False ->
                               GHC.Real.%_$s%
                                 (GHC.Integer.Type.andInteger
                                    fRepI_swtk
                                    (GHC.Integer.Type.minusInteger
                                       (GHC.Real.^
                                          @ GHC.Integer.Type.Integer
                                          @ GHC.Types.Int
                                          GHC.Num.$fNumInteger
                                          GHC.Real.$fIntegralInt
                                          lvl_sww5
                                          nF_swti)
                                       lvl_sww6))
                                 (GHC.Real.^
                                    @ GHC.Integer.Type.Integer
                                    @ GHC.Types.Int
                                    GHC.Num.$fNumInteger
                                    GHC.Real.$fIntegralInt
                                    lvl_sww9
                                    nF_swti);
                             GHC.Types.True ->
                               GHC.Real.%_$s%
                                 (GHC.Integer.Type.andInteger
                                    fRepI_abs_swtj
                                    (GHC.Integer.Type.minusInteger
                                       (GHC.Real.^
                                          @ GHC.Integer.Type.Integer
                                          @ GHC.Types.Int
                                          GHC.Num.$fNumInteger
                                          GHC.Real.$fIntegralInt
                                          lvl_sww7
                                          nF_swti)
                                       lvl_sww8))
                                 (GHC.Real.^
                                    @ GHC.Integer.Type.Integer
                                    @ GHC.Types.Int
                                    GHC.Num.$fNumInteger
                                    GHC.Real.$fIntegralInt
                                    lvl_sww9
                                    nF_swti)
                           }
                           }))
              of _ [Occ=Dead] {
                [] ->
                  Data.Maybe.fromJust1
                    @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer);
                : a1_awdh ds1_awdi -> a1_awdh
              } } in
          let {
            str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]
            [LclId,
             Str=DmdType,
             Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                     ConLike=False, WorkFree=False, Expandable=False,
                     Guidance=IF_ARGS [] 60 0}]
            str_auHK =
              case eta_awcR of _ [Occ=Dead] { (x_awcZ, y_awd0) ->
              case y_awd0 of _ [Occ=Dead] { GHC.Real.:% x_awcK ds1_awcL ->
              GHC.Show.$fShowInteger_$cshowsPrec
                GHC.Show.shows27 x_awcK (GHC.Types.[] @ GHC.Types.Char)
              }
              } } in
          GHC.Base.augment
            @ GHC.Types.Char
            (\ (@ b_X4M9)
               (c_X4Mc [OS=OneShot] :: GHC.Types.Char -> b_X4M9 -> b_X4M9)
               (n_X4Kt [OS=OneShot] :: b_X4M9) ->
               case eta_awcR of _ [Occ=Dead] { (x_awcU, y_awcV) ->
               case x_awcU of _ [Occ=Dead] { GHC.Types.I# x_akIV ->
               case GHC.Base.foldr
                      @ GHC.Types.Char
                      @ (GHC.Prim.Int# -> GHC.Types.Int)
                      (GHC.List.incLen @ GHC.Types.Char)
                      GHC.Types.I#
                      str_auHK
                      0
               of _ [Occ=Dead] { GHC.Types.I# y_akIZ ->
               let {
                 n#_awbi :: GHC.Prim.Int#
                 [LclId,
                  Str=DmdType,
                  Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                          ConLike=False, WorkFree=False, Expandable=True,
                          Guidance=IF_ARGS [] 1 0}]
                 n#_awbi = GHC.Prim.-# x_akIV y_akIZ } in
               case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# n#_awbi 0)
               of _ [Occ=Dead] {
                 GHC.Types.False ->
                   GHC.List.repeatFB
                     @ GHC.Types.Char
                     @ (GHC.Prim.Int# -> b_X4M9)
                     (GHC.List.takeFB @ GHC.Types.Char @ b_X4M9 c_X4Mc n_X4Kt)
                     lvl_swvG
                     n#_awbi;
                 GHC.Types.True -> n_X4Kt
               }
               }
               }
               })
            str_auHK))

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 120 40}]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.augment
      @ GHC.Types.Char
      (\ (@ b_a2g3)
         (c_a2g4 [OS=OneShot] :: GHC.Types.Char -> b_a2g3 -> b_a2g3)
         (n_a2g5 [OS=OneShot] :: b_a2g3) ->
         GHC.Base.foldr
           @ GHC.Types.Char
           @ b_a2g3
           c_a2g4
           n_a2g5
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY))
      s_a2fZ

$cshowList_avIE
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId,
 Arity=6,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=6, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0] 180 0}]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_B2 :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta_B1 :: GHC.Base.String) ->
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (\ (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
         (s_a2fZ [OS=OneShot] :: GHC.Base.String) ->
         GHC.Base.augment
           @ GHC.Types.Char
           (\ (@ b_a2g3)
              (c_a2g4 [OS=OneShot] :: GHC.Types.Char -> b_a2g3 -> b_a2g3)
              (n_a2g5 [OS=OneShot] :: b_a2g3) ->
              GHC.Base.foldr
                @ GHC.Types.Char
                @ b_a2g3
                c_a2g4
                n_a2g5
                ($cshow_avFD
                   @ frac_auHx
                   @ rep_auHy
                   @ size_auHz
                   $dShow_avFv
                   $dBits_avFw
                   $dKnownNat_avFx
                   $dIntegral_avFy
                   x_a2fY))
           s_a2fZ)
      eta_B2
      eta_B1

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl_X1B) ->
    case tpl_X1B of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
    ((tpl_X1z
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 430 0}]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swta
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swta =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1L, tpl_X1N, tpl_B3) ->
        tpl_X1N
        } } in
    let {
      $dBounded_swt9
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_swt9 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1N
        } } in
    let {
      $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swt8 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_swt7 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swt6
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swt6 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swt5
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swt5 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swt4
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swt4 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl_X24, tpl_B3) ->
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swt2 =
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X21, tpl_X23, tpl_X5p, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X43, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5q
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X46, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5n
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 430 0}]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swsS
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsS =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1M, tpl_X1O, tpl_B3) ->
        tpl_X1O
        } } in
    let {
      $dBounded_swsR
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_swsR =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1O
        } } in
    let {
      $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swsQ =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_swsP =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swsO
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsO =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swsN
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swsN =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swsM
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsM =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl_X25, tpl_B3) ->
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swsK =
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X45, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5r
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X48, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5o
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 130 0}]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    case tpl_X1N
    of _ [Occ=Dead]
    { (tpl_X1M, tpl_X1O, tpl_X3i, tpl_X3k, tpl_X3m, tpl_X3o, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       tpl_B9
       (GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl_B3 eta_X1I)
       (case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl_B3
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup_swsy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsy =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1V
        } } in
    let {
      $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsx =
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsw =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1X
        } } in
    let {
      $dKnownNat_swsv
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsv =
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsy
           of _ [Occ=Dead]
           { (tpl_X7i, tpl_X7l, tpl_X5n, tpl_X5p, tpl_X5r, tpl_X5t, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5t
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                    :: CLaSH.Class.Num.Resize rep_XuIL
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup_swsq
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsq =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1W
        } } in
    let {
      $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsp =
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swso =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsn
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsn =
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsq
           of _ [Occ=Dead]
           { (tpl_X7k, tpl_X7n, tpl_X5o, tpl_X5q, tpl_X5s, tpl_X5u, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5u
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                    :: CLaSH.Class.Num.Resize rep_XuIM
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup_swsi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsi =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsg =
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsf =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X22
        } } in
    let {
      $dKnownNat_swse
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swse =
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 222 0}]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup_sws8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws8 =
        case tup_XvDd
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Z
        } } in
    let {
      $dBits_sws7
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_sws7 =
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B3
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B6
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B7
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B8
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B9
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Ba
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bb
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bc
       })
      (case tup_XvDd
       of _ [Occ=Dead]
       { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
       ((tpl_B5
         `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                   <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                 :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                      ~#
                    (rep_XuIO size_XuIQ
                     -> rep_XuIO size_XuIQ
                     -> CLaSH.Class.Num.MResult
                          (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
          (eta_X1U
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ))
          (eta_X3N
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ)))
       `cast` (Sub cobox_dw1a
               ; Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                            GHC.TypeLits.+ size_XuIQ>_N
               :: CLaSH.Class.Num.MResult
                    (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       }
       })

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup_sws4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws4 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X20
        } } in
    let {
      $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_sws2 =
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws1 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X24
        } } in
    let {
      $dKnownNat_sws0
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_sws0 =
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     (a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
                     `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                             -> Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                             :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> rep_XuIQ size_XuIS)
                                  ~#
                                (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS))
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ((a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
       `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
               :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> rep_XuIQ size_XuIS)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)))
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         (\ ($dKnownNat_avB0
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (ds_dw0H
                                               :: CLaSH.Sized.Fixed.Fixed
                                                    frac_XuIN rep_XuIP size_XuIR) ->
                                            CLaSH.Class.BitVector.toBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avB0
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (ds_dw0H
                                               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                                                       :: CLaSH.Sized.Fixed.Fixed
                                                            frac_XuIN rep_XuIP size_XuIR
                                                            ~#
                                                          rep_XuIP size_XuIR)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR>_R
                                                 -> (CLaSH.Sized.Vector.Vec
                                                       (Sym
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))
                                                       <CLaSH.Bit.Bit>_R)_R
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (CLaSH.Sized.Fixed.Fixed
                                                                frac_XuIN rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit))
                                         (\ ($dKnownNat_avBa
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (bv_auGX
                                               :: CLaSH.Sized.Vector.Vec
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))
                                                    CLaSH.Bit.Bit) ->
                                            CLaSH.Class.BitVector.fromBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avBa
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (bv_auGX
                                               `cast` ((CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N)
                                                          <CLaSH.Bit.Bit>_R)_R
                                                       :: CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit
                                                            ~#
                                                          CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit>_R
                                                 -> Sym
                                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> rep_XuIP size_XuIR)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ((\ ($dKnownNat_avB0
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (ds_dw0H
             :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
          CLaSH.Class.BitVector.toBV
            @ (rep_XuIP size_XuIR)
            $dBitVector_XvCT
            ($dKnownNat_avB0
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (ds_dw0H
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                          ~#
                        rep_XuIP size_XuIR)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
               -> (CLaSH.Sized.Vector.Vec
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                     <CLaSH.Bit.Bit>_R)_R
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize
                           (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                        CLaSH.Bit.Bit)))
      ((\ ($dKnownNat_avBa
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (bv_auGX
             :: CLaSH.Sized.Vector.Vec
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                  CLaSH.Bit.Bit) ->
          CLaSH.Class.BitVector.fromBV
            @ (rep_XuIP size_XuIR)
            $dBitVector_XvCT
            ($dKnownNat_avBa
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (bv_auGX
             `cast` ((CLaSH.Sized.Vector.Vec
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                        <CLaSH.Bit.Bit>_R)_R
                     :: CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> rep_XuIP size_XuIR)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))

a_swC4
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swC4 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cdef_avAg =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
                          (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ((GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
      ((GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Ordering>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Ordering))
                         (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
                         (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ((GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Ordering>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Ordering)))
      ((GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
      ((GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))
                        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ((GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
      ((GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))

a_swC6 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 40}]
a_swC6 =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#)

a_swC9 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 40}]
a_swC9 =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) ->
       GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#)

a_swCb :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 40}]
a_swCb =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) ->
       GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#)

a_swC7 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swC7 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swC9
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCb
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwh :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swwh =
  Language.Haskell.TH.Syntax.Name
    (a_swC6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swC7

a_swCc
  :: forall (m_XfCO :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_XfCO =>
     m_XfCO Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swCc =
  \ (@ (m_XfCO :: * -> *))
    (eta_XfCQ :: Language.Haskell.TH.Syntax.Quasi m_XfCO) ->
    GHC.Base.return
      @ m_XfCO
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_XfCO eta_XfCQ)
      @ Language.Haskell.TH.Syntax.Exp
      (Language.Haskell.TH.Syntax.ConE lvl_swwh)

a_swCe :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 40}]
a_swCe =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) -> GHC.CString.unpackFoldrCString# @ b_a4Iy "Fixed"#)

a_swCh :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 40}]
a_swCh =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) ->
       GHC.CString.unpackFoldrCString# @ b_a4Iy "clash-prelude-0.5"#)

a_swCj :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 40}]
a_swCj =
  GHC.Base.build
    @ GHC.Types.Char
    (\ (@ b_a4Iy) ->
       GHC.CString.unpackFoldrCString# @ b_a4Iy "CLaSH.Sized.Fixed"#)

a_swCf :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swCf =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (a_swCh
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCj
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwp :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swwp =
  Language.Haskell.TH.Syntax.Name
    (a_swCe
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swCf

a_swCk
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swCk =
  \ (@ (m_a4Ni :: * -> *))
    (eta_a4Nj :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    GHC.Base.return
      @ m_a4Ni
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_a4Nj)
      @ Language.Haskell.TH.Syntax.Type
      (Language.Haskell.TH.Syntax.ConT lvl_swwp)

a_swCv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0] 734 60}]
a_swCv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    Language.Haskell.TH.Lib.sigE1
      ((Language.Haskell.TH.Lib.appE1
          (a_swCc
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Exp)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))
          (($dLift_avAq
            `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                      <rep_auGP size_auGQ>_N
                    :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                         ~#
                       (rep_auGP size_auGQ
                        -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
             (f_auGR
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                           ~#
                         rep_auGP size_auGQ))))
       `cast` (Sym
                 (Language.Haskell.TH.Syntax.NTCo:Q[0]
                    <Language.Haskell.TH.Syntax.Exp>_N)
               :: (forall (m_a4LE :: * -> *).
                   Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                   m_a4LE Language.Haskell.TH.Syntax.Exp)
                    ~#
                  Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))
      (letrec {
         lgo_awhL [Occ=LoopBreaker]
           :: Language.Haskell.TH.Lib.TypeQ
              -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
         [LclId,
          Arity=2,
          Str=DmdType <L,U><S,1*U>,
          Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=2, Value=True,
                  ConLike=True, WorkFree=True, Expandable=True,
                  Guidance=IF_ARGS [0 30] 80 0}]
         lgo_awhL =
           \ (z_awhM :: Language.Haskell.TH.Lib.TypeQ)
             (ds_awhN :: [Language.Haskell.TH.Lib.TypeQ]) ->
             case ds_awhN of _ [Occ=Dead] {
               [] -> z_awhM;
               : x_awhS xs_awhT ->
                 lgo_awhL
                   ((Language.Haskell.TH.Lib.appT1 z_awhM x_awhS)
                    `cast` (Sym
                              (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                 <Language.Haskell.TH.Syntax.Type>_N)
                            :: (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.Type)
                                 ~#
                               Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                   xs_awhT
             }; } in
       lgo_awhL
         (a_swCk
          `cast` (Sym
                    (Language.Haskell.TH.Syntax.NTCo:Q[0]
                       <Language.Haskell.TH.Syntax.Type>_N)
                  :: (forall (m_a4LE :: * -> *).
                      Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                      m_a4LE Language.Haskell.TH.Syntax.Type)
                       ~#
                     Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
         (GHC.Base.build
            @ Language.Haskell.TH.Lib.TypeQ
            (\ (@ a_dvZ6)
               (c_dvZ7 [OS=OneShot]
                  :: Language.Haskell.TH.Lib.TypeQ -> a_dvZ6 -> a_dvZ6)
               (n_dvZ8 [OS=OneShot] :: a_dvZ6) ->
               c_dvZ7
                 (let {
                    l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                    [LclId,
                     Str=DmdType,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                             ConLike=False, WorkFree=False, Expandable=False,
                             Guidance=IF_ARGS [] 20 0}]
                    l_a5DZ =
                      Language.Haskell.TH.Lib.numTyLit
                        ($dKnownNat_avAr
                         `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                                 ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                                 :: GHC.TypeLits.KnownNat frac_auGO
                                      ~#
                                    GHC.Integer.Type.Integer)) } in
                  (\ (@ (m_a5E0 :: * -> *))
                     (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                     GHC.Base.fmap
                       @ m_a5E0
                       (Control.Applicative.$p1Applicative
                          @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                       @ Language.Haskell.TH.Syntax.TyLit
                       @ Language.Haskell.TH.Syntax.Type
                       Language.Haskell.TH.Syntax.LitT
                       ((l_a5DZ
                         `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                   <Language.Haskell.TH.Syntax.TyLit>_N
                                 :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                      ~#
                                    (forall (m_a4LE :: * -> *).
                                     Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                     m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                          @ m_a5E0 eta_a5E1))
                  `cast` (Sym
                            (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <Language.Haskell.TH.Syntax.Type>_N)
                          :: (forall (m_a4LE :: * -> *).
                              Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                              m_a4LE Language.Haskell.TH.Syntax.Type)
                               ~#
                             Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                 (c_dvZ7
                    (let {
                       x_X4Ts :: Language.Haskell.TH.Syntax.Name
                       [LclId,
                        Str=DmdType,
                        Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                ConLike=False, WorkFree=False, Expandable=False,
                                Guidance=IF_ARGS [] 101 0}]
                       x_X4Ts =
                         Language.Haskell.TH.Syntax.mkName_split
                           (GHC.Types.[] @ GHC.Types.Char)
                           (GHC.List.reverse1
                              @ GHC.Types.Char
                              (Data.Typeable.Internal.$fShowTypeRep_$cshowsPrec
                                 GHC.Show.shows27
                                 (($dTypeable_avAt
                                   `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                                             <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                                           :: Data.Typeable.Internal.Typeable rep_auGP
                                                ~#
                                              (GHC.Prim.Proxy# rep_auGP
                                               -> Data.Typeable.Internal.TypeRep)))
                                    (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP))
                                 (GHC.Types.[] @ GHC.Types.Char))
                              (GHC.Types.[] @ GHC.Types.Char)) } in
                     (\ (@ (m_X4Tv :: * -> *))
                        (eta_X4Tx :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
                        GHC.Base.return
                          @ m_X4Tv
                          (Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_X4Tx)
                          @ Language.Haskell.TH.Syntax.Type
                          (Language.Haskell.TH.Syntax.ConT x_X4Ts))
                     `cast` (Sym
                               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                  <Language.Haskell.TH.Syntax.Type>_N)
                             :: (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.Type)
                                  ~#
                                Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                    (c_dvZ7
                       (let {
                          l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                          [LclId,
                           Str=DmdType,
                           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                   ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 20 0}]
                          l_a5DZ =
                            Language.Haskell.TH.Lib.numTyLit
                              ($dKnownNat_avAs
                               `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                                       ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                                       :: GHC.TypeLits.KnownNat size_auGQ
                                            ~#
                                          GHC.Integer.Type.Integer)) } in
                        (\ (@ (m_a5E0 :: * -> *))
                           (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                           GHC.Base.fmap
                             @ m_a5E0
                             (Control.Applicative.$p1Applicative
                                @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                             @ Language.Haskell.TH.Syntax.TyLit
                             @ Language.Haskell.TH.Syntax.Type
                             Language.Haskell.TH.Syntax.LitT
                             ((l_a5DZ
                               `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                         <Language.Haskell.TH.Syntax.TyLit>_N
                                       :: Language.Haskell.TH.Syntax.Q
                                            Language.Haskell.TH.Syntax.TyLit
                                            ~#
                                          (forall (m_a4LE :: * -> *).
                                           Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                           m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                                @ m_a5E0 eta_a5E1))
                        `cast` (Sym
                                  (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <Language.Haskell.TH.Syntax.Type>_N)
                                :: (forall (m_a4LE :: * -> *).
                                    Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                    m_a4LE Language.Haskell.TH.Syntax.Type)
                                     ~#
                                   Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                       n_dvZ8)))))

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$clift_avAv =
  a_swCv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                              (rep_XuMX :: GHC.TypeLits.Nat -> *)
                              (size_XuMZ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
                       -> <GHC.TypeLits.KnownNat frac_XuMV>_R
                       -> <GHC.TypeLits.KnownNat size_XuMZ>_R
                       -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
                       :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  a_swCv
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Simplifier:
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swwY{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [a_swx6{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvF{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [lvl_swvQ{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [ds_swvT{v} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swC6{v} [lid]]
SimplBind [a_swC9{v} [lid]]
SimplBind [a_swCb{v} [lid]]
SimplBind [a_swC7{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [a_swCc{v} [lid]]
SimplBind [a_swCe{v} [lid]]
SimplBind [a_swCh{v} [lid]]
SimplBind [a_swCj{v} [lid]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=1
  = {terms: 2,014, types: 9,295, coercions: 962}
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swwY{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [a_swx6{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [lvl_swvQ{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [ds_swvT{v} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swC6{v} [lid]]
SimplBind [a_swC9{v} [lid]]
SimplBind [a_swCb{v} [lid]]
SimplBind [a_swC7{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [a_swCc{v} [lid]]
SimplBind [a_swCe{v} [lid]]
SimplBind [a_swCh{v} [lid]]
SimplBind [a_swCj{v} [lid]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=2
  = {terms: 2,005, types: 9,283, coercions: 962}
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swwY{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [a_swx6{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [lvl_swvQ{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [ds_swvT{v} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swC6{v} [lid]]
SimplBind [a_swC9{v} [lid]]
SimplBind [a_swCb{v} [lid]]
SimplBind [a_swC7{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [a_swCc{v} [lid]]
SimplBind [a_swCe{v} [lid]]
SimplBind [a_swCh{v} [lid]]
SimplBind [a_swCj{v} [lid]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]

==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 1 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 2,005, types: 9,283, coercions: 962}

lvl_swvg :: GHC.Types.Double
[LclId, Str=DmdType b]
lvl_swvg =
  GHC.Err.error
    @ GHC.Types.Double
    (GHC.CString.unpackCString# "Negative exponent"#)

lvl_swve :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swve = GHC.Types.D# 1.0

lvl_swv0 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv0 = __integer 1

lvl_swv2 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv2 = __integer 1

lvl_swv4 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv4 = __integer 2

lvl_swv6 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv6 = __integer 2

Rec {
g1_swuY [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 442 0}]
g1_swuY =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP :: GHC.Types.Double) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y1_akDO GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y1_akDO lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x1_akDN x1_akDN)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y1_akDO lvl_swv2) lvl_swv4)
              (GHC.Float.timesDouble x1_akDN z_akDP);
          GHC.Types.True -> GHC.Float.timesDouble x1_akDN z_akDP
        }
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Float.timesDouble x1_akDN x1_akDN)
          (GHC.Integer.Type.quotInteger y1_akDO lvl_swv6)
          z_akDP
    }
    }
end Rec }

lvl_swuS :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuS = __integer 1

lvl_swv8 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv8 = __integer 1

lvl_swva :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swva = __integer 2

lvl_swvc :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvc = __integer 2

Rec {
f_swuQ [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 372 0}]
f_swuQ =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y_akDB GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y_akDB lvl_swuS
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x_akDA x_akDA)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y_akDB lvl_swv8) lvl_swva)
              x_akDA;
          GHC.Types.True -> x_akDA
        }
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Float.timesDouble x_akDA x_akDA)
          (GHC.Integer.Type.quotInteger y_akDB lvl_swvc)
    }
    }
end Rec }

lvl_swuH :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuH = __integer 0

lvl_swuK :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuK = __integer 0

$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 152 0}]
$s^_swu6 =
  \ (eta_akDk :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger# eta1_akDl lvl_swuH
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# eta1_akDl lvl_swuK
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        }
        };
      GHC.Types.True -> lvl_swvg
    }
    }

lvl_swvh :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvh = GHC.Types.D# 2.0

a_swwS :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swwS = GHC.CString.unpackCString# "Fixed"#

a_swwV :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swwV = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swwX :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swwX = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swwT :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swwT =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvo :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvo =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swwT

a_swwY
  :: forall (m_afx5 :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_afx5 =>
     m_afx5 Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swwY =
  \ (@ (m_afx5 :: * -> *))
    (eta_afx6 :: Language.Haskell.TH.Syntax.Quasi m_afx5) ->
    GHC.Base.return
      @ m_afx5
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_afx5 eta_afx6)
      @ Language.Haskell.TH.Syntax.Exp
      (Language.Haskell.TH.Syntax.ConE lvl_swvo)

a_swx0 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 60 0}]
a_swx0 = GHC.CString.unpackCString# "fromInteger"#

a_swx3 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 40 0}]
a_swx3 = GHC.CString.unpackCString# "base"#

a_swx5 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swx5 = GHC.CString.unpackCString# "GHC.Num"#

a_swx1 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swx1 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (a_swx3
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swx5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvw :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvw =
  Language.Haskell.TH.Syntax.Name
    (a_swx0
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swx1

a_swx6
  :: forall (m_a5ye :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a5ye =>
     m_a5ye Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swx6 =
  \ (@ (m_a5ye :: * -> *))
    (eta_a5yf :: Language.Haskell.TH.Syntax.Quasi m_a5ye) ->
    GHC.Base.return
      @ m_a5ye
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a5ye eta_a5yf)
      @ Language.Haskell.TH.Syntax.Exp
      (Language.Haskell.TH.Syntax.VarE lvl_swvw)

a_swxS
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
a_swxS =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    Language.Haskell.TH.Syntax.unsafeTExpCoerce1
      @ (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)
      ((Language.Haskell.TH.Lib.appE1
          (a_swwY
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Exp)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))
          ((Language.Haskell.TH.Lib.appE1
              (a_swx6
               `cast` (Sym
                         (Language.Haskell.TH.Syntax.NTCo:Q[0]
                            <Language.Haskell.TH.Syntax.Exp>_N)
                       :: (forall (m_a4LE :: * -> *).
                           Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                           m_a4LE Language.Haskell.TH.Syntax.Exp)
                            ~#
                          Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))
              (let {
                 x_akVD :: GHC.Integer.Type.Integer
                 [LclId,
                  Str=DmdType,
                  Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                          ConLike=False, WorkFree=False, Expandable=False, Guidance=NEVER}]
                 x_akVD =
                   let {
                     rMax_swu0 :: GHC.Integer.Type.Integer
                     [LclId,
                      Str=DmdType,
                      Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                              ConLike=False, WorkFree=False, Expandable=False,
                              Guidance=IF_ARGS [] 50 0}]
                     rMax_swu0 =
                       GHC.Real.toInteger
                         @ (rep_avhN size_avhO)
                         $dIntegral_avlP
                         (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
                   let {
                     truncated_swu2 :: GHC.Integer.Type.Integer
                     [LclId,
                      Str=DmdType,
                      Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                              ConLike=False, WorkFree=False, Expandable=False,
                              Guidance=IF_ARGS [] 540 0}]
                     truncated_swu2 =
                       case a_auGC of _ [Occ=Dead] { GHC.Types.D# x_aw80 ->
                       case $s^_swu6
                              lvl_swvh
                              ($dKnownNat_avlM
                               `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                                       ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                                       :: GHC.TypeLits.KnownNat frac_avhM
                                            ~#
                                          GHC.Integer.Type.Integer))
                       of _ [Occ=Dead] { GHC.Types.D# y_aw84 ->
                       case GHC.Integer.Type.decodeDoubleInteger
                              (GHC.Prim.*## x_aw80 y_aw84)
                       of _ [Occ=Dead] { (# ipv_aw8Q, ipv1_aw8R #) ->
                       case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ipv1_aw8R 0)
                       of _ [Occ=Dead] {
                         GHC.Types.False ->
                           GHC.Integer.Type.shiftLInteger ipv_aw8Q ipv1_aw8R;
                         GHC.Types.True ->
                           let {
                             s_aw8X :: GHC.Prim.Int#
                             [LclId,
                              Str=DmdType,
                              Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                      ConLike=False, WorkFree=False, Expandable=True,
                                      Guidance=IF_ARGS [] 1 0}]
                             s_aw8X = GHC.Prim.negateInt# ipv1_aw8R } in
                           case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># s_aw8X 52)
                           of _ [Occ=Dead] {
                             GHC.Types.False ->
                               case GHC.Integer.Type.ltInteger# ipv_aw8Q (__integer 0)
                               of wild3_aw92 { __DEFAULT ->
                               case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild3_aw92
                               of _ [Occ=Dead] {
                                 GHC.Types.False ->
                                   case GHC.Integer.Type.integerToInt ipv_aw8Q
                                   of n_aw96 { __DEFAULT ->
                                   GHC.Integer.Type.smallInteger
                                     (GHC.Prim.uncheckedIShiftRA# n_aw96 s_aw8X)
                                   };
                                 GHC.Types.True ->
                                   case GHC.Integer.Type.integerToInt
                                          (GHC.Integer.Type.negateInteger ipv_aw8Q)
                                   of n_aw99 { __DEFAULT ->
                                   GHC.Integer.Type.smallInteger
                                     (GHC.Prim.negateInt#
                                        (GHC.Prim.uncheckedIShiftRA# n_aw99 s_aw8X))
                                   }
                               }
                               };
                             GHC.Types.True -> __integer 0
                           }
                       }
                       }
                       }
                       } } in
                   case GHC.Integer.Type.gtInteger# truncated_swu2 rMax_swu0
                   of wild_akJ6 { __DEFAULT ->
                   case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ6
                   of _ [Occ=Dead] {
                     GHC.Types.False ->
                       let {
                         rMin_swu1 :: GHC.Integer.Type.Integer
                         [LclId,
                          Str=DmdType,
                          Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                  ConLike=False, WorkFree=False, Expandable=False,
                                  Guidance=IF_ARGS [] 50 0}]
                         rMin_swu1 =
                           GHC.Real.toInteger
                             @ (rep_avhN size_avhO)
                             $dIntegral_avlP
                             (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
                       case GHC.Integer.Type.ltInteger# truncated_swu2 rMin_swu1
                       of wild_a4It { __DEFAULT ->
                       case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
                       of _ [Occ=Dead] {
                         GHC.Types.False -> truncated_swu2;
                         GHC.Types.True -> rMin_swu1
                       }
                       };
                     GHC.Types.True -> rMax_swu0
                   }
                   } } in
               (\ (@ (m_akVE :: * -> *))
                  (eta_akVF :: Language.Haskell.TH.Syntax.Quasi m_akVE) ->
                  GHC.Base.return
                    @ m_akVE
                    (Language.Haskell.TH.Syntax.$p1Quasi @ m_akVE eta_akVF)
                    @ Language.Haskell.TH.Syntax.Exp
                    (Language.Haskell.TH.Syntax.LitE
                       (Language.Haskell.TH.Syntax.IntegerL x_akVD)))
               `cast` (Sym
                         (Language.Haskell.TH.Syntax.NTCo:Q[0]
                            <Language.Haskell.TH.Syntax.Exp>_N)
                       :: (forall (m_a4LE :: * -> *).
                           Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                           m_a4LE Language.Haskell.TH.Syntax.Exp)
                            ~#
                          Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Exp)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
       `cast` (Sym
                 (Language.Haskell.TH.Syntax.NTCo:Q[0]
                    <Language.Haskell.TH.Syntax.Exp>_N)
               :: (forall (m_a4LE :: * -> *).
                   Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                   m_a4LE Language.Haskell.TH.Syntax.Exp)
                    ~#
                  Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.fLit =
  a_swxS
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 60 0}]
      repBV_swtT =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl_B4
           (tpl_B8
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_B1)
        `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        }
        } } in
    let {
      cobox_swtU
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      cobox_swtU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 50 0}]
      s_swtS =
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (repBV_swtT
              `cast` ((CLaSH.Sized.Vector.Vec
                         (Sym cobox_dw7d) <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
        } } in
    let {
      cobox_swtV
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      cobox_swtV =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    case tup_avmQ
    of _ [Occ=Dead]
    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl_Ba eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        };
      GHC.Types.True ->
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        }
    }
    }

lvl_swvz :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvz = __integer 0

lvl_swvy :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvy = __integer 0

lvl_swvB :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvB = __integer 0

lvl_swvA :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvA = __integer 0

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swtH =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swtI =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_swtI
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat_swtH
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_akJ3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ3
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          $dBounded_swtD :: GHC.Enum.Bounded (rep_avjs size2_avju)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBounded_swtD =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X1u
            } } in
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          fMax_swtA =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          $dBits_swtF :: Data.Bits.Bits (rep_avjs size1_avjt)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swtF =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X5L, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 43 0}]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (case tup_avnK
               of _ [Occ=Dead]
               { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
               (tpl_B6
                `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                        :: CLaSH.Class.Num.Resize rep_avjs
                             ~#
                           (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                            (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                            rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                 @ size2_avju @ size1_avjt $dKnownNat_swtH $dKnownNat_swtI fMax_swtA
               }) } in
        let {
          $dNum_swtE :: GHC.Num.Num (rep_avjs size1_avjt)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dNum_swtE =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            } } in
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFQ { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFQ)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 51 0}]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFQ)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvy)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvz)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 51 0}]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_XkFQ wild_akCB)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvA)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvB)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFG { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFG)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFG)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_XkFG wild_akCB)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 40 20}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_avxa
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_akCB { __DEFAULT ->
    GHC.Types.I# wild_akCB
    }

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

lvl_swvD :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvD = GHC.Types.C# '-'

lvl_swvC :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvC = __integer 0

lvl_swvG :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvG = GHC.Types.C# '0'

ds_swvM :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
ds_swvM = __integer 1

lvl_swvQ
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> GHC.Types.Bool
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20] 61 0}]
lvl_swvQ =
  \ (x_acXI
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    case x_acXI of _ [Occ=Dead] { (ds1_afnD, y_afnE) ->
    case y_afnE of _ [Occ=Dead] { GHC.Real.:% ds1_awdp y_awdq ->
    case GHC.Integer.Type.eqInteger# y_awdq ds_swvM
    of wild_a2f3 { __DEFAULT ->
    GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
    }
    }
    }

dt_akMa :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
dt_akMa = __integer 10

ds_swvT :: GHC.Real.Ratio GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
ds_swvT =
  GHC.Real.:%
    @ GHC.Integer.Type.Integer dt_akMa GHC.Real.$fEnumRatio1

lvl_swvV
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40] 101 30}]
lvl_swvV =
  \ (ds_awe3
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    (case ds_awe3 of _ [Occ=Dead] { (x_awe6, y_awe7) ->
     case x_awe6 of _ [Occ=Dead] { GHC.Types.I# x1_awdC ->
     case x1_awdC of wild1_awdE {
       __DEFAULT -> GHC.Types.I# (GHC.Prim.+# wild1_awdE 1);
       9223372036854775807 -> GHC.Enum.$fEnumInt2
     }
     }
     },
     case ds_awe3 of _ [Occ=Dead] { (x_aweb, y_awec) ->
     GHC.Real.$fNumRatio_$s$c* y_awec ds_swvT
     })

lvl_swvX :: GHC.Types.Int
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvX = GHC.Types.I# 0

lvl_sww5 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww5 = __integer 2

lvl_sww6 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww6 = __integer 1

lvl_sww7 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww7 = __integer 2

lvl_sww8 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww8 = __integer 1

lvl_sww4 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww4 = __integer 0

lvl_sww9 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww9 = __integer 2

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      nF_swti :: GHC.Types.Int
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 40 20}]
      nF_swti =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_avFx
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        } } in
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 30 0}]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 20 0}]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      a_swOO :: [GHC.Types.Char]
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False, Guidance=NEVER}]
      a_swOO =
        let {
          eta_awcR
            :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False, Guidance=NEVER}]
          eta_awcR =
            case GHC.List.iterateFB
                   @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                   @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                   (GHC.List.filterFB
                      @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                      @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                      (GHC.Types.:
                         @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                      lvl_swvQ)
                   lvl_swvV
                   (lvl_swvX,
                    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_sww4
                    of wild_a4It { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        case nF_swti of wild_awO7 { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of _ [Occ=Dead] {
                          GHC.Types.False ->
                            let {
                              a_swOs :: GHC.Integer.Type.Integer
                              [LclId,
                               Str=DmdType,
                               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                       ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 72 0}]
                              a_swOs =
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                                of _ [Occ=Dead] {
                                  GHC.Types.False ->
                                    case x_awO9 of _ [Occ=Dead] {
                                      __DEFAULT -> GHC.Real.^_f1 lvl_sww9 wild_awO7;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of _ [Occ=Dead] {
                              __DEFAULT ->
                                GHC.Real.%_$s%
                                  (GHC.Integer.Type.andInteger
                                     fRepI_swtk
                                     (GHC.Integer.Type.minusInteger
                                        (GHC.Real.^_f1 lvl_sww5 wild_awO7) lvl_sww6))
                                  a_swOs;
                              0 ->
                                GHC.Real.%_$s%
                                  (GHC.Integer.Type.andInteger fRepI_swtk (__integer 0)) a_swOs
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        };
                      GHC.Types.True ->
                        case nF_swti of wild_awO7 { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of _ [Occ=Dead] {
                          GHC.Types.False ->
                            let {
                              a_swOy :: GHC.Integer.Type.Integer
                              [LclId,
                               Str=DmdType,
                               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                       ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 72 0}]
                              a_swOy =
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                                of _ [Occ=Dead] {
                                  GHC.Types.False ->
                                    case x_awO9 of _ [Occ=Dead] {
                                      __DEFAULT -> GHC.Real.^_f1 lvl_sww9 wild_awO7;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of _ [Occ=Dead] {
                              __DEFAULT ->
                                GHC.Real.%_$s%
                                  (GHC.Integer.Type.andInteger
                                     fRepI_abs_swtj
                                     (GHC.Integer.Type.minusInteger
                                        (GHC.Real.^_f1 lvl_sww7 wild_awO7) lvl_sww8))
                                  a_swOy;
                              0 ->
                                GHC.Real.%_$s%
                                  (GHC.Integer.Type.andInteger fRepI_abs_swtj (__integer 0)) a_swOy
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        }
                    }
                    })
            of _ [Occ=Dead] {
              [] ->
                Data.Maybe.fromJust1
                  @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer);
              : a1_awdh ds1_awdi -> a1_awdh
            } } in
        let {
          str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 60 0}]
          str_auHK =
            case eta_awcR of _ [Occ=Dead] { (x_awcZ, y_awd0) ->
            case y_awd0 of _ [Occ=Dead] { GHC.Real.:% x_awcK ds1_awcL ->
            GHC.Show.$fShowInteger_$cshowsPrec
              GHC.Show.shows27 x_awcK (GHC.Types.[] @ GHC.Types.Char)
            }
            } } in
        case eta_awcR of _ [Occ=Dead] { (x_awcU, y_awcV) ->
        case x_awcU of _ [Occ=Dead] { GHC.Types.I# x_akIV ->
        case GHC.List.lenAcc @ GHC.Types.Char str_auHK 0
        of _ [Occ=Dead] { GHC.Types.I# y_akIZ ->
        let {
          n#_awbi :: GHC.Prim.Int#
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 1 0}]
          n#_awbi = GHC.Prim.-# x_akIV y_akIZ } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# n#_awbi 0)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            GHC.List.repeatFB
              @ GHC.Types.Char
              @ (GHC.Prim.Int# -> [GHC.Types.Char])
              (GHC.List.takeFB
                 @ GHC.Types.Char
                 @ [GHC.Types.Char]
                 (GHC.Types.: @ GHC.Types.Char)
                 str_auHK)
              lvl_swvG
              n#_awbi;
          GHC.Types.True -> str_auHK
        }
        }
        }
        } } in
    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swvC
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
        GHC.Base.++
          @ GHC.Types.Char
          (GHC.Show.$fShowInteger_$cshowsPrec
             GHC.Show.shows27
             (Data.Bits.$fBitsInteger_$cshift
                fRepI_swtk (GHC.Types.I# (GHC.Prim.negateInt# x_aiKN)))
             (GHC.Types.[] @ GHC.Types.Char))
          (GHC.Types.: @ GHC.Types.Char (GHC.Types.C# '.') a_swOO)
        };
      GHC.Types.True ->
        GHC.Base.++
          @ GHC.Types.Char
          (GHC.Types.:
             @ GHC.Types.Char
             lvl_swvD
             (case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
              GHC.Show.$fShowInteger_$cshowsPrec
                GHC.Show.shows27
                (Data.Bits.$fBitsInteger_$cshift
                   fRepI_abs_swtj (GHC.Types.I# (GHC.Prim.negateInt# x_aiKN)))
                (GHC.Types.[] @ GHC.Types.Char)
              }))
          (GHC.Types.: @ GHC.Types.Char (GHC.Types.C# '.') a_swOO)
    }
    }

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 90 0}]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.++
      @ GHC.Types.Char
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy
         x_a2fY)
      s_a2fZ

$cshowList_avIE
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId,
 Arity=6,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=6, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0] 150 0}]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_B2 :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta_B1 :: GHC.Base.String) ->
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (\ (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
         (s_a2fZ [OS=OneShot] :: GHC.Base.String) ->
         GHC.Base.++
           @ GHC.Types.Char
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY)
           s_a2fZ)
      eta_B2
      eta_B1

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl_X1B) ->
    case tpl_X1B of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
    ((tpl_X1z
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 430 0}]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swta
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swta =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1L, tpl_X1N, tpl_B3) ->
        tpl_X1N
        } } in
    let {
      $dBounded_swt9
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_swt9 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1N
        } } in
    let {
      $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swt8 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_swt7 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swt6
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swt6 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swt5
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swt5 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swt4
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swt4 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl_X24, tpl_B3) ->
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swt2 =
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X21, tpl_X23, tpl_X5p, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X43, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5q
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X46, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5n
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 430 0}]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swsS
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsS =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1M, tpl_X1O, tpl_B3) ->
        tpl_X1O
        } } in
    let {
      $dBounded_swsR
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_swsR =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1O
        } } in
    let {
      $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swsQ =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_swsP =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swsO
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsO =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swsN
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swsN =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swsM
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsM =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl_X25, tpl_B3) ->
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swsK =
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X45, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5r
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X48, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5o
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 130 0}]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    case tpl_X1N
    of _ [Occ=Dead]
    { (tpl_X1M, tpl_X1O, tpl_X3i, tpl_X3k, tpl_X3m, tpl_X3o, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       tpl_B9
       (GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl_B3 eta_X1I)
       (case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl_B3
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup_swsy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsy =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1V
        } } in
    let {
      $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsx =
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsw =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1X
        } } in
    let {
      $dKnownNat_swsv
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsv =
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsy
           of _ [Occ=Dead]
           { (tpl_X7i, tpl_X7l, tpl_X5n, tpl_X5p, tpl_X5r, tpl_X5t, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5t
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                    :: CLaSH.Class.Num.Resize rep_XuIL
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup_swsq
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsq =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1W
        } } in
    let {
      $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsp =
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swso =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsn
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsn =
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsq
           of _ [Occ=Dead]
           { (tpl_X7k, tpl_X7n, tpl_X5o, tpl_X5q, tpl_X5s, tpl_X5u, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5u
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                    :: CLaSH.Class.Num.Resize rep_XuIM
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup_swsi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsi =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsg =
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsf =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X22
        } } in
    let {
      $dKnownNat_swse
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swse =
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 222 0}]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup_sws8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws8 =
        case tup_XvDd
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Z
        } } in
    let {
      $dBits_sws7
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_sws7 =
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B3
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B6
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B7
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B8
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B9
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Ba
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bb
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bc
       })
      (case tup_XvDd
       of _ [Occ=Dead]
       { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
       ((tpl_B5
         `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                   <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                 :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                      ~#
                    (rep_XuIO size_XuIQ
                     -> rep_XuIO size_XuIQ
                     -> CLaSH.Class.Num.MResult
                          (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
          (eta_X1U
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ))
          (eta_X3N
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ)))
       `cast` (Sub cobox_dw1a
               ; Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                            GHC.TypeLits.+ size_XuIQ>_N
               :: CLaSH.Class.Num.MResult
                    (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       }
       })

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup_sws4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws4 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X20
        } } in
    let {
      $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_sws2 =
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws1 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X24
        } } in
    let {
      $dKnownNat_sws0
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_sws0 =
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     (a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
                     `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                             -> Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                             :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> rep_XuIQ size_XuIS)
                                  ~#
                                (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS))
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ((a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
       `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
               :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> rep_XuIQ size_XuIS)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)))
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         (\ ($dKnownNat_avB0
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (ds_dw0H
                                               :: CLaSH.Sized.Fixed.Fixed
                                                    frac_XuIN rep_XuIP size_XuIR) ->
                                            CLaSH.Class.BitVector.toBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avB0
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (ds_dw0H
                                               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                                                       :: CLaSH.Sized.Fixed.Fixed
                                                            frac_XuIN rep_XuIP size_XuIR
                                                            ~#
                                                          rep_XuIP size_XuIR)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR>_R
                                                 -> (CLaSH.Sized.Vector.Vec
                                                       (Sym
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))
                                                       <CLaSH.Bit.Bit>_R)_R
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (CLaSH.Sized.Fixed.Fixed
                                                                frac_XuIN rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit))
                                         (\ ($dKnownNat_avBa
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (bv_auGX
                                               :: CLaSH.Sized.Vector.Vec
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))
                                                    CLaSH.Bit.Bit) ->
                                            CLaSH.Class.BitVector.fromBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avBa
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (bv_auGX
                                               `cast` ((CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N)
                                                          <CLaSH.Bit.Bit>_R)_R
                                                       :: CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit
                                                            ~#
                                                          CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit>_R
                                                 -> Sym
                                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> rep_XuIP size_XuIR)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ((\ ($dKnownNat_avB0
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (ds_dw0H
             :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
          CLaSH.Class.BitVector.toBV
            @ (rep_XuIP size_XuIR)
            $dBitVector_XvCT
            ($dKnownNat_avB0
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (ds_dw0H
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                          ~#
                        rep_XuIP size_XuIR)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
               -> (CLaSH.Sized.Vector.Vec
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                     <CLaSH.Bit.Bit>_R)_R
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize
                           (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                        CLaSH.Bit.Bit)))
      ((\ ($dKnownNat_avBa
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (bv_auGX
             :: CLaSH.Sized.Vector.Vec
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                  CLaSH.Bit.Bit) ->
          CLaSH.Class.BitVector.fromBV
            @ (rep_XuIP size_XuIR)
            $dBitVector_XvCT
            ($dKnownNat_avBa
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (bv_auGX
             `cast` ((CLaSH.Sized.Vector.Vec
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                        <CLaSH.Bit.Bit>_R)_R
                     :: CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> rep_XuIP size_XuIR)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))

a_swC4
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swC4 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cdef_avAg =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
                          (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ((GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
      ((GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Ordering>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Ordering))
                         (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
                         (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ((GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Ordering>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Ordering)))
      ((GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
      ((GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))
                        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ((GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
      ((GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))

a_swC6 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swC6 = GHC.CString.unpackCString# "Fixed"#

a_swC9 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swC9 = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swCb :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swCb = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swC7 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swC7 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swC9
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCb
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwh :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swwh =
  Language.Haskell.TH.Syntax.Name
    (a_swC6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swC7

a_swCc
  :: forall (m_XfCO :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_XfCO =>
     m_XfCO Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swCc =
  \ (@ (m_XfCO :: * -> *))
    (eta_XfCQ :: Language.Haskell.TH.Syntax.Quasi m_XfCO) ->
    GHC.Base.return
      @ m_XfCO
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_XfCO eta_XfCQ)
      @ Language.Haskell.TH.Syntax.Exp
      (Language.Haskell.TH.Syntax.ConE lvl_swwh)

a_swCe :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swCe = GHC.CString.unpackCString# "Fixed"#

a_swCh :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swCh = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swCj :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swCj = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swCf :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swCf =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (a_swCh
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCj
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwp :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swwp =
  Language.Haskell.TH.Syntax.Name
    (a_swCe
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swCf

a_swCk
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swCk =
  \ (@ (m_a4Ni :: * -> *))
    (eta_a4Nj :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    GHC.Base.return
      @ m_a4Ni
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_a4Nj)
      @ Language.Haskell.TH.Syntax.Type
      (Language.Haskell.TH.Syntax.ConT lvl_swwp)

a_swCv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0] 654 60}]
a_swCv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    Language.Haskell.TH.Lib.sigE1
      ((Language.Haskell.TH.Lib.appE1
          (a_swCc
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Exp)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))
          (($dLift_avAq
            `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                      <rep_auGP size_auGQ>_N
                    :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                         ~#
                       (rep_auGP size_auGQ
                        -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
             (f_auGR
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                           ~#
                         rep_auGP size_auGQ))))
       `cast` (Sym
                 (Language.Haskell.TH.Syntax.NTCo:Q[0]
                    <Language.Haskell.TH.Syntax.Exp>_N)
               :: (forall (m_a4LE :: * -> *).
                   Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                   m_a4LE Language.Haskell.TH.Syntax.Exp)
                    ~#
                  Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))
      (letrec {
         lgo_awhL [Occ=LoopBreaker]
           :: Language.Haskell.TH.Lib.TypeQ
              -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
         [LclId,
          Arity=2,
          Str=DmdType <L,U><S,1*U>,
          Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=2, Value=True,
                  ConLike=True, WorkFree=True, Expandable=True,
                  Guidance=IF_ARGS [0 30] 80 0}]
         lgo_awhL =
           \ (z_awhM :: Language.Haskell.TH.Lib.TypeQ)
             (ds_awhN :: [Language.Haskell.TH.Lib.TypeQ]) ->
             case ds_awhN of _ [Occ=Dead] {
               [] -> z_awhM;
               : x_awhS xs_awhT ->
                 lgo_awhL
                   ((Language.Haskell.TH.Lib.appT1 z_awhM x_awhS)
                    `cast` (Sym
                              (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                 <Language.Haskell.TH.Syntax.Type>_N)
                            :: (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.Type)
                                 ~#
                               Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                   xs_awhT
             }; } in
       lgo_awhL
         (a_swCk
          `cast` (Sym
                    (Language.Haskell.TH.Syntax.NTCo:Q[0]
                       <Language.Haskell.TH.Syntax.Type>_N)
                  :: (forall (m_a4LE :: * -> *).
                      Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                      m_a4LE Language.Haskell.TH.Syntax.Type)
                       ~#
                     Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
         (GHC.Types.:
            @ Language.Haskell.TH.Lib.TypeQ
            (let {
               l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
               [LclId,
                Str=DmdType,
                Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                        ConLike=False, WorkFree=False, Expandable=False,
                        Guidance=IF_ARGS [] 20 0}]
               l_a5DZ =
                 Language.Haskell.TH.Lib.numTyLit
                   ($dKnownNat_avAr
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                            :: GHC.TypeLits.KnownNat frac_auGO
                                 ~#
                               GHC.Integer.Type.Integer)) } in
             (\ (@ (m_a5E0 :: * -> *))
                (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                GHC.Base.fmap
                  @ m_a5E0
                  (Control.Applicative.$p1Applicative
                     @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                  @ Language.Haskell.TH.Syntax.TyLit
                  @ Language.Haskell.TH.Syntax.Type
                  Language.Haskell.TH.Syntax.LitT
                  ((l_a5DZ
                    `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.TyLit>_N
                            :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                 ~#
                               (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                     @ m_a5E0 eta_a5E1))
             `cast` (Sym
                       (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <Language.Haskell.TH.Syntax.Type>_N)
                     :: (forall (m_a4LE :: * -> *).
                         Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                         m_a4LE Language.Haskell.TH.Syntax.Type)
                          ~#
                        Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
            (GHC.Types.:
               @ Language.Haskell.TH.Lib.TypeQ
               (let {
                  x_X4Ts :: Language.Haskell.TH.Syntax.Name
                  [LclId,
                   Str=DmdType,
                   Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                           ConLike=False, WorkFree=False, Expandable=False,
                           Guidance=IF_ARGS [] 101 0}]
                  x_X4Ts =
                    Language.Haskell.TH.Syntax.mkName_split
                      (GHC.Types.[] @ GHC.Types.Char)
                      (GHC.List.reverse1
                         @ GHC.Types.Char
                         (Data.Typeable.Internal.$fShowTypeRep_$cshowsPrec
                            GHC.Show.shows27
                            (($dTypeable_avAt
                              `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                                        <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                                      :: Data.Typeable.Internal.Typeable rep_auGP
                                           ~#
                                         (GHC.Prim.Proxy# rep_auGP
                                          -> Data.Typeable.Internal.TypeRep)))
                               (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP))
                            (GHC.Types.[] @ GHC.Types.Char))
                         (GHC.Types.[] @ GHC.Types.Char)) } in
                (\ (@ (m_X4Tv :: * -> *))
                   (eta_X4Tx :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
                   GHC.Base.return
                     @ m_X4Tv
                     (Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_X4Tx)
                     @ Language.Haskell.TH.Syntax.Type
                     (Language.Haskell.TH.Syntax.ConT x_X4Ts))
                `cast` (Sym
                          (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N)
                        :: (forall (m_a4LE :: * -> *).
                            Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                            m_a4LE Language.Haskell.TH.Syntax.Type)
                             ~#
                           Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
               (GHC.Types.:
                  @ Language.Haskell.TH.Lib.TypeQ
                  (let {
                     l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                     [LclId,
                      Str=DmdType,
                      Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                              ConLike=False, WorkFree=False, Expandable=False,
                              Guidance=IF_ARGS [] 20 0}]
                     l_a5DZ =
                       Language.Haskell.TH.Lib.numTyLit
                         ($dKnownNat_avAs
                          `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                                  ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                                  :: GHC.TypeLits.KnownNat size_auGQ
                                       ~#
                                     GHC.Integer.Type.Integer)) } in
                   (\ (@ (m_a5E0 :: * -> *))
                      (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                      GHC.Base.fmap
                        @ m_a5E0
                        (Control.Applicative.$p1Applicative
                           @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                        @ Language.Haskell.TH.Syntax.TyLit
                        @ Language.Haskell.TH.Syntax.Type
                        Language.Haskell.TH.Syntax.LitT
                        ((l_a5DZ
                          `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                    <Language.Haskell.TH.Syntax.TyLit>_N
                                  :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                       ~#
                                     (forall (m_a4LE :: * -> *).
                                      Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                      m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                           @ m_a5E0 eta_a5E1))
                   `cast` (Sym
                             (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                <Language.Haskell.TH.Syntax.Type>_N)
                           :: (forall (m_a4LE :: * -> *).
                               Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                               m_a4LE Language.Haskell.TH.Syntax.Type)
                                ~#
                              Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                  (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)))))

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$clift_avAv =
  a_swCv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                              (rep_XuMX :: GHC.TypeLits.Nat -> *)
                              (size_XuMZ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
                       -> <GHC.TypeLits.KnownNat frac_XuMV>_R
                       -> <GHC.TypeLits.KnownNat size_XuMZ>_R
                       -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
                       :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  a_swCv
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Simplifier:
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swwY{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [a_swx6{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [lvl_swvQ{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [ds_swvT{v} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swC6{v} [lid]]
SimplBind [a_swC9{v} [lid]]
SimplBind [a_swCb{v} [lid]]
SimplBind [a_swC7{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [a_swCc{v} [lid]]
SimplBind [a_swCe{v} [lid]]
SimplBind [a_swCh{v} [lid]]
SimplBind [a_swCj{v} [lid]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=1
  = {terms: 2,402, types: 10,054, coercions: 953}
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swC6{v} [lid]]
SimplBind [a_swC9{v} [lid]]
SimplBind [a_swCb{v} [lid]]
SimplBind [a_swC7{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [a_swCe{v} [lid]]
SimplBind [a_swCh{v} [lid]]
SimplBind [a_swCj{v} [lid]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=2
  = {terms: 2,269, types: 9,622, coercions: 953}
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv2{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [lvl_swv6{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [lvl_swuS{v} [lid]]
SimplBind [lvl_swv8{v} [lid]]
SimplBind [lvl_swva{v} [lid]]
SimplBind [lvl_swvc{v} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind [lvl_swvz{v} [lid]]
SimplBind [lvl_swvy{v} [lid]]
SimplBind [lvl_swvB{v} [lid]]
SimplBind [lvl_swvA{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvC{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [ds_swvM{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sww5{v} [lid]]
SimplBind [lvl_sww6{v} [lid]]
SimplBind [lvl_sww7{v} [lid]]
SimplBind [lvl_sww8{v} [lid]]
SimplBind [lvl_sww4{v} [lid]]
SimplBind [lvl_sww9{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swC6{v} [lid]]
SimplBind [a_swC9{v} [lid]]
SimplBind [a_swCb{v} [lid]]
SimplBind [a_swC7{v} [lid]]
SimplBind [lvl_swwh{v} [lid]]
SimplBind [a_swCe{v} [lid]]
SimplBind [a_swCh{v} [lid]]
SimplBind [a_swCj{v} [lid]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]

==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [main],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 2,243, types: 9,616, coercions: 953}

lvl_swvg :: GHC.Types.Double
[LclId, Str=DmdType b]
lvl_swvg =
  GHC.Err.error
    @ GHC.Types.Double
    (GHC.CString.unpackCString# "Negative exponent"#)

lvl_swve :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swve = GHC.Types.D# 1.0

lvl_swv0 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv0 = __integer 1

lvl_swv2 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv2 = __integer 1

lvl_swv4 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv4 = __integer 2

lvl_swv6 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv6 = __integer 2

Rec {
g1_swuY [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 442 0}]
g1_swuY =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP :: GHC.Types.Double) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y1_akDO GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y1_akDO lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x1_akDN x1_akDN)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y1_akDO lvl_swv2) lvl_swv4)
              (GHC.Float.timesDouble x1_akDN z_akDP);
          GHC.Types.True -> GHC.Float.timesDouble x1_akDN z_akDP
        }
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Float.timesDouble x1_akDN x1_akDN)
          (GHC.Integer.Type.quotInteger y1_akDO lvl_swv6)
          z_akDP
    }
    }
end Rec }

lvl_swuS :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuS = __integer 1

lvl_swv8 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv8 = __integer 1

lvl_swva :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swva = __integer 2

lvl_swvc :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvc = __integer 2

Rec {
f_swuQ [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 372 0}]
f_swuQ =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y_akDB GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y_akDB lvl_swuS
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x_akDA x_akDA)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y_akDB lvl_swv8) lvl_swva)
              x_akDA;
          GHC.Types.True -> x_akDA
        }
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Float.timesDouble x_akDA x_akDA)
          (GHC.Integer.Type.quotInteger y_akDB lvl_swvc)
    }
    }
end Rec }

lvl_swuH :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuH = __integer 0

lvl_swuK :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuK = __integer 0

$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 152 0}]
$s^_swu6 =
  \ (eta_akDk :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger# eta1_akDl lvl_swuH
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# eta1_akDl lvl_swuK
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        }
        };
      GHC.Types.True -> lvl_swvg
    }
    }

lvl_swvh :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvh = GHC.Types.D# 2.0

a_swwS :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swwS = GHC.CString.unpackCString# "Fixed"#

a_swwV :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swwV = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swwX :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swwX = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swwT :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swwT =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvo :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvo =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swwT

a_swx0 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 60 0}]
a_swx0 = GHC.CString.unpackCString# "fromInteger"#

a_swx3 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 40 0}]
a_swx3 = GHC.CString.unpackCString# "base"#

a_swx5 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swx5 = GHC.CString.unpackCString# "GHC.Num"#

a_swx1 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swx1 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (a_swx3
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swx5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvw :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvw =
  Language.Haskell.TH.Syntax.Name
    (a_swx0
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swx1

a_swxS
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
a_swxS =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      x_akVD :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False, Guidance=NEVER}]
      x_akVD =
        let {
          rMax_swu0 :: GHC.Integer.Type.Integer
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 50 0}]
          rMax_swu0 =
            GHC.Real.toInteger
              @ (rep_avhN size_avhO)
              $dIntegral_avlP
              (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
        let {
          truncated_swu2 :: GHC.Integer.Type.Integer
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 540 0}]
          truncated_swu2 =
            case a_auGC of _ [Occ=Dead] { GHC.Types.D# x_aw80 ->
            case $s^_swu6
                   lvl_swvh
                   ($dKnownNat_avlM
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                            :: GHC.TypeLits.KnownNat frac_avhM ~# GHC.Integer.Type.Integer))
            of _ [Occ=Dead] { GHC.Types.D# y_aw84 ->
            case GHC.Integer.Type.decodeDoubleInteger
                   (GHC.Prim.*## x_aw80 y_aw84)
            of _ [Occ=Dead] { (# ipv_aw8Q, ipv1_aw8R #) ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ipv1_aw8R 0)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Integer.Type.shiftLInteger ipv_aw8Q ipv1_aw8R;
              GHC.Types.True ->
                let {
                  s_aw8X :: GHC.Prim.Int#
                  [LclId,
                   Str=DmdType,
                   Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                           ConLike=False, WorkFree=False, Expandable=True,
                           Guidance=IF_ARGS [] 1 0}]
                  s_aw8X = GHC.Prim.negateInt# ipv1_aw8R } in
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># s_aw8X 52)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger# ipv_aw8Q (__integer 0)
                    of wild3_aw92 { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild3_aw92
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        case GHC.Integer.Type.integerToInt ipv_aw8Q
                        of n_aw96 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.uncheckedIShiftRA# n_aw96 s_aw8X)
                        };
                      GHC.Types.True ->
                        case GHC.Integer.Type.integerToInt
                               (GHC.Integer.Type.negateInteger ipv_aw8Q)
                        of n_aw99 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.negateInt# (GHC.Prim.uncheckedIShiftRA# n_aw99 s_aw8X))
                        }
                    }
                    };
                  GHC.Types.True -> __integer 0
                }
            }
            }
            }
            } } in
        case GHC.Integer.Type.gtInteger# truncated_swu2 rMax_swu0
        of wild_akJ6 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ6
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              rMin_swu1 :: GHC.Integer.Type.Integer
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 50 0}]
              rMin_swu1 =
                GHC.Real.toInteger
                  @ (rep_avhN size_avhO)
                  $dIntegral_avlP
                  (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
            case GHC.Integer.Type.ltInteger# truncated_swu2 rMin_swu1
            of wild_a4It { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
            of _ [Occ=Dead] {
              GHC.Types.False -> truncated_swu2;
              GHC.Types.True -> rMin_swu1
            }
            };
          GHC.Types.True -> rMax_swu0
        }
        } } in
    \ (@ (m_awx9 :: * -> *))
      (w1_awxa :: Language.Haskell.TH.Syntax.Quasi m_awx9) ->
      case w1_awxa
      of _ [Occ=Dead]
      { Language.Haskell.TH.Syntax.D:Quasi ww1_awxd ww2_awxe ww3_awxf
                                           ww4_awxg ww5_awxh ww6_awxi ww7_awxj ww8_awxk ww9_awxl
                                           ww10_awxm ww11_awxn ww12_awxo ww13_awxp ww14_awxq
                                           ww15_awxr ww16_awxs ww17_awxt ww18_awxu ->
      case ww1_awxd
      of _ [Occ=Dead]
      { GHC.Base.D:Monad ww20_awxy ww21_awxz ww22_awxA ww23_awxB ->
      ww20_awxy
        @ Language.Haskell.TH.Syntax.Exp
        @ (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
        (ww20_awxy
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_awxA
              @ Language.Haskell.TH.Syntax.Exp
              (Language.Haskell.TH.Syntax.ConE lvl_swvo))
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_awxy
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                (ww20_awxy
                   @ Language.Haskell.TH.Syntax.Exp
                   @ Language.Haskell.TH.Syntax.Exp
                   (ww22_awxA
                      @ Language.Haskell.TH.Syntax.Exp
                      (Language.Haskell.TH.Syntax.VarE lvl_swvw))
                   (\ (x_Xd36 :: Language.Haskell.TH.Syntax.Exp) ->
                      ww20_awxy
                        @ Language.Haskell.TH.Syntax.Exp
                        @ Language.Haskell.TH.Syntax.Exp
                        (ww22_awxA
                           @ Language.Haskell.TH.Syntax.Exp
                           (Language.Haskell.TH.Syntax.LitE
                              (Language.Haskell.TH.Syntax.IntegerL x_akVD)))
                        (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                           ww22_awxA
                             @ Language.Haskell.TH.Syntax.Exp
                             (Language.Haskell.TH.Syntax.AppE x_Xd36 x1_acZX))))
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_awxA
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_awxD :: Language.Haskell.TH.Syntax.Exp) ->
           ww22_awxA
             @ (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
             (x_awxD
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:TExp[0]
                           <CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO>_N)
                      :: Language.Haskell.TH.Syntax.Exp
                           ~#
                         Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))
      }
      }

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.fLit =
  a_swxS
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 60 0}]
      repBV_swtT =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl_B4
           (tpl_B8
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_B1)
        `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        }
        } } in
    let {
      cobox_swtU
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      cobox_swtU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 50 0}]
      s_swtS =
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (repBV_swtT
              `cast` ((CLaSH.Sized.Vector.Vec
                         (Sym cobox_dw7d) <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
        } } in
    let {
      cobox_swtV
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      cobox_swtV =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    case tup_avmQ
    of _ [Occ=Dead]
    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl_Ba eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        };
      GHC.Types.True ->
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        }
    }
    }

lvl_swvz :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvz = __integer 0

lvl_swvy :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvy = __integer 0

lvl_swvB :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvB = __integer 0

lvl_swvA :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvA = __integer 0

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swtH =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swtI =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_swtI
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat_swtH
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_akJ3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ3
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          $dBounded_swtD :: GHC.Enum.Bounded (rep_avjs size2_avju)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBounded_swtD =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X1u
            } } in
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          fMax_swtA =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          $dBits_swtF :: Data.Bits.Bits (rep_avjs size1_avjt)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swtF =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X5L, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 43 0}]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (case tup_avnK
               of _ [Occ=Dead]
               { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
               (tpl_B6
                `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                        :: CLaSH.Class.Num.Resize rep_avjs
                             ~#
                           (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                            (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                            rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                 @ size2_avju @ size1_avjt $dKnownNat_swtH $dKnownNat_swtI fMax_swtA
               }) } in
        let {
          $dNum_swtE :: GHC.Num.Num (rep_avjs size1_avjt)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dNum_swtE =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            } } in
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFQ { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFQ)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 51 0}]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFQ)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvy)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvz)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 51 0}]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_XkFQ wild_akCB)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvA)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvB)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFG { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFG)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFG)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_XkFG wild_akCB)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 40 20}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_avxa
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_akCB { __DEFAULT ->
    GHC.Types.I# wild_akCB
    }

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

lvl_swvD :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvD = GHC.Types.C# '-'

lvl_swvC :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvC = __integer 0

lvl_swvG :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvG = GHC.Types.C# '0'

ds_swvM :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
ds_swvM = __integer 1

dt_akMa :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
dt_akMa = __integer 10

lvl_swvV
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40] 191 30}]
lvl_swvV =
  \ (ds_awe3
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    (case ds_awe3 of _ [Occ=Dead] { (x_awe6, y_awe7) ->
     case x_awe6 of _ [Occ=Dead] { GHC.Types.I# x1_awdC ->
     case x1_awdC of wild1_awdE {
       __DEFAULT -> GHC.Types.I# (GHC.Prim.+# wild1_awdE 1);
       9223372036854775807 -> GHC.Enum.$fEnumInt2
     }
     }
     },
     case ds_awe3 of _ [Occ=Dead] { (x_aweb, y_awec) ->
     case y_awec of _ [Occ=Dead] { GHC.Real.:% ww1_awdJ ww2_awdK ->
     case GHC.Real.$w$sreduce
            (GHC.Integer.Type.timesInteger ww1_awdJ dt_akMa)
            (GHC.Integer.Type.timesInteger ww2_awdK GHC.Real.$fEnumRatio1)
     of _ [Occ=Dead] { (# ww7_awdU, ww8_awdV #) ->
     GHC.Real.:% @ GHC.Integer.Type.Integer ww7_awdU ww8_awdV
     }
     }
     })

lvl_swvX :: GHC.Types.Int
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvX = GHC.Types.I# 0

lvl_sww5 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww5 = __integer 2

lvl_sww6 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww6 = __integer 1

lvl_sww7 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww7 = __integer 2

lvl_sww8 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww8 = __integer 1

lvl_sww4 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww4 = __integer 0

lvl_sww9 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww9 = __integer 2

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      nF_swti :: GHC.Types.Int
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 40 20}]
      nF_swti =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_avFx
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        } } in
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 30 0}]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 20 0}]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      a_swOO :: [GHC.Types.Char]
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False, Guidance=NEVER}]
      a_swOO =
        let {
          eta_awcR
            :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False, Guidance=NEVER}]
          eta_awcR =
            case GHC.List.iterateFB
                   @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                   @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                   (\ (x_awzz
                         :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
                      (r_awzA [OS=OneShot]
                         :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]) ->
                      case x_awzz of wild_afnB { (ds1_afnD, y_afnE) ->
                      case y_afnE of _ [Occ=Dead] { GHC.Real.:% ds1_awdp y_awdq ->
                      case GHC.Integer.Type.eqInteger# y_awdq ds_swvM
                      of wild_a2f3 { __DEFAULT ->
                      case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
                      of _ [Occ=Dead] {
                        GHC.Types.False -> r_awzA;
                        GHC.Types.True ->
                          GHC.Types.:
                            @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                            wild_afnB
                            r_awzA
                      }
                      }
                      }
                      })
                   lvl_swvV
                   (lvl_swvX,
                    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_sww4
                    of wild_a4It { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of _ [Occ=Dead] {
                          GHC.Types.False ->
                            let {
                              a_swOs :: GHC.Integer.Type.Integer
                              [LclId,
                               Str=DmdType,
                               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                       ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 72 0}]
                              a_swOs =
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                                of _ [Occ=Dead] {
                                  GHC.Types.False ->
                                    case x_awO9 of wild2_awOe {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_sww9 wild2_awOe;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of wild2_awOe {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_swtk
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_sww5 wild2_awOe) lvl_sww6))
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger fRepI_swtk (__integer 0))
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        };
                      GHC.Types.True ->
                        case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of _ [Occ=Dead] {
                          GHC.Types.False ->
                            let {
                              a_swOy :: GHC.Integer.Type.Integer
                              [LclId,
                               Str=DmdType,
                               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                       ConLike=False, WorkFree=False, Expandable=False,
                                       Guidance=IF_ARGS [] 72 0}]
                              a_swOy =
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                                of _ [Occ=Dead] {
                                  GHC.Types.False ->
                                    case x_awO9 of wild2_awOe {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_sww9 wild2_awOe;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of wild2_awOe {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_abs_swtj
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_sww7 wild2_awOe) lvl_sww8))
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger fRepI_abs_swtj (__integer 0))
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        }
                    }
                    })
            of _ [Occ=Dead] {
              [] ->
                Data.Maybe.fromJust1
                  @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer);
              : a1_awdh ds1_awdi -> a1_awdh
            } } in
        let {
          str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 80 30}]
          str_auHK =
            case eta_awcR of _ [Occ=Dead] { (x_awcZ, y_awd0) ->
            case y_awd0 of _ [Occ=Dead] { GHC.Real.:% x_awcK ds1_awcL ->
            case GHC.Show.$w$cshowsPrec
                   0 x_awcK (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
            }
            }
            } } in
        case eta_awcR of _ [Occ=Dead] { (x_awcU, y_awcV) ->
        case x_awcU of _ [Occ=Dead] { GHC.Types.I# x_akIV ->
        case GHC.List.$wlenAcc @ GHC.Types.Char str_auHK 0
        of ww_awOK { __DEFAULT ->
        let {
          n#_awbi :: GHC.Prim.Int#
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 1 0}]
          n#_awbi = GHC.Prim.-# x_akIV ww_awOK } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# n#_awbi 0)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            letrec {
              xs_awyT [Occ=LoopBreaker] :: GHC.Prim.Int# -> [GHC.Types.Char]
              [LclId,
               Arity=1,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=1, Value=True,
                       ConLike=True, WorkFree=True, Expandable=True,
                       Guidance=IF_ARGS [0] 63 60}]
              xs_awyT =
                \ (m_awz0 :: GHC.Prim.Int#) ->
                  case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# m_awz0 1)
                  of _ [Occ=Dead] {
                    GHC.Types.False ->
                      GHC.Types.:
                        @ GHC.Types.Char lvl_swvG (xs_awyT (GHC.Prim.-# m_awz0 1));
                    GHC.Types.True -> GHC.Types.: @ GHC.Types.Char lvl_swvG str_auHK
                  }; } in
            xs_awyT n#_awbi;
          GHC.Types.True -> str_auHK
        }
        }
        }
        } } in
    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swvC
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
        let {
          ww_al4F :: GHC.Prim.Int#
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 1 0}]
          ww_al4F = GHC.Prim.negateInt# x_aiKN } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftRInteger
                      fRepI_swtk (GHC.Prim.negateInt# ww_al4F))
                   (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char (GHC.Types.C# '.') a_swOO)
            };
          GHC.Types.True ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftLInteger fRepI_swtk ww_al4F)
                   (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char (GHC.Types.C# '.') a_swOO)
            }
        }
        };
      GHC.Types.True ->
        GHC.Base.++
          @ GHC.Types.Char
          (GHC.Types.:
             @ GHC.Types.Char
             lvl_swvD
             (case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
              let {
                ww_al4F :: GHC.Prim.Int#
                [LclId,
                 Str=DmdType,
                 Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                         ConLike=False, WorkFree=False, Expandable=True,
                         Guidance=IF_ARGS [] 1 0}]
                ww_al4F = GHC.Prim.negateInt# x_aiKN } in
              case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
              of _ [Occ=Dead] {
                GHC.Types.False ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftRInteger
                            fRepI_abs_swtj (GHC.Prim.negateInt# ww_al4F))
                         (GHC.Types.[] @ GHC.Types.Char)
                  of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  };
                GHC.Types.True ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftLInteger fRepI_abs_swtj ww_al4F)
                         (GHC.Types.[] @ GHC.Types.Char)
                  of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  }
              }
              }))
          (GHC.Types.: @ GHC.Types.Char (GHC.Types.C# '.') a_swOO)
    }
    }

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 90 0}]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.++
      @ GHC.Types.Char
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy
         x_a2fY)
      s_a2fZ

$cshowList_avIE
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId,
 Arity=6,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=6, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0] 150 0}]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_B2 :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta_B1 :: GHC.Base.String) ->
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (\ (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
         (s_a2fZ [OS=OneShot] :: GHC.Base.String) ->
         GHC.Base.++
           @ GHC.Types.Char
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY)
           s_a2fZ)
      eta_B2
      eta_B1

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl_X1B) ->
    case tpl_X1B of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
    ((tpl_X1z
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 430 0}]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swta
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swta =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1L, tpl_X1N, tpl_B3) ->
        tpl_X1N
        } } in
    let {
      $dBounded_swt9
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_swt9 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1N
        } } in
    let {
      $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swt8 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_swt7 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swt6
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swt6 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swt5
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swt5 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swt4
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swt4 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl_X24, tpl_B3) ->
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swt2 =
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X21, tpl_X23, tpl_X5p, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X43, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5q
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X46, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5n
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 430 0}]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swsS
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsS =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1M, tpl_X1O, tpl_B3) ->
        tpl_X1O
        } } in
    let {
      $dBounded_swsR
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_swsR =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1O
        } } in
    let {
      $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swsQ =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_swsP =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swsO
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsO =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swsN
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swsN =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swsM
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsM =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl_X25, tpl_B3) ->
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swsK =
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X45, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5r
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X48, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5o
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 130 0}]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    case tpl_X1N
    of _ [Occ=Dead]
    { (tpl_X1M, tpl_X1O, tpl_X3i, tpl_X3k, tpl_X3m, tpl_X3o, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       tpl_B9
       (GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl_B3 eta_X1I)
       (case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl_B3
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup_swsy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsy =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1V
        } } in
    let {
      $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsx =
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsw =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1X
        } } in
    let {
      $dKnownNat_swsv
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsv =
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsy
           of _ [Occ=Dead]
           { (tpl_X7i, tpl_X7l, tpl_X5n, tpl_X5p, tpl_X5r, tpl_X5t, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5t
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                    :: CLaSH.Class.Num.Resize rep_XuIL
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup_swsq
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsq =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1W
        } } in
    let {
      $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsp =
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swso =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsn
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsn =
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsq
           of _ [Occ=Dead]
           { (tpl_X7k, tpl_X7n, tpl_X5o, tpl_X5q, tpl_X5s, tpl_X5u, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5u
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                    :: CLaSH.Class.Num.Resize rep_XuIM
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup_swsi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsi =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsg =
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsf =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X22
        } } in
    let {
      $dKnownNat_swse
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swse =
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 222 0}]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup_sws8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws8 =
        case tup_XvDd
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Z
        } } in
    let {
      $dBits_sws7
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_sws7 =
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B3
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B6
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B7
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B8
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B9
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Ba
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bb
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bc
       })
      (case tup_XvDd
       of _ [Occ=Dead]
       { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
       ((tpl_B5
         `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                   <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                 :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                      ~#
                    (rep_XuIO size_XuIQ
                     -> rep_XuIO size_XuIQ
                     -> CLaSH.Class.Num.MResult
                          (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
          (eta_X1U
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ))
          (eta_X3N
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ)))
       `cast` (Sub cobox_dw1a
               ; Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                            GHC.TypeLits.+ size_XuIQ>_N
               :: CLaSH.Class.Num.MResult
                    (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       }
       })

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup_sws4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws4 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X20
        } } in
    let {
      $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_sws2 =
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws1 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X24
        } } in
    let {
      $dKnownNat_sws0
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_sws0 =
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     (a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
                     `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                             -> Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                             :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> rep_XuIQ size_XuIS)
                                  ~#
                                (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS))
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ((a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
       `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
               :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> rep_XuIQ size_XuIS)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)))
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         (\ ($dKnownNat_avB0
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (ds_dw0H
                                               :: CLaSH.Sized.Fixed.Fixed
                                                    frac_XuIN rep_XuIP size_XuIR) ->
                                            CLaSH.Class.BitVector.toBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avB0
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (ds_dw0H
                                               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                                                       :: CLaSH.Sized.Fixed.Fixed
                                                            frac_XuIN rep_XuIP size_XuIR
                                                            ~#
                                                          rep_XuIP size_XuIR)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR>_R
                                                 -> (CLaSH.Sized.Vector.Vec
                                                       (Sym
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))
                                                       <CLaSH.Bit.Bit>_R)_R
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (CLaSH.Sized.Fixed.Fixed
                                                                frac_XuIN rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit))
                                         (\ ($dKnownNat_avBa
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (bv_auGX
                                               :: CLaSH.Sized.Vector.Vec
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))
                                                    CLaSH.Bit.Bit) ->
                                            CLaSH.Class.BitVector.fromBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avBa
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (bv_auGX
                                               `cast` ((CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N)
                                                          <CLaSH.Bit.Bit>_R)_R
                                                       :: CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit
                                                            ~#
                                                          CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit>_R
                                                 -> Sym
                                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> rep_XuIP size_XuIR)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ((\ ($dKnownNat_avB0
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (ds_dw0H
             :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
          CLaSH.Class.BitVector.toBV
            @ (rep_XuIP size_XuIR)
            $dBitVector_XvCT
            ($dKnownNat_avB0
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (ds_dw0H
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                          ~#
                        rep_XuIP size_XuIR)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
               -> (CLaSH.Sized.Vector.Vec
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                     <CLaSH.Bit.Bit>_R)_R
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize
                           (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                        CLaSH.Bit.Bit)))
      ((\ ($dKnownNat_avBa
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (bv_auGX
             :: CLaSH.Sized.Vector.Vec
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                  CLaSH.Bit.Bit) ->
          CLaSH.Class.BitVector.fromBV
            @ (rep_XuIP size_XuIR)
            $dBitVector_XvCT
            ($dKnownNat_avBa
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (bv_auGX
             `cast` ((CLaSH.Sized.Vector.Vec
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                        <CLaSH.Bit.Bit>_R)_R
                     :: CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> rep_XuIP size_XuIR)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))

a_swC4
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swC4 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cdef_avAg =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
                          (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ((GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
      ((GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Ordering>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Ordering))
                         (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
                         (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ((GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Ordering>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Ordering)))
      ((GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
      ((GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))
                        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ((GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
      ((GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))

a_swC6 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swC6 = GHC.CString.unpackCString# "Fixed"#

a_swC9 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swC9 = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swCb :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swCb = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swC7 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swC7 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swC9
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCb
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwh :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swwh =
  Language.Haskell.TH.Syntax.Name
    (a_swC6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swC7

a_swCe :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swCe = GHC.CString.unpackCString# "Fixed"#

a_swCh :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swCh = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swCj :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swCj = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swCf :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swCf =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (a_swCh
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCj
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwp :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swwp =
  Language.Haskell.TH.Syntax.Name
    (a_swCe
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swCf

a_swCk
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swCk =
  \ (@ (m_a4Ni :: * -> *))
    (eta_a4Nj :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    GHC.Base.return
      @ m_a4Ni
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_a4Nj)
      @ Language.Haskell.TH.Syntax.Type
      (Language.Haskell.TH.Syntax.ConT lvl_swwp)

a_swCv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
a_swCv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    let {
      w1_acZp :: Language.Haskell.TH.Lib.ExpQ
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 1 0}]
      w1_acZp =
        ($dLift_avAq
         `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                   <rep_auGP size_auGQ>_N
                 :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                      ~#
                    (rep_auGP size_auGQ
                     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
          (f_auGR
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                        ~#
                      rep_auGP size_auGQ)) } in
    let {
      w1_akV2 :: Language.Haskell.TH.Lib.TypeQ
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False, Guidance=NEVER}]
      w1_akV2 =
        letrec {
          lgo_awhL [Occ=LoopBreaker]
            :: Language.Haskell.TH.Lib.TypeQ
               -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
          [LclId,
           Arity=2,
           Str=DmdType <L,U><S,1*U>,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=2, Value=True,
                   ConLike=True, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [0 30] 80 0}]
          lgo_awhL =
            \ (z_awhM :: Language.Haskell.TH.Lib.TypeQ)
              (ds_awhN :: [Language.Haskell.TH.Lib.TypeQ]) ->
              case ds_awhN of _ [Occ=Dead] {
                [] -> z_awhM;
                : x_awhS xs_awhT ->
                  lgo_awhL
                    ((Language.Haskell.TH.Lib.appT1 z_awhM x_awhS)
                     `cast` (Sym
                               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                  <Language.Haskell.TH.Syntax.Type>_N)
                             :: (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.Type)
                                  ~#
                                Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                    xs_awhT
              }; } in
        lgo_awhL
          (a_swCk
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          (GHC.Types.:
             @ Language.Haskell.TH.Lib.TypeQ
             (let {
                l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                [LclId,
                 Str=DmdType,
                 Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                         ConLike=False, WorkFree=False, Expandable=False,
                         Guidance=IF_ARGS [] 20 0}]
                l_a5DZ =
                  Language.Haskell.TH.Lib.numTyLit
                    ($dKnownNat_avAr
                     `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                             ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                             :: GHC.TypeLits.KnownNat frac_auGO
                                  ~#
                                GHC.Integer.Type.Integer)) } in
              (\ (@ (m_a5E0 :: * -> *))
                 (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                 GHC.Base.fmap
                   @ m_a5E0
                   (Control.Applicative.$p1Applicative
                      @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                   @ Language.Haskell.TH.Syntax.TyLit
                   @ Language.Haskell.TH.Syntax.Type
                   Language.Haskell.TH.Syntax.LitT
                   ((l_a5DZ
                     `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <Language.Haskell.TH.Syntax.TyLit>_N
                             :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                  ~#
                                (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                      @ m_a5E0 eta_a5E1))
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <Language.Haskell.TH.Syntax.Type>_N)
                      :: (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Type)
                           ~#
                         Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
             (GHC.Types.:
                @ Language.Haskell.TH.Lib.TypeQ
                (let {
                   x_X4Ts :: Language.Haskell.TH.Syntax.Name
                   [LclId,
                    Str=DmdType,
                    Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                            ConLike=False, WorkFree=False, Expandable=False,
                            Guidance=IF_ARGS [] 271 90}]
                   x_X4Ts =
                     case ($dTypeable_avAt
                           `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                                     <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                                   :: Data.Typeable.Internal.Typeable rep_auGP
                                        ~#
                                      (GHC.Prim.Proxy# rep_auGP -> Data.Typeable.Internal.TypeRep)))
                            (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP)
                     of _ [Occ=Dead]
                     { Data.Typeable.Internal.TypeRep ww1_awCq ww2_awCr ww3_awCs
                                                      ww4_awCt ->
                     case GHC.List.reverse1
                            @ GHC.Types.Char
                            (Data.Typeable.Internal.$w$cshowsPrec
                               GHC.Show.shows27 ww3_awCs ww4_awCt (GHC.Types.[] @ GHC.Types.Char))
                            (GHC.Types.[] @ GHC.Types.Char)
                     of _ [Occ=Dead] {
                       [] ->
                         Language.Haskell.TH.Syntax.Name
                           ((GHC.Types.[] @ GHC.Types.Char)
                            `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
                                    :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
                           Language.Haskell.TH.Syntax.NameS;
                       : ds_a5Fa rev_a5Fb ->
                         case ds_a5Fa of wild22_a5Fd { GHC.Types.C# ds1_a5Ff ->
                         case ds1_a5Ff of _ [Occ=Dead] {
                           __DEFAULT ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    wild22_a5Fd (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of _ [Occ=Dead] { (# ww1_a5Aw, ww2_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             };
                           '.' ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    wild22_a5Fd (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of _ [Occ=Dead] { (# ww1_a5Aw, ww2_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             }
                         }
                         }
                     }
                     } } in
                 (\ (@ (m_X4Tv :: * -> *))
                    (eta_X4Tx :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
                    GHC.Base.return
                      @ m_X4Tv
                      (Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_X4Tx)
                      @ Language.Haskell.TH.Syntax.Type
                      (Language.Haskell.TH.Syntax.ConT x_X4Ts))
                 `cast` (Sym
                           (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.Type>_N)
                         :: (forall (m_a4LE :: * -> *).
                             Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                             m_a4LE Language.Haskell.TH.Syntax.Type)
                              ~#
                            Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                (GHC.Types.:
                   @ Language.Haskell.TH.Lib.TypeQ
                   (let {
                      l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                      [LclId,
                       Str=DmdType,
                       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                               ConLike=False, WorkFree=False, Expandable=False,
                               Guidance=IF_ARGS [] 20 0}]
                      l_a5DZ =
                        Language.Haskell.TH.Lib.numTyLit
                          ($dKnownNat_avAs
                           `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                                   ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                                   :: GHC.TypeLits.KnownNat size_auGQ
                                        ~#
                                      GHC.Integer.Type.Integer)) } in
                    (\ (@ (m_a5E0 :: * -> *))
                       (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                       GHC.Base.fmap
                         @ m_a5E0
                         (Control.Applicative.$p1Applicative
                            @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                         @ Language.Haskell.TH.Syntax.TyLit
                         @ Language.Haskell.TH.Syntax.Type
                         Language.Haskell.TH.Syntax.LitT
                         ((l_a5DZ
                           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <Language.Haskell.TH.Syntax.TyLit>_N
                                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                        ~#
                                      (forall (m_a4LE :: * -> *).
                                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                       m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                            @ m_a5E0 eta_a5E1))
                    `cast` (Sym
                              (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                 <Language.Haskell.TH.Syntax.Type>_N)
                            :: (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.Type)
                                 ~#
                               Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)))) } in
    \ (@ (m_akV3 :: * -> *))
      (w2_akV4 :: Language.Haskell.TH.Syntax.Quasi m_akV3) ->
      case w2_akV4
      of _ [Occ=Dead]
      { Language.Haskell.TH.Syntax.D:Quasi ww1_akV7 ww2_akV8 ww3_akV9
                                           ww4_akVa ww5_akVb ww6_akVc ww7_akVd ww8_akVe ww9_akVf
                                           ww10_akVg ww11_akVh ww12_akVi ww13_akVj ww14_akVk
                                           ww15_akVl ww16_akVm ww17_akVn ww18_akVo ->
      case ww1_akV7
      of _ [Occ=Dead]
      { GHC.Base.D:Monad ww20_akVt ww21_akVu ww22_akVv ww23_akVw ->
      let {
        a_akVs :: GHC.Base.Monad m_akV3
        [LclId,
         Str=DmdType,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=True,
                 ConLike=True, WorkFree=True, Expandable=True,
                 Guidance=IF_ARGS [] 10 50}]
        a_akVs =
          GHC.Base.D:Monad
            @ m_akV3 ww20_akVt ww21_akVu ww22_akVv ww23_akVw } in
      let {
        eta_akVy :: Language.Haskell.TH.Syntax.Quasi m_akV3
        [LclId,
         Str=DmdType,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=True,
                 ConLike=True, WorkFree=True, Expandable=True,
                 Guidance=IF_ARGS [] 10 190}]
        eta_akVy =
          Language.Haskell.TH.Syntax.D:Quasi
            @ m_akV3
            a_akVs
            ww2_akV8
            ww3_akV9
            ww4_akVa
            ww5_akVb
            ww6_akVc
            ww7_akVd
            ww8_akVe
            ww9_akVf
            ww10_akVg
            ww11_akVh
            ww12_akVi
            ww13_akVj
            ww14_akVk
            ww15_akVl
            ww16_akVm
            ww17_akVn
            ww18_akVo } in
      ww20_akVt
        @ Language.Haskell.TH.Syntax.Exp
        @ Language.Haskell.TH.Syntax.Exp
        (let {
           a_acZP :: GHC.Base.Monad m_akV3
           [LclId,
            Str=DmdType,
            Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=True,
                    ConLike=True, WorkFree=True, Expandable=True,
                    Guidance=IF_ARGS [] 10 50}]
           a_acZP =
             GHC.Base.D:Monad
               @ m_akV3 ww20_akVt ww21_akVu ww22_akVv ww23_akVw } in
         let {
           eta_acZV :: Language.Haskell.TH.Syntax.Quasi m_akV3
           [LclId,
            Str=DmdType,
            Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=True,
                    ConLike=True, WorkFree=True, Expandable=True,
                    Guidance=IF_ARGS [] 10 190}]
           eta_acZV =
             Language.Haskell.TH.Syntax.D:Quasi
               @ m_akV3
               a_acZP
               ww2_akV8
               ww3_akV9
               ww4_akVa
               ww5_akVb
               ww6_akVc
               ww7_akVd
               ww8_akVe
               ww9_akVf
               ww10_akVg
               ww11_akVh
               ww12_akVi
               ww13_akVj
               ww14_akVk
               ww15_akVl
               ww16_akVm
               ww17_akVn
               ww18_akVo } in
         ww20_akVt
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_akVv
              @ Language.Haskell.TH.Syntax.Exp
              (Language.Haskell.TH.Syntax.ConE lvl_swwh))
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_akVt
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                ((w1_acZp
                  `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                            <Language.Haskell.TH.Syntax.Exp>_N
                          :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
                               ~#
                             (forall (m_a4LE :: * -> *).
                              Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                              m_a4LE Language.Haskell.TH.Syntax.Exp)))
                   @ m_akV3 eta_acZV)
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_akVv
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_akVz :: Language.Haskell.TH.Syntax.Exp) ->
           ww20_akVt
             @ Language.Haskell.TH.Syntax.Type
             @ Language.Haskell.TH.Syntax.Exp
             ((w1_akV2
               `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N
                       :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
                            ~#
                          (forall (m_a4LE :: * -> *).
                           Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                           m_a4LE Language.Haskell.TH.Syntax.Type)))
                @ m_akV3 eta_akVy)
             (\ (x1_akVA :: Language.Haskell.TH.Syntax.Type) ->
                ww22_akVv
                  @ Language.Haskell.TH.Syntax.Exp
                  (Language.Haskell.TH.Syntax.SigE x_akVz x1_akVA)))
      }
      }

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$clift_avAv =
  a_swCv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                              (rep_XuMX :: GHC.TypeLits.Nat -> *)
                              (size_XuMZ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
                       -> <GHC.TypeLits.KnownNat frac_XuMV>_R
                       -> <GHC.TypeLits.KnownNat size_XuMZ>_R
                       -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
                       :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  a_swCv
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Float out(FOS {Lam = Just 0, Consts = True, PAPs = True}):

==================== Levels added: ====================
<lvl_swvg,<0,0>>
<lvl_swvg,<0,0>> =
  GHC.Err.error
    @ GHC.Types.Double
    (let {
       <lvl_sxai,F<0,0>>
       <lvl_sxai,F<0,0>> =
         GHC.CString.unpackCString# "Negative exponent"# } in
     lvl_sxai)
<lvl_swve,<0,0>>
<lvl_swve,<0,0>> = GHC.Types.D# 1.0
<lvl_swv0,<0,0>>
<lvl_swv0,<0,0>> = __integer 1
<lvl_swv2,<0,0>>
<lvl_swv2,<0,0>> = __integer 1
<lvl_swv4,<0,0>>
<lvl_swv4,<0,0>> = __integer 2
<lvl_swv6,<0,0>>
<lvl_swv6,<0,0>> = __integer 2
<g1_swuY,<0,0>>
<g1_swuY,<0,0>> =
  \ <x1_akDN,<1,0>> <y1_akDO,<1,0>> <z_akDP,<1,0>> ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y1_akDO GHC.Real.even2) GHC.Real.even1
    of <wild_akF2,<1,1>> { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of <wild4_akDQ,<1,2>> {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y1_akDO lvl_swv0
        of <wild_a2f3,<1,3>> { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of <wild5_akDT,<1,4>> {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x1_akDN x1_akDN)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y1_akDO lvl_swv2) lvl_swv4)
              (GHC.Float.timesDouble x1_akDN z_akDP);
          GHC.Types.True -> GHC.Float.timesDouble x1_akDN z_akDP
        }
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Float.timesDouble x1_akDN x1_akDN)
          (GHC.Integer.Type.quotInteger y1_akDO lvl_swv6)
          z_akDP
    }
    };
<lvl_swuS,<0,0>>
<lvl_swuS,<0,0>> = __integer 1
<lvl_swv8,<0,0>>
<lvl_swv8,<0,0>> = __integer 1
<lvl_swva,<0,0>>
<lvl_swva,<0,0>> = __integer 2
<lvl_swvc,<0,0>>
<lvl_swvc,<0,0>> = __integer 2
<f_swuQ,<0,0>>
<f_swuQ,<0,0>> =
  \ <x_akDA,<1,0>> <y_akDB,<1,0>> ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y_akDB GHC.Real.even2) GHC.Real.even1
    of <wild_akF2,<1,1>> { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of <wild2_akDC,<1,2>> {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y_akDB lvl_swuS
        of <wild_a2f3,<1,3>> { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of <wild3_akDF,<1,4>> {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x_akDA x_akDA)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y_akDB lvl_swv8) lvl_swva)
              x_akDA;
          GHC.Types.True -> x_akDA
        }
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Float.timesDouble x_akDA x_akDA)
          (GHC.Integer.Type.quotInteger y_akDB lvl_swvc)
    }
    };
<lvl_swuH,<0,0>>
<lvl_swuH,<0,0>> = __integer 0
<lvl_swuK,<0,0>>
<lvl_swuK,<0,0>> = __integer 0
<$s^_swu6,<0,0>>
<$s^_swu6,<0,0>> =
  \ <eta_akDk,<1,0>> <eta1_akDl,<1,0>> ->
    case GHC.Integer.Type.ltInteger# eta1_akDl lvl_swuH
    of <wild_a4It,<1,1>> { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of <wild_akDp,<1,2>> {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# eta1_akDl lvl_swuK
        of <wild_a2f3,<1,3>> { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of <wild1_akDs,<1,4>> {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        }
        };
      GHC.Types.True -> lvl_swvg
    }
    }
<lvl_swvh,<0,0>>
<lvl_swvh,<0,0>> = GHC.Types.D# 2.0
<a_swwS,<0,0>>
<a_swwS,<0,0>> = GHC.CString.unpackCString# "Fixed"#
<a_swwV,<0,0>>
<a_swwV,<0,0>> = GHC.CString.unpackCString# "clash-prelude-0.5"#
<a_swwX,<0,0>>
<a_swwX,<0,0>> = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#
<a_swwT,<0,0>>
<a_swwT,<0,0>> =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))
<lvl_swvo,<0,0>>
<lvl_swvo,<0,0>> =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swwT
<a_swx0,<0,0>>
<a_swx0,<0,0>> = GHC.CString.unpackCString# "fromInteger"#
<a_swx3,<0,0>>
<a_swx3,<0,0>> = GHC.CString.unpackCString# "base"#
<a_swx5,<0,0>>
<a_swx5,<0,0>> = GHC.CString.unpackCString# "GHC.Num"#
<a_swx1,<0,0>>
<a_swx1,<0,0>> =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (a_swx3
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swx5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))
<lvl_swvw,<0,0>>
<lvl_swvw,<0,0>> =
  Language.Haskell.TH.Syntax.Name
    (a_swx0
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swx1
<a_swxS,<0,0>>
<a_swxS,<0,0>> =
  \ <frac_avhM,<1,0>>
    <rep_avhN,<1,0>>
    <size_avhO,<1,0>>
    <$dKnownNat_avlM,<1,0>>
    <$dNum_avlN,<1,0>>
    <$dBounded_avlO,<1,0>>
    <$dIntegral_avlP,<1,0>>
    <a_auGC,<1,0>> ->
    let {
      <x_akVD,<1,1>>
      <x_akVD,<1,1>> =
        let {
          <rMax_swu0,<1,1>>
          <rMax_swu0,<1,1>> =
            GHC.Real.toInteger
              @ (rep_avhN size_avhO)
              $dIntegral_avlP
              (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
        let {
          <truncated_swu2,<1,2>>
          <truncated_swu2,<1,2>> =
            case a_auGC of <wild_aw7Y,<1,2>> { GHC.Types.D# <x_aw80,<1,2>> ->
            case $s^_swu6
                   lvl_swvh
                   ($dKnownNat_avlM
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                            :: GHC.TypeLits.KnownNat frac_avhM ~# GHC.Integer.Type.Integer))
            of <wild1_aw82,<1,3>> { GHC.Types.D# <y_aw84,<1,3>> ->
            case GHC.Integer.Type.decodeDoubleInteger
                   (GHC.Prim.*## x_aw80 y_aw84)
            of <ds_aw8O,<1,4>> { (# <ipv_aw8Q,<1,4>>, <ipv1_aw8R,<1,4>> #) ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ipv1_aw8R 0)
            of <wild1_aw8T,<1,5>> {
              GHC.Types.False ->
                GHC.Integer.Type.shiftLInteger ipv_aw8Q ipv1_aw8R;
              GHC.Types.True ->
                let {
                  <s_aw8X,<1,6>>
                  <s_aw8X,<1,6>> = GHC.Prim.negateInt# ipv1_aw8R } in
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># s_aw8X 52)
                of <wild2_aw8Z,<1,7>> {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger#
                           ipv_aw8Q
                           (let {
                              <lvl_sxaj,F<0,0>>
                              <lvl_sxaj,F<0,0>> = __integer 0 } in
                            lvl_sxaj)
                    of <wild3_aw92,<1,8>> { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild3_aw92
                    of <wild4_aw93,<1,9>> {
                      GHC.Types.False ->
                        case GHC.Integer.Type.integerToInt ipv_aw8Q
                        of <n_aw96,<1,10>> { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.uncheckedIShiftRA# n_aw96 s_aw8X)
                        };
                      GHC.Types.True ->
                        case GHC.Integer.Type.integerToInt
                               (GHC.Integer.Type.negateInteger ipv_aw8Q)
                        of <n_aw99,<1,10>> { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.negateInt# (GHC.Prim.uncheckedIShiftRA# n_aw99 s_aw8X))
                        }
                    }
                    };
                  GHC.Types.True ->
                    let {
                      <lvl_sxak,F<0,0>>
                      <lvl_sxak,F<0,0>> = __integer 0 } in
                    lvl_sxak
                }
            }
            }
            }
            } } in
        case GHC.Integer.Type.gtInteger# truncated_swu2 rMax_swu0
        of <wild_akJ6,<1,3>> { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ6
        of <wild_X13,<1,4>> {
          GHC.Types.False ->
            let {
              <rMin_swu1,<1,5>>
              <rMin_swu1,<1,5>> =
                GHC.Real.toInteger
                  @ (rep_avhN size_avhO)
                  $dIntegral_avlP
                  (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
            case GHC.Integer.Type.ltInteger# truncated_swu2 rMin_swu1
            of <wild_a4It,<1,6>> { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
            of <wild_Xd,<1,7>> {
              GHC.Types.False -> truncated_swu2;
              GHC.Types.True -> rMin_swu1
            }
            };
          GHC.Types.True -> rMax_swu0
        }
        } } in
    \ <m_awx9,<2,0>> <w1_awxa,<2,0>> ->
      case w1_awxa
      of <ww_awxb,<2,1>>
      { Language.Haskell.TH.Syntax.D:Quasi <ww1_awxd,<2,1>>
                                           <ww2_awxe,<2,1>> <ww3_awxf,<2,1>> <ww4_awxg,<2,1>>
                                           <ww5_awxh,<2,1>> <ww6_awxi,<2,1>> <ww7_awxj,<2,1>>
                                           <ww8_awxk,<2,1>> <ww9_awxl,<2,1>> <ww10_awxm,<2,1>>
                                           <ww11_awxn,<2,1>> <ww12_awxo,<2,1>> <ww13_awxp,<2,1>>
                                           <ww14_awxq,<2,1>> <ww15_awxr,<2,1>> <ww16_awxs,<2,1>>
                                           <ww17_awxt,<2,1>> <ww18_awxu,<2,1>> ->
      case ww1_awxd
      of <ww19_awxw,<2,2>>
      { GHC.Base.D:Monad <ww20_awxy,<2,2>> <ww21_awxz,<2,2>>
                         <ww22_awxA,<2,2>> <ww23_awxB,<2,2>> ->
      ww20_awxy
        @ Language.Haskell.TH.Syntax.Exp
        @ (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
        (ww20_awxy
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_awxA
              @ Language.Haskell.TH.Syntax.Exp
              (let {
                 <lvl_sxal,F<0,0>>
                 <lvl_sxal,F<0,0>> = Language.Haskell.TH.Syntax.ConE lvl_swvo } in
               lvl_sxal))
           (\ <x_acZW,<3,0>> ->
              ww20_awxy
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                (let {
                   <lvl_sxap,F<2,2>>
                   <lvl_sxap,F<2,2>> =
                     ww20_awxy
                       @ Language.Haskell.TH.Syntax.Exp
                       @ Language.Haskell.TH.Syntax.Exp
                       (ww22_awxA
                          @ Language.Haskell.TH.Syntax.Exp
                          (let {
                             <lvl_sxam,F<0,0>>
                             <lvl_sxam,F<0,0>> = Language.Haskell.TH.Syntax.VarE lvl_swvw } in
                           lvl_sxam))
                       (\ <x_Xd36,<3,0>> ->
                          ww20_awxy
                            @ Language.Haskell.TH.Syntax.Exp
                            @ Language.Haskell.TH.Syntax.Exp
                            (let {
                               <lvl_sxao,F<2,2>>
                               <lvl_sxao,F<2,2>> =
                                 ww22_awxA
                                   @ Language.Haskell.TH.Syntax.Exp
                                   (let {
                                      <lvl_sxan,F<1,1>>
                                      <lvl_sxan,F<1,1>> =
                                        Language.Haskell.TH.Syntax.LitE
                                          (Language.Haskell.TH.Syntax.IntegerL x_akVD) } in
                                    lvl_sxan) } in
                             lvl_sxao)
                            (\ <x1_acZX,<4,0>> ->
                               ww22_awxA
                                 @ Language.Haskell.TH.Syntax.Exp
                                 (Language.Haskell.TH.Syntax.AppE x_Xd36 x1_acZX))) } in
                 lvl_sxap)
                (\ <x1_acZX,<4,0>> ->
                   ww22_awxA
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ <x_awxD,<3,0>> ->
           ww22_awxA
             @ (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
             (x_awxD
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:TExp[0]
                           <CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO>_N)
                      :: Language.Haskell.TH.Syntax.Exp
                           ~#
                         Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))
      }
      }
<CLaSH.Sized.Fixed.fLit,<0,0>>
<CLaSH.Sized.Fixed.fLit,<0,0>> =
  a_swxS
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))
<CLaSH.Sized.Fixed.satN2,<0,0>>
<CLaSH.Sized.Fixed.satN2,<0,0>> =
  \ <rep_aviy,<1,0>>
    <n_aviz,<1,0>>
    <tup_avmQ,<1,0>>
    <eta_B1,<1,0>> ->
    let {
      <repBV_swtT,<1,1>>
      <repBV_swtT,<1,1>> =
        case tup_avmQ
        of <wild_XY,<1,1>>
        { (<tpl_X1g,<1,1>>, <tpl_B2,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>, <tpl_B7,<1,1>>, <tpl_B8,<1,1>>, <tpl_B9,<1,1>>, <tpl_Ba,<1,1>>) ->
        case tpl_B6
        of <cobox_avJ3,<1,2>> { GHC.Types.Eq# <cobox_dw6Z,<1,2>> ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl_B4
           (tpl_B8
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_B1)
        `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        }
        } } in
    let {
      <cobox_swtU,<1,2>>
      <cobox_swtU,<1,2>> =
        case tup_avmQ
        of <wild_X14,<1,2>>
        { (<tpl_X1l,<1,2>>, <tpl_B2,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>) ->
        tpl_B2
        } } in
    let {
      <s_swtS,<1,3>>
      <s_swtS,<1,3>> =
        case cobox_swtU
        of <cobox_avJi,<1,3>> { GHC.Types.Eq# <cobox_dw7d,<1,3>> ->
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (repBV_swtT
              `cast` ((CLaSH.Sized.Vector.Vec
                         (Sym cobox_dw7d) <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
        } } in
    let {
      <cobox_swtV,<1,4>>
      <cobox_swtV,<1,4>> =
        case tup_avmQ
        of <wild_X10,<1,4>>
        { (<tpl_X1i,<1,4>>, <tpl_B2,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B5
        } } in
    case tup_avmQ
    of <wild_X1c,<1,5>>
    { (<tpl_X1t,<1,5>>, <tpl_B2,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl_Ba eta_B1
    of <wild_X5J,<1,6>> {
      GHC.Types.False ->
        case cobox_swtU
        of <cobox_avJ8,<1,7>> { GHC.Types.Eq# <cobox_dw7j,<1,7>> ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of <wild_Xu,<1,8>> {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of <wild_Xv,<1,9>> {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV
                   of <cobox_XvJ5,<1,10>> { GHC.Types.Eq# <cobox_dw7b,<1,10>> ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV
                   of <cobox_XvJ4,<1,10>> { GHC.Types.Eq# <cobox_dw7c,<1,10>> ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of <wild_Xv,<1,9>> {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV
                   of <cobox_XvJ5,<1,10>> { GHC.Types.Eq# <cobox_dw7b,<1,10>> ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV
                   of <cobox_XvJ4,<1,10>> { GHC.Types.Eq# <cobox_dw7c,<1,10>> ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        };
      GHC.Types.True ->
        case cobox_swtU
        of <cobox_avJ8,<1,7>> { GHC.Types.Eq# <cobox_dw7j,<1,7>> ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of <wild_Xu,<1,8>> {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of <wild_Xv,<1,9>> {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV
                   of <cobox_XvJ7,<1,10>> { GHC.Types.Eq# <cobox_dw79,<1,10>> ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV
                   of <cobox_avJl,<1,10>> { GHC.Types.Eq# <cobox_dw7a,<1,10>> ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of <wild_Xv,<1,9>> {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV
                   of <cobox_XvJ7,<1,10>> { GHC.Types.Eq# <cobox_dw79,<1,10>> ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV
                   of <cobox_avJl,<1,10>> { GHC.Types.Eq# <cobox_dw7a,<1,10>> ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        }
    }
    }
<lvl_swvz,<0,0>>
<lvl_swvz,<0,0>> = __integer 0
<lvl_swvy,<0,0>>
<lvl_swvy,<0,0>> = __integer 0
<lvl_swvB,<0,0>>
<lvl_swvB,<0,0>> = __integer 0
<lvl_swvA,<0,0>>
<lvl_swvA,<0,0>> = __integer 0
<CLaSH.Sized.Fixed.resizeF,<0,0>>
<CLaSH.Sized.Fixed.resizeF,<0,0>> =
  \ <frac1_avjq,<1,0>>
    <frac2_avjr,<1,0>>
    <rep_avjs,<1,0>>
    <size1_avjt,<1,0>>
    <size2_avju,<1,0>>
    <tup_avnK,<1,0>>
    <eta_B1,<1,0>> ->
    let {
      <$dKnownNat_swtH,<1,1>>
      <$dKnownNat_swtH,<1,1>> =
        case tup_avnK
        of <wild_X12,<1,1>>
        { (<tpl_X1k,<1,1>>, <tpl_B2,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>, <tpl_B7,<1,1>>, <tpl_B8,<1,1>>, <tpl_B9,<1,1>>, <tpl_Ba,<1,1>>, <tpl_Bb,<1,1>>, <tpl_Bc,<1,1>>) ->
        tpl_B7
        } } in
    let {
      <$dKnownNat_swtI,<1,2>>
      <$dKnownNat_swtI,<1,2>> =
        case tup_avnK
        of <wild_X10,<1,2>>
        { (<tpl_X1i,<1,2>>, <tpl_B2,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B8
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_swtI
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat_swtH
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of <wild_akJ3,<1,3>> { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ3
    of <wild_X1o,<1,4>> {
      GHC.Types.False ->
        let {
          <$dBounded_swtD,<1,5>>
          <$dBounded_swtD,<1,5>> =
            case tup_avnK
            of <wild_X1e,<1,5>>
            { (<tpl_X1u,<1,5>>, <tpl_B2,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>, <tpl_Bb,<1,5>>, <tpl_Bc,<1,5>>) ->
            tpl_X1u
            } } in
        let {
          <fMax_swtA,<1,6>>
          <fMax_swtA,<1,6>> =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          <$dBits_swtF,<1,7>>
          <$dBits_swtF,<1,7>> =
            case tup_avnK
            of <wild_X16,<1,7>>
            { (<tpl_X5L,<1,7>>, <tpl_B2,<1,7>>, <tpl_B3,<1,7>>, <tpl_B4,<1,7>>, <tpl_B5,<1,7>>, <tpl_B6,<1,7>>, <tpl_B7,<1,7>>, <tpl_B8,<1,7>>, <tpl_B9,<1,7>>, <tpl_Ba,<1,7>>, <tpl_Bb,<1,7>>, <tpl_Bc,<1,7>>) ->
            tpl_B5
            } } in
        let {
          <mask_swtz,<1,8>>
          <mask_swtz,<1,8>> =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (case tup_avnK
               of <wild_X14,<1,8>>
               { (<tpl_X1m,<1,8>>, <tpl_B2,<1,8>>, <tpl_B3,<1,8>>, <tpl_B4,<1,8>>, <tpl_B5,<1,8>>, <tpl_B6,<1,8>>, <tpl_B7,<1,8>>, <tpl_B8,<1,8>>, <tpl_B9,<1,8>>, <tpl_Ba,<1,8>>, <tpl_Bb,<1,8>>, <tpl_Bc,<1,8>>) ->
               (tpl_B6
                `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                        :: CLaSH.Class.Num.Resize rep_avjs
                             ~#
                           (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                            (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                            rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                 @ size2_avju @ size1_avjt $dKnownNat_swtH $dKnownNat_swtI fMax_swtA
               }) } in
        let {
          <$dNum_swtE,<1,9>>
          <$dNum_swtE,<1,9>> =
            case tup_avnK
            of <wild_X1a,<1,9>>
            { (<tpl_X1r,<1,9>>, <tpl_B2,<1,9>>, <tpl_B3,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_B4
            } } in
        case tup_avnK
        of <wild_X1g,<1,10>>
        { (<tpl_X1y,<1,10>>, <tpl_B2,<1,10>>, <tpl_B3,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of <wild_akCB,<1,11>> { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of <wild_XkFQ,<1,12>> { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFQ)
        of <wild_Xr,<1,13>> {
          GHC.Types.False ->
            let {
              <shiftedR_swty,<1,14>>
              <shiftedR_swty,<1,14>> =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFQ)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvy)
            of <wild_Xv,<1,15>> {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of <wild_Xw,<1,16>> {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvz)
                of <wild_Xw,<1,16>> {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              <shiftedL_swtK,<1,14>>
              <shiftedL_swtK,<1,14>> =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_XkFQ wild_akCB)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvA)
            of <wild_Xv,<1,15>> {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of <wild_Xw,<1,16>> {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvB)
                of <wild_Xw,<1,16>> {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_avnK
        of <wild_X1g,<1,5>>
        { (<tpl_X1y,<1,5>>, <tpl_B2,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>, <tpl_Bb,<1,5>>, <tpl_Bc,<1,5>>) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of <wild_akCB,<1,6>> { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of <wild_XkFG,<1,7>> { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFG)
        of <wild_Xo,<1,8>> {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFG)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_XkFG wild_akCB)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
        }
        }
        }
    }
    }
<CLaSH.Sized.Fixed.asRepProxy,<0,0>>
<CLaSH.Sized.Fixed.asRepProxy,<0,0>> =
  \ <frac_avk6,<1,0>>
    <rep_avk7,<1,0>>
    <size_avk8,<1,0>>
    <ds_dvZa,<1,0>> ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7
<CLaSH.Sized.Fixed.asFracProxy,<0,0>>
<CLaSH.Sized.Fixed.asFracProxy,<0,0>> =
  \ <frac_avkp,<1,0>>
    <rep_avkq,<1,0>>
    <size_avkr,<1,0>>
    <ds_dvZf,<1,0>> ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp
<CLaSH.Sized.Fixed.fracShift,<0,0>>
<CLaSH.Sized.Fixed.fracShift,<0,0>> =
  \ <frac_avjN,<1,0>>
    <rep_avjO,<1,0>>
    <size_avjP,<1,0>>
    <$dKnownNat_avxa,<1,0>>
    <f_auGd,<1,0>> ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_avxa
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of <wild_akCB,<1,1>> { __DEFAULT ->
    GHC.Types.I# wild_akCB
    }
<a_swaI,<0,0>>
<a_swaI,<0,0>> =
  \ <int_avkK,<1,0>> <frac_avkL,<1,0>> <ds_dvZi,<1,0>> -> ds_dvZi
<CLaSH.Sized.Fixed.unUF,<0,0>>
<CLaSH.Sized.Fixed.unUF,<0,0>> =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))
<a_swaJ,<0,0>>
<a_swaJ,<0,0>> =
  \ <frac_avl5,<1,0>>
    <int_avl6,<1,0>>
    <ds_dvZp,<1,0>>
    <fRep_auGb,<1,0>> ->
    fRep_auGb
<CLaSH.Sized.Fixed.uf,<0,0>>
<CLaSH.Sized.Fixed.uf,<0,0>> =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))
<a_swaK,<0,0>>
<a_swaK,<0,0>> =
  \ <int_avlp,<1,0>> <frac_avlq,<1,0>> <ds_dvZu,<1,0>> -> ds_dvZu
<CLaSH.Sized.Fixed.unSF,<0,0>>
<CLaSH.Sized.Fixed.unSF,<0,0>> =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))
<a_swaL,<0,0>>
<a_swaL,<0,0>> =
  \ <frac_avlK,<1,0>>
    <int_avlL,<1,0>>
    <ds_dvZB,<1,0>>
    <fRep_auG9,<1,0>> ->
    fRep_auG9
<CLaSH.Sized.Fixed.sf,<0,0>>
<CLaSH.Sized.Fixed.sf,<0,0>> =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))
<a_swaM,<0,0>>
<a_swaM,<0,0>> =
  \ <frac_auI2,<1,0>>
    <rep_auI3,<1,0>>
    <size_auI4,<1,0>>
    <ds_dvZF,<1,0>> ->
    ds_dvZF
<CLaSH.Sized.Fixed.unFixed,<0,0>>
<CLaSH.Sized.Fixed.unFixed,<0,0>> =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))
<lvl_swvD,<0,0>>
<lvl_swvD,<0,0>> = GHC.Types.C# '-'
<lvl_swvC,<0,0>>
<lvl_swvC,<0,0>> = __integer 0
<lvl_swvG,<0,0>>
<lvl_swvG,<0,0>> = GHC.Types.C# '0'
<ds_swvM,<0,0>>
<ds_swvM,<0,0>> = __integer 1
<dt_akMa,<0,0>>
<dt_akMa,<0,0>> = __integer 10
<lvl_swvV,<0,0>>
<lvl_swvV,<0,0>> =
  \ <ds_awe3,<1,0>> ->
    (case ds_awe3
     of <wild_awe4,<1,1>> { (<x_awe6,<1,1>>, <y_awe7,<1,1>>) ->
     case x_awe6 of <wild_awdA,<1,2>> { GHC.Types.I# <x1_awdC,<1,2>> ->
     case x1_awdC of <wild1_awdE,<1,3>> {
       __DEFAULT -> GHC.Types.I# (GHC.Prim.+# x1_awdC 1);
       9223372036854775807 -> GHC.Enum.$fEnumInt2
     }
     }
     },
     case ds_awe3
     of <wild_awe9,<1,1>> { (<x_aweb,<1,1>>, <y_awec,<1,1>>) ->
     case y_awec
     of <ww_awdH,<1,2>>
     { GHC.Real.:% <ww1_awdJ,<1,2>> <ww2_awdK,<1,2>> ->
     case GHC.Real.$w$sreduce
            (GHC.Integer.Type.timesInteger ww1_awdJ dt_akMa)
            (GHC.Integer.Type.timesInteger ww2_awdK GHC.Real.$fEnumRatio1)
     of <ww6_awdS,<1,3>> { (# <ww7_awdU,<1,3>>, <ww8_awdV,<1,3>> #) ->
     GHC.Real.:% @ GHC.Integer.Type.Integer ww7_awdU ww8_awdV
     }
     }
     })
<lvl_swvX,<0,0>>
<lvl_swvX,<0,0>> = GHC.Types.I# 0
<lvl_sww5,<0,0>>
<lvl_sww5,<0,0>> = __integer 2
<lvl_sww6,<0,0>>
<lvl_sww6,<0,0>> = __integer 1
<lvl_sww7,<0,0>>
<lvl_sww7,<0,0>> = __integer 2
<lvl_sww8,<0,0>>
<lvl_sww8,<0,0>> = __integer 1
<lvl_sww4,<0,0>>
<lvl_sww4,<0,0>> = __integer 0
<lvl_sww9,<0,0>>
<lvl_sww9,<0,0>> = __integer 2
<$cshow_avFD,<0,0>>
<$cshow_avFD,<0,0>> =
  \ <frac_auHx,<1,0>>
    <rep_auHy,<1,0>>
    <size_auHz,<1,0>>
    <$dShow_avFv,<1,0>>
    <$dBits_avFw,<1,0>>
    <$dKnownNat_avFx,<1,0>>
    <$dIntegral_avFy,<1,0>>
    <f_auHA,<1,0>> ->
    let {
      <nF_swti,<1,1>>
      <nF_swti,<1,1>> =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_avFx
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of <wild_akCB,<1,1>> { __DEFAULT ->
        GHC.Types.I# wild_akCB
        } } in
    let {
      <fRepI_swtk,<1,2>>
      <fRepI_swtk,<1,2>> =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      <fRepI_abs_swtj,<1,3>>
      <fRepI_abs_swtj,<1,3>> =
        GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      <a_swOO,<1,4>>
      <a_swOO,<1,4>> =
        let {
          <eta_awcR,<1,4>>
          <eta_awcR,<1,4>> =
            case GHC.List.iterateFB
                   @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                   @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                   (let {
                      <lvl_sxaq,F<0,0>>
                      <lvl_sxaq,F<0,0>> =
                        \ <x_awzz,<1,0>> <r_awzA,<1,0>> ->
                          case x_awzz
                          of <wild_afnB,<1,1>> { (<ds1_afnD,<1,1>>, <y_afnE,<1,1>>) ->
                          case y_afnE
                          of <wild_awdn,<1,2>>
                          { GHC.Real.:% <ds1_awdp,<1,2>> <y_awdq,<1,2>> ->
                          case GHC.Integer.Type.eqInteger# y_awdq ds_swvM
                          of <wild_a2f3,<1,3>> { __DEFAULT ->
                          case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
                          of <wild_awzB,<1,4>> {
                            GHC.Types.False -> r_awzA;
                            GHC.Types.True ->
                              GHC.Types.:
                                @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                                x_awzz
                                r_awzA
                          }
                          }
                          }
                          } } in
                    lvl_sxaq)
                   lvl_swvV
                   (lvl_swvX,
                    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_sww4
                    of <wild_a4It,<1,4>> { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
                    of <wild_X1C,<1,5>> {
                      GHC.Types.False ->
                        case nF_swti of <wild_awO7,<1,6>> { GHC.Types.I# <x_awO9,<1,6>> ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of <wild1_awOb,<1,7>> {
                          GHC.Types.False ->
                            let {
                              <a_swOs,<1,8>>
                              <a_swOs,<1,8>> =
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                                of <wild1_XwRo,<1,8>> {
                                  GHC.Types.False ->
                                    case x_awO9 of <wild2_awOe,<1,9>> {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_sww9 x_awO9;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of <wild2_awOe,<1,9>> {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_swtk
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_sww5 x_awO9) lvl_sww6))
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of <ww_awf3,<1,10>> { (# <ww1_awf5,<1,10>>, <ww2_awf6,<1,10>> #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_swtk
                                             (let {
                                                <lvl_sxar,F<0,0>>
                                                <lvl_sxar,F<0,0>> = __integer 0 } in
                                              lvl_sxar))
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of <ww_awf3,<1,10>> { (# <ww1_awf5,<1,10>>, <ww2_awf6,<1,10>> #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of <wild_00,<1,8>> { }
                        }
                        };
                      GHC.Types.True ->
                        case nF_swti of <wild_awO7,<1,6>> { GHC.Types.I# <x_awO9,<1,6>> ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of <wild1_awOb,<1,7>> {
                          GHC.Types.False ->
                            let {
                              <a_swOy,<1,8>>
                              <a_swOy,<1,8>> =
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                                of <wild1_XwRo,<1,8>> {
                                  GHC.Types.False ->
                                    case x_awO9 of <wild2_awOe,<1,9>> {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_sww9 x_awO9;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of <wild2_awOe,<1,9>> {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_abs_swtj
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_sww7 x_awO9) lvl_sww8))
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of <ww_awf3,<1,10>> { (# <ww1_awf5,<1,10>>, <ww2_awf6,<1,10>> #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_abs_swtj
                                             (let {
                                                <lvl_sxas,F<0,0>>
                                                <lvl_sxas,F<0,0>> = __integer 0 } in
                                              lvl_sxas))
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of <ww_awf3,<1,10>> { (# <ww1_awf5,<1,10>>, <ww2_awf6,<1,10>> #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of <wild_00,<1,8>> { }
                        }
                        }
                    }
                    })
            of <wild_awde,<1,4>> {
              [] ->
                Data.Maybe.fromJust1
                  @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer);
              : <a1_awdh,<1,4>> <ds1_awdi,<1,4>> -> a1_awdh
            } } in
        let {
          <str_auHK,<1,5>>
          <str_auHK,<1,5>> =
            case eta_awcR
            of <wild_awcX,<1,5>> { (<x_awcZ,<1,5>>, <y_awd0,<1,5>>) ->
            case y_awd0
            of <wild_awcI,<1,6>>
            { GHC.Real.:% <x_awcK,<1,6>> <ds1_awcL,<1,6>> ->
            case GHC.Show.$w$cshowsPrec
                   0 x_awcK (GHC.Types.[] @ GHC.Types.Char)
            of <ww2_a2hY,<1,7>> { (# <ww3_a2i0,<1,7>>, <ww4_a2i1,<1,7>> #) ->
            GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
            }
            }
            } } in
        case eta_awcR
        of <wild_awcS,<1,6>> { (<x_awcU,<1,6>>, <y_awcV,<1,6>>) ->
        case x_awcU of <wild_akIT,<1,7>> { GHC.Types.I# <x_akIV,<1,7>> ->
        case GHC.List.$wlenAcc @ GHC.Types.Char str_auHK 0
        of <ww_awOK,<1,8>> { __DEFAULT ->
        let {
          <n#_awbi,<1,9>>
          <n#_awbi,<1,9>> = GHC.Prim.-# x_akIV ww_awOK } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# n#_awbi 0)
        of <wild1_awbk,<1,10>> {
          GHC.Types.False ->
            letrec {
              <xs_awyT,<1,11>>
              <xs_awyT,<1,11>> =
                \ <m_awz0,<2,0>> ->
                  case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# m_awz0 1)
                  of <wild_awz1,<2,1>> {
                    GHC.Types.False ->
                      GHC.Types.:
                        @ GHC.Types.Char lvl_swvG (xs_awyT (GHC.Prim.-# m_awz0 1));
                    GHC.Types.True ->
                      let {
                        <lvl_sxat,F<1,5>>
                        <lvl_sxat,F<1,5>> =
                          GHC.Types.: @ GHC.Types.Char lvl_swvG str_auHK } in
                      lvl_sxat
                  }; } in
            xs_awyT n#_awbi;
          GHC.Types.True -> str_auHK
        }
        }
        }
        } } in
    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swvC
    of <wild_a4It,<1,5>> { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of <wild_X1C,<1,6>> {
      GHC.Types.False ->
        case nF_swti of <wild_aiKL,<1,7>> { GHC.Types.I# <x_aiKN,<1,7>> ->
        let {
          <ww_al4F,<1,8>>
          <ww_al4F,<1,8>> = GHC.Prim.negateInt# x_aiKN } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
        of <wild_al4G,<1,9>> {
          GHC.Types.False ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftRInteger
                      fRepI_swtk (GHC.Prim.negateInt# ww_al4F))
                   (GHC.Types.[] @ GHC.Types.Char)
            of <ww2_a2hY,<1,10>>
            { (# <ww3_a2i0,<1,10>>, <ww4_a2i1,<1,10>> #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.:
                 @ GHC.Types.Char
                 (let {
                    <lvl_sxau,F<0,0>>
                    <lvl_sxau,F<0,0>> = GHC.Types.C# '.' } in
                  lvl_sxau)
                 a_swOO)
            };
          GHC.Types.True ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftLInteger fRepI_swtk ww_al4F)
                   (GHC.Types.[] @ GHC.Types.Char)
            of <ww2_a2hY,<1,10>>
            { (# <ww3_a2i0,<1,10>>, <ww4_a2i1,<1,10>> #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.:
                 @ GHC.Types.Char
                 (let {
                    <lvl_sxav,F<0,0>>
                    <lvl_sxav,F<0,0>> = GHC.Types.C# '.' } in
                  lvl_sxav)
                 a_swOO)
            }
        }
        };
      GHC.Types.True ->
        GHC.Base.++
          @ GHC.Types.Char
          (GHC.Types.:
             @ GHC.Types.Char
             lvl_swvD
             (case nF_swti of <wild_aiKL,<1,7>> { GHC.Types.I# <x_aiKN,<1,7>> ->
              let {
                <ww_al4F,<1,8>>
                <ww_al4F,<1,8>> = GHC.Prim.negateInt# x_aiKN } in
              case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
              of <wild_al4G,<1,9>> {
                GHC.Types.False ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftRInteger
                            fRepI_abs_swtj (GHC.Prim.negateInt# ww_al4F))
                         (GHC.Types.[] @ GHC.Types.Char)
                  of <ww2_a2hY,<1,10>>
                  { (# <ww3_a2i0,<1,10>>, <ww4_a2i1,<1,10>> #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  };
                GHC.Types.True ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftLInteger fRepI_abs_swtj ww_al4F)
                         (GHC.Types.[] @ GHC.Types.Char)
                  of <ww2_a2hY,<1,10>>
                  { (# <ww3_a2i0,<1,10>>, <ww4_a2i1,<1,10>> #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  }
              }
              }))
          (GHC.Types.:
             @ GHC.Types.Char
             (let {
                <lvl_sxaw,F<0,0>>
                <lvl_sxaw,F<0,0>> = GHC.Types.C# '.' } in
              lvl_sxaw)
             a_swOO)
    }
    }
<$cshowsPrec_avFB,<0,0>>
<$cshowsPrec_avFB,<0,0>> =
  \ <frac_auHx,<1,0>>
    <rep_auHy,<1,0>>
    <size_auHz,<1,0>>
    <$dShow_avFv,<1,0>>
    <$dBits_avFw,<1,0>>
    <$dKnownNat_avFx,<1,0>>
    <$dIntegral_avFy,<1,0>>
    <ds_a2fX,<1,0>>
    <x_a2fY,<1,0>>
    <s_a2fZ,<1,0>> ->
    GHC.Base.++
      @ GHC.Types.Char
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy
         x_a2fY)
      s_a2fZ
<$cshowList_avIE,<0,0>>
<$cshowList_avIE,<0,0>> =
  \ <frac_auHx,<1,0>>
    <rep_auHy,<1,0>>
    <size_auHz,<1,0>>
    <$dShow_avFv,<1,0>>
    <$dBits_avFw,<1,0>>
    <$dKnownNat_avFx,<1,0>>
    <$dIntegral_avFy,<1,0>>
    <eta_B2,<1,0>>
    <eta_B1,<1,0>> ->
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (\ <x_a2fY,<2,0>> <s_a2fZ,<2,0>> ->
         GHC.Base.++
           @ GHC.Types.Char
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY)
           s_a2fZ)
      eta_B2
      eta_B1
<CLaSH.Sized.Fixed.$fShowFixed,<0,0>>
<CLaSH.Sized.Fixed.$fShowFixed,<0,0>> =
  \ <frac_auHx,<1,0>>
    <rep_auHy,<1,0>>
    <size_auHz,<1,0>>
    <$dShow_avFv,<1,0>>
    <$dBits_avFw,<1,0>>
    <$dKnownNat_avFx,<1,0>>
    <$dIntegral_avFy,<1,0>> ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
<a_swjx,<0,0>>
<a_swjx,<0,0>> =
  \ <frac1_auHq,<1,0>>
    <rep_auHr,<1,0>>
    <size1_auHs,<1,0>>
    <frac2_auHt,<1,0>>
    <size2_auHu,<1,0>>
    <tup_avFg,<1,0>>
    <eta_B2,<1,0>>
    <eta_B1,<1,0>> ->
    case tup_avFg
    of <wild_X1y,<1,1>> { (<tpl_X1z,<1,1>>, <tpl_X1B,<1,1>>) ->
    case tpl_X1B
    of <cobox_XvFS,<1,2>> { GHC.Types.Eq# <cobox_dw3M,<1,2>> ->
    ((tpl_X1z
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }
<$cmult_avFi,<0,0>>
<$cmult_avFi,<0,0>> =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))
<CLaSH.Sized.Fixed.$fMultFixedFixed,<0,0>>
<CLaSH.Sized.Fixed.$fMultFixedFixed,<0,0>> =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))
<$cminus_avEx,<0,0>>
<$cminus_avEx,<0,0>> =
  \ <frac1_auHd,<1,0>>
    <rep_auHe,<1,0>>
    <size1_auHf,<1,0>>
    <frac2_auHg,<1,0>>
    <size2_auHh,<1,0>>
    <tup_avDN,<1,0>>
    <eta_X1I,<1,0>>
    <eta_X3p,<1,0>> ->
    let {
      <tup_swta,<1,1>>
      <tup_swta,<1,1>> =
        case tup_avDN
        of <wild_X1A,<1,1>>
        { (<tpl_X1L,<1,1>>, <tpl_X1N,<1,1>>, <tpl_B3,<1,1>>) ->
        tpl_X1N
        } } in
    let {
      <$dBounded_swt9,<1,2>>
      <$dBounded_swt9,<1,2>> =
        case tup_swta
        of <wild_X1C,<1,2>>
        { (<tpl_X1N,<1,2>>, <tpl_X1P,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_X1N
        } } in
    let {
      <$dBits_swt8,<1,3>>
      <$dBits_swt8,<1,3>> =
        case tup_swta
        of <wild_X3v,<1,3>>
        { (<tpl_X1P,<1,3>>, <tpl_X1R,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B5
        } } in
    let {
      <$dResize_swt7,<1,4>>
      <$dResize_swt7,<1,4>> =
        case tup_swta
        of <wild_X1M,<1,4>>
        { (<tpl_X1R,<1,4>>, <tpl_X1T,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>, <tpl_Bb,<1,4>>, <tpl_Bc,<1,4>>) ->
        tpl_B6
        } } in
    let {
      <$dKnownNat_swt6,<1,5>>
      <$dKnownNat_swt6,<1,5>> =
        case tup_swta
        of <wild_X1O,<1,5>>
        { (<tpl_X1T,<1,5>>, <tpl_X1V,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>, <tpl_Bb,<1,5>>, <tpl_Bc,<1,5>>) ->
        tpl_B7
        } } in
    let {
      <$dBits_swt5,<1,6>>
      <$dBits_swt5,<1,6>> =
        case tup_swta
        of <wild_X1S,<1,6>>
        { (<tpl_X1V,<1,6>>, <tpl_X1X,<1,6>>, <tpl_B3,<1,6>>, <tpl_B4,<1,6>>, <tpl_B5,<1,6>>, <tpl_B6,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>, <tpl_Bb,<1,6>>, <tpl_Bc,<1,6>>) ->
        tpl_B9
        } } in
    let {
      <$dKnownNat_swt4,<1,7>>
      <$dKnownNat_swt4,<1,7>> =
        case tup_swta
        of <wild_X1U,<1,7>>
        { (<tpl_X1X,<1,7>>, <tpl_X1Z,<1,7>>, <tpl_B3,<1,7>>, <tpl_B4,<1,7>>, <tpl_B5,<1,7>>, <tpl_B6,<1,7>>, <tpl_B7,<1,7>>, <tpl_B8,<1,7>>, <tpl_B9,<1,7>>, <tpl_Ba,<1,7>>, <tpl_Bb,<1,7>>, <tpl_Bc,<1,7>>) ->
        tpl_Ba
        } } in
    case tup_avDN
    of <wild_X2g,<1,8>>
    { (<tpl_X22,<1,8>>, <tpl_X24,<1,8>>, <tpl_B3,<1,8>>) ->
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          <$dBits_swt2,<1,9>>
          <$dBits_swt2,<1,9>> =
            case tpl_X22
            of <wild_X26,<1,9>>
            { (<tpl_X21,<1,9>>, <tpl_X23,<1,9>>, <tpl_X5p,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tpl_X22
            of <wild_X7m,<1,10>>
            { (<tpl_X43,<1,10>>, <tpl_X7q,<1,10>>, <tpl_X5q,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_X5q
            },
            case tpl_X22
            of <wild_X7o,<1,10>>
            { (<tpl_X7n,<1,10>>, <tpl_X46,<1,10>>, <tpl_X5q,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tpl_X22
            of <wild_X2a,<1,10>>
            { (<tpl_X7n,<1,10>>, <tpl_X7q,<1,10>>, <tpl_X5q,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl_X22
            of <wild_X2c,<1,10>>
            { (<tpl_X7n,<1,10>>, <tpl_X7q,<1,10>>, <tpl_X5q,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_Bb
            },
            case tpl_X22
            of <wild_X2e,<1,10>>
            { (<tpl_X7n,<1,10>>, <tpl_X7q,<1,10>>, <tpl_X5q,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of <wild_X1E,<1,9>>
            { (<tpl_X7k,<1,9>>, <tpl_X7n,<1,9>>, <tpl_X5n,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_X5n
            },
            case tup_swta
            of <wild_X1G,<1,9>>
            { (<tpl_X7k,<1,9>>, <tpl_X7n,<1,9>>, <tpl_X5n,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of <wild_X1Q,<1,9>>
            { (<tpl_X7k,<1,9>>, <tpl_X7n,<1,9>>, <tpl_X5n,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of <wild_X1W,<1,9>>
            { (<tpl_X7k,<1,9>>, <tpl_X7n,<1,9>>, <tpl_X5n,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_Bb
            },
            case tup_swta
            of <wild_X1Y,<1,9>>
            { (<tpl_X7k,<1,9>>, <tpl_X7n,<1,9>>, <tpl_X5n,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }
<$cplus_avDP,<0,0>>
<$cplus_avDP,<0,0>> =
  \ <frac1_auHd,<1,0>>
    <rep_auHe,<1,0>>
    <size1_auHf,<1,0>>
    <frac2_auHg,<1,0>>
    <size2_auHh,<1,0>>
    <tup_avDN,<1,0>>
    <eta_X1J,<1,0>>
    <eta_X3r,<1,0>> ->
    let {
      <tup_swsS,<1,1>>
      <tup_swsS,<1,1>> =
        case tup_avDN
        of <wild_X1B,<1,1>>
        { (<tpl_X1M,<1,1>>, <tpl_X1O,<1,1>>, <tpl_B3,<1,1>>) ->
        tpl_X1O
        } } in
    let {
      <$dBounded_swsR,<1,2>>
      <$dBounded_swsR,<1,2>> =
        case tup_swsS
        of <wild_X1D,<1,2>>
        { (<tpl_X1O,<1,2>>, <tpl_X1Q,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_X1O
        } } in
    let {
      <$dBits_swsQ,<1,3>>
      <$dBits_swsQ,<1,3>> =
        case tup_swsS
        of <wild_X3x,<1,3>>
        { (<tpl_X1Q,<1,3>>, <tpl_X1S,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
        tpl_B5
        } } in
    let {
      <$dResize_swsP,<1,4>>
      <$dResize_swsP,<1,4>> =
        case tup_swsS
        of <wild_X1N,<1,4>>
        { (<tpl_X1S,<1,4>>, <tpl_X1U,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>, <tpl_Bb,<1,4>>, <tpl_Bc,<1,4>>) ->
        tpl_B6
        } } in
    let {
      <$dKnownNat_swsO,<1,5>>
      <$dKnownNat_swsO,<1,5>> =
        case tup_swsS
        of <wild_X1P,<1,5>>
        { (<tpl_X1U,<1,5>>, <tpl_X1W,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>, <tpl_Bb,<1,5>>, <tpl_Bc,<1,5>>) ->
        tpl_B7
        } } in
    let {
      <$dBits_swsN,<1,6>>
      <$dBits_swsN,<1,6>> =
        case tup_swsS
        of <wild_X1T,<1,6>>
        { (<tpl_X1W,<1,6>>, <tpl_X1Y,<1,6>>, <tpl_B3,<1,6>>, <tpl_B4,<1,6>>, <tpl_B5,<1,6>>, <tpl_B6,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>, <tpl_Bb,<1,6>>, <tpl_Bc,<1,6>>) ->
        tpl_B9
        } } in
    let {
      <$dKnownNat_swsM,<1,7>>
      <$dKnownNat_swsM,<1,7>> =
        case tup_swsS
        of <wild_X1V,<1,7>>
        { (<tpl_X1Y,<1,7>>, <tpl_X20,<1,7>>, <tpl_B3,<1,7>>, <tpl_B4,<1,7>>, <tpl_B5,<1,7>>, <tpl_B6,<1,7>>, <tpl_B7,<1,7>>, <tpl_B8,<1,7>>, <tpl_B9,<1,7>>, <tpl_Ba,<1,7>>, <tpl_Bb,<1,7>>, <tpl_Bc,<1,7>>) ->
        tpl_Ba
        } } in
    case tup_avDN
    of <wild_X2h,<1,8>>
    { (<tpl_X23,<1,8>>, <tpl_X25,<1,8>>, <tpl_B3,<1,8>>) ->
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          <$dBits_swsK,<1,9>>
          <$dBits_swsK,<1,9>> =
            case tpl_X23
            of <wild_X27,<1,9>>
            { (<tpl_X22,<1,9>>, <tpl_X24,<1,9>>, <tpl_X5q,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tpl_X23
            of <wild_X7o,<1,10>>
            { (<tpl_X45,<1,10>>, <tpl_X7s,<1,10>>, <tpl_X5r,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_X5r
            },
            case tpl_X23
            of <wild_X7q,<1,10>>
            { (<tpl_X7p,<1,10>>, <tpl_X48,<1,10>>, <tpl_X5r,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tpl_X23
            of <wild_X2b,<1,10>>
            { (<tpl_X7p,<1,10>>, <tpl_X7s,<1,10>>, <tpl_X5r,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl_X23
            of <wild_X2d,<1,10>>
            { (<tpl_X7p,<1,10>>, <tpl_X7s,<1,10>>, <tpl_X5r,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_Bb
            },
            case tpl_X23
            of <wild_X2f,<1,10>>
            { (<tpl_X7p,<1,10>>, <tpl_X7s,<1,10>>, <tpl_X5r,<1,10>>, <tpl_B4,<1,10>>, <tpl_B5,<1,10>>, <tpl_B6,<1,10>>, <tpl_B7,<1,10>>, <tpl_B8,<1,10>>, <tpl_B9,<1,10>>, <tpl_Ba,<1,10>>, <tpl_Bb,<1,10>>, <tpl_Bc,<1,10>>) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of <wild_X1F,<1,9>>
            { (<tpl_X7m,<1,9>>, <tpl_X7p,<1,9>>, <tpl_X5o,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_X5o
            },
            case tup_swsS
            of <wild_X1H,<1,9>>
            { (<tpl_X7m,<1,9>>, <tpl_X7p,<1,9>>, <tpl_X5o,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of <wild_X1R,<1,9>>
            { (<tpl_X7m,<1,9>>, <tpl_X7p,<1,9>>, <tpl_X5o,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of <wild_X1X,<1,9>>
            { (<tpl_X7m,<1,9>>, <tpl_X7p,<1,9>>, <tpl_X5o,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_Bb
            },
            case tup_swsS
            of <wild_X1Z,<1,9>>
            { (<tpl_X7m,<1,9>>, <tpl_X7p,<1,9>>, <tpl_X5o,<1,9>>, <tpl_B4,<1,9>>, <tpl_B5,<1,9>>, <tpl_B6,<1,9>>, <tpl_B7,<1,9>>, <tpl_B8,<1,9>>, <tpl_B9,<1,9>>, <tpl_Ba,<1,9>>, <tpl_Bb,<1,9>>, <tpl_Bc,<1,9>>) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }
<CLaSH.Sized.Fixed.$fAddFixedFixed,<0,0>>
<CLaSH.Sized.Fixed.$fAddFixedFixed,<0,0>> =
  \ <frac1_auHd,<1,0>>
    <rep_auHe,<1,0>>
    <size1_auHf,<1,0>>
    <frac2_auHg,<1,0>>
    <size2_auHh,<1,0>>
    <tup_avDN,<1,0>> ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
<$cfromInteger_avDp,<0,0>>
<$cfromInteger_avDp,<0,0>> =
  \ <frac_auGY,<1,0>>
    <rep_auGZ,<1,0>>
    <size_auH0,<1,0>>
    <tup_avBm,<1,0>>
    <eta_X1I,<1,0>> ->
    case tup_avBm
    of <wild_X1B,<1,1>>
    { (<tpl_X1L,<1,1>>, <tpl_X1N,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>) ->
    case tpl_X1N
    of <wild_X1F,<1,2>>
    { (<tpl_X1M,<1,2>>, <tpl_X1O,<1,2>>, <tpl_X3i,<1,2>>, <tpl_X3k,<1,2>>, <tpl_X3m,<1,2>>, <tpl_X3o,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       tpl_B9
       (GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl_B3 eta_X1I)
       (case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of <wild_akCB,<1,3>> { __DEFAULT ->
        GHC.Types.I# wild_akCB
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }
<a_swkh,<0,0>>
<a_swkh,<0,0>> =
  \ <frac_auGY,<1,0>>
    <rep_auGZ,<1,0>>
    <size_auH0,<1,0>>
    <tup_avBm,<1,0>>
    <eta_X1J,<1,0>> ->
    case tup_avBm
    of <wild_X1C,<1,1>>
    { (<tpl_X1L,<1,1>>, <tpl_X1N,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl_B3
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }
<$cabs_avCW,<0,0>>
<$cabs_avCW,<0,0>> =
  \ <frac_XuIJ,<1,0>>
    <rep_XuIL,<1,0>>
    <size_XuIN,<1,0>>
    <tup_XvDa,<1,0>>
    <eta_X1Q,<1,0>> ->
    let {
      <tup_swsy,<1,1>>
      <tup_swsy,<1,1>> =
        case tup_XvDa
        of <wild_X1D,<1,1>>
        { (<tpl_X1T,<1,1>>, <tpl_X1V,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>) ->
        tpl_X1V
        } } in
    let {
      <$dKnownNat_swsx,<1,2>>
      <$dKnownNat_swsx,<1,2>> =
        case tup_swsy
        of <wild_X1H,<1,2>>
        { (<tpl_X1V,<1,2>>, <tpl_X1X,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B7
        } } in
    let {
      <tup_swsw,<1,3>>
      <tup_swsw,<1,3>> =
        case tup_XvDa
        of <wild_X3E,<1,3>>
        { (<tpl_X1X,<1,3>>, <tpl_X1Z,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
        tpl_X1X
        } } in
    let {
      <$dKnownNat_swsv,<1,4>>
      <$dKnownNat_swsv,<1,4>> =
        case tup_swsw
        of <wild_X1X,<1,4>>
        { (<tpl_X1Z,<1,4>>, <tpl_X21,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of <wild_X1L,<1,5>>
        { (<tpl_X20,<1,5>>, <tpl_X22,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_X20
        },
        case tup_swsw
        of <wild_X1N,<1,5>>
        { (<tpl_X20,<1,5>>, <tpl_X22,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_X22
        },
        case tup_swsw
        of <wild_X1P,<1,5>>
        { (<tpl_X20,<1,5>>, <tpl_X22,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B3
        },
        case tup_swsw
        of <wild_X1R,<1,5>>
        { (<tpl_X20,<1,5>>, <tpl_X22,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B4
        },
        case tup_swsw
        of <wild_X1T,<1,5>>
        { (<tpl_X20,<1,5>>, <tpl_X22,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B5
        },
        case tup_swsw
        of <wild_X1V,<1,5>>
        { (<tpl_X20,<1,5>>, <tpl_X22,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of <wild_X1F,<1,5>>
        { (<tpl_X20,<1,5>>, <tpl_X22,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>, <tpl_Bb,<1,5>>, <tpl_Bc,<1,5>>) ->
        tpl_X20
        },
        case tup_swsw
        of <wild_X1Z,<1,5>>
        { (<tpl_X20,<1,5>>, <tpl_X22,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_Ba
        })
       (case tup_XvDa
        of <wild_X23,<1,5>>
        { (<tpl_X20,<1,5>>, <tpl_X22,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>) ->
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsy
           of <wild_X21,<1,6>>
           { (<tpl_X7i,<1,6>>, <tpl_X7l,<1,6>>, <tpl_X5n,<1,6>>, <tpl_X5p,<1,6>>, <tpl_X5r,<1,6>>, <tpl_X5t,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>, <tpl_Bb,<1,6>>, <tpl_Bc,<1,6>>) ->
           (tpl_X5t
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                    :: CLaSH.Class.Num.Resize rep_XuIL
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)
<$cnegate_avCC,<0,0>>
<$cnegate_avCC,<0,0>> =
  \ <frac_XuIK,<1,0>>
    <rep_XuIM,<1,0>>
    <size_XuIO,<1,0>>
    <tup_XvDb,<1,0>>
    <eta_X1R,<1,0>> ->
    let {
      <tup_swsq,<1,1>>
      <tup_swsq,<1,1>> =
        case tup_XvDb
        of <wild_X1E,<1,1>>
        { (<tpl_X1U,<1,1>>, <tpl_X1W,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>) ->
        tpl_X1W
        } } in
    let {
      <$dKnownNat_swsp,<1,2>>
      <$dKnownNat_swsp,<1,2>> =
        case tup_swsq
        of <wild_X1I,<1,2>>
        { (<tpl_X1W,<1,2>>, <tpl_X1Y,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B7
        } } in
    let {
      <tup_swso,<1,3>>
      <tup_swso,<1,3>> =
        case tup_XvDb
        of <wild_X1K,<1,3>>
        { (<tpl_X1Y,<1,3>>, <tpl_X20,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
        tpl_X1Y
        } } in
    let {
      <$dKnownNat_swsn,<1,4>>
      <$dKnownNat_swsn,<1,4>> =
        case tup_swso
        of <wild_X1Y,<1,4>>
        { (<tpl_X20,<1,4>>, <tpl_X22,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of <wild_X1M,<1,5>>
        { (<tpl_X21,<1,5>>, <tpl_X23,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_X21
        },
        case tup_swso
        of <wild_X1O,<1,5>>
        { (<tpl_X21,<1,5>>, <tpl_X23,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_X23
        },
        case tup_swso
        of <wild_X1Q,<1,5>>
        { (<tpl_X21,<1,5>>, <tpl_X23,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B3
        },
        case tup_swso
        of <wild_X1S,<1,5>>
        { (<tpl_X21,<1,5>>, <tpl_X23,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B4
        },
        case tup_swso
        of <wild_X1U,<1,5>>
        { (<tpl_X21,<1,5>>, <tpl_X23,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B5
        },
        case tup_swso
        of <wild_X1W,<1,5>>
        { (<tpl_X21,<1,5>>, <tpl_X23,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of <wild_X1G,<1,5>>
        { (<tpl_X21,<1,5>>, <tpl_X23,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>, <tpl_Bb,<1,5>>, <tpl_Bc,<1,5>>) ->
        tpl_X21
        },
        case tup_swso
        of <wild_X20,<1,5>>
        { (<tpl_X21,<1,5>>, <tpl_X23,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_Ba
        })
       (case tup_XvDb
        of <wild_X24,<1,5>>
        { (<tpl_X21,<1,5>>, <tpl_X23,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>) ->
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsq
           of <wild_X22,<1,6>>
           { (<tpl_X7k,<1,6>>, <tpl_X7n,<1,6>>, <tpl_X5o,<1,6>>, <tpl_X5q,<1,6>>, <tpl_X5s,<1,6>>, <tpl_X5u,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>, <tpl_Bb,<1,6>>, <tpl_Bc,<1,6>>) ->
           (tpl_X5u
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                    :: CLaSH.Class.Num.Resize rep_XuIM
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)
<$c-_avCb,<0,0>>
<$c-_avCb,<0,0>> =
  \ <frac_XuIL,<1,0>>
    <rep_XuIN,<1,0>>
    <size_XuIP,<1,0>>
    <tup_XvDc,<1,0>>
    <eta_X1T,<1,0>>
    <eta_X3L,<1,0>> ->
    let {
      <tup_swsi,<1,1>>
      <tup_swsi,<1,1>> =
        case tup_XvDc
        of <wild_X1F,<1,1>>
        { (<tpl_X1W,<1,1>>, <tpl_X1Y,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>) ->
        tpl_X1Y
        } } in
    let {
      <$dKnownNat_swsg,<1,2>>
      <$dKnownNat_swsg,<1,2>> =
        case tup_swsi
        of <wild_X1L,<1,2>>
        { (<tpl_X20,<1,2>>, <tpl_X22,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B7
        } } in
    let {
      <tup_swsf,<1,3>>
      <tup_swsf,<1,3>> =
        case tup_XvDc
        of <wild_X1N,<1,3>>
        { (<tpl_X22,<1,3>>, <tpl_X24,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
        tpl_X22
        } } in
    let {
      <$dKnownNat_swse,<1,4>>
      <$dKnownNat_swse,<1,4>> =
        case tup_swsf
        of <wild_X21,<1,4>>
        { (<tpl_X24,<1,4>>, <tpl_X26,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of <wild_X1P,<1,5>>
        { (<tpl_X25,<1,5>>, <tpl_X27,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_X25
        },
        case tup_swsf
        of <wild_X1R,<1,5>>
        { (<tpl_X25,<1,5>>, <tpl_X27,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_X27
        },
        case tup_swsf
        of <wild_X3W,<1,5>>
        { (<tpl_X25,<1,5>>, <tpl_X27,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B3
        },
        case tup_swsf
        of <wild_X1V,<1,5>>
        { (<tpl_X25,<1,5>>, <tpl_X27,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B4
        },
        case tup_swsf
        of <wild_X1X,<1,5>>
        { (<tpl_X25,<1,5>>, <tpl_X27,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B5
        },
        case tup_swsf
        of <wild_X1Z,<1,5>>
        { (<tpl_X25,<1,5>>, <tpl_X27,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of <wild_X1H,<1,5>>
        { (<tpl_X25,<1,5>>, <tpl_X27,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>, <tpl_Bb,<1,5>>, <tpl_Bc,<1,5>>) ->
        tpl_X25
        },
        case tup_swsf
        of <wild_X23,<1,5>>
        { (<tpl_X25,<1,5>>, <tpl_X27,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_Ba
        })
       (case tup_XvDc
        of <wild_X25,<1,5>>
        { (<tpl_X49,<1,5>>, <tpl_X27,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>) ->
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsi
           of <wild_X3F,<1,6>>
           { (<tpl_X1Y,<1,6>>, <tpl_X20,<1,6>>, <tpl_X5s,<1,6>>, <tpl_X5u,<1,6>>, <tpl_X5w,<1,6>>, <tpl_X5y,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>, <tpl_Bb,<1,6>>, <tpl_Bc,<1,6>>) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
          (case tup_swsi
           of <wild_X3F,<1,6>>
           { (<tpl_X1Y,<1,6>>, <tpl_X20,<1,6>>, <tpl_X5s,<1,6>>, <tpl_X5u,<1,6>>, <tpl_X5w,<1,6>>, <tpl_X5y,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>, <tpl_Bb,<1,6>>, <tpl_Bc,<1,6>>) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
<$c*_avBP,<0,0>>
<$c*_avBP,<0,0>> =
  \ <frac_XuIM,<1,0>>
    <rep_XuIO,<1,0>>
    <size_XuIQ,<1,0>>
    <tup_XvDd,<1,0>>
    <eta_X1U,<1,0>>
    <eta_X3N,<1,0>> ->
    let {
      <tup_sws8,<1,1>>
      <tup_sws8,<1,1>> =
        case tup_XvDd
        of <wild_X1G,<1,1>>
        { (<tpl_X1X,<1,1>>, <tpl_X1Z,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>) ->
        tpl_X1Z
        } } in
    let {
      <$dBits_sws7,<1,2>>
      <$dBits_sws7,<1,2>> =
        case tup_sws8
        of <wild_X1O,<1,2>>
        { (<tpl_X1Z,<1,2>>, <tpl_X21,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B5
        } } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of <wild_X1I,<1,3>>
       { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of <wild_X1K,<1,3>>
       { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_B3
       },
       case tup_sws8
       of <wild_X1M,<1,3>>
       { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of <wild_X1S,<1,3>>
       { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_B6
       },
       case tup_sws8
       of <wild_X3S,<1,3>>
       { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_B7
       },
       case tup_sws8
       of <wild_X1W,<1,3>>
       { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_B8
       },
       case tup_sws8
       of <wild_X1Y,<1,3>>
       { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_B9
       },
       case tup_sws8
       of <wild_X20,<1,3>>
       { (<tpl_X3Z,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_Ba
       },
       case tup_sws8
       of <wild_X22,<1,3>>
       { (<tpl_X20,<1,3>>, <tpl_X42,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_Bb
       },
       case tup_sws8
       of <wild_X24,<1,3>>
       { (<tpl_X20,<1,3>>, <tpl_X22,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>, <tpl_B7,<1,3>>, <tpl_B8,<1,3>>, <tpl_B9,<1,3>>, <tpl_Ba,<1,3>>, <tpl_Bb,<1,3>>, <tpl_Bc,<1,3>>) ->
       tpl_Bc
       })
      (case tup_XvDd
       of <wild_X26,<1,3>>
       { (<tpl_Xk,<1,3>>, <tpl_Xm,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
       case tpl_B6
       of <cobox_XvCT,<1,4>> { GHC.Types.Eq# <cobox_dw1a,<1,4>> ->
       ((tpl_B5
         `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                   <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                 :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                      ~#
                    (rep_XuIO size_XuIQ
                     -> rep_XuIO size_XuIQ
                     -> CLaSH.Class.Num.MResult
                          (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
          (eta_X1U
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ))
          (eta_X3N
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ)))
       `cast` (Sub cobox_dw1a
               ; Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                            GHC.TypeLits.+ size_XuIQ>_N
               :: CLaSH.Class.Num.MResult
                    (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       }
       })
<$c+_avBo,<0,0>>
<$c+_avBo,<0,0>> =
  \ <frac_XuIN,<1,0>>
    <rep_XuIP,<1,0>>
    <size_XuIR,<1,0>>
    <tup_XvDe,<1,0>>
    <eta_X1V,<1,0>>
    <eta_X3P,<1,0>> ->
    let {
      <tup_sws4,<1,1>>
      <tup_sws4,<1,1>> =
        case tup_XvDe
        of <wild_X1H,<1,1>>
        { (<tpl_X1Y,<1,1>>, <tpl_X20,<1,1>>, <tpl_B3,<1,1>>, <tpl_B4,<1,1>>, <tpl_B5,<1,1>>, <tpl_B6,<1,1>>) ->
        tpl_X20
        } } in
    let {
      <$dKnownNat_sws2,<1,2>>
      <$dKnownNat_sws2,<1,2>> =
        case tup_sws4
        of <wild_X1N,<1,2>>
        { (<tpl_X22,<1,2>>, <tpl_X24,<1,2>>, <tpl_B3,<1,2>>, <tpl_B4,<1,2>>, <tpl_B5,<1,2>>, <tpl_B6,<1,2>>, <tpl_B7,<1,2>>, <tpl_B8,<1,2>>, <tpl_B9,<1,2>>, <tpl_Ba,<1,2>>, <tpl_Bb,<1,2>>, <tpl_Bc,<1,2>>) ->
        tpl_B7
        } } in
    let {
      <tup_sws1,<1,3>>
      <tup_sws1,<1,3>> =
        case tup_XvDe
        of <wild_X1P,<1,3>>
        { (<tpl_X24,<1,3>>, <tpl_X26,<1,3>>, <tpl_B3,<1,3>>, <tpl_B4,<1,3>>, <tpl_B5,<1,3>>, <tpl_B6,<1,3>>) ->
        tpl_X24
        } } in
    let {
      <$dKnownNat_sws0,<1,4>>
      <$dKnownNat_sws0,<1,4>> =
        case tup_sws1
        of <wild_X23,<1,4>>
        { (<tpl_X26,<1,4>>, <tpl_X28,<1,4>>, <tpl_B3,<1,4>>, <tpl_B4,<1,4>>, <tpl_B5,<1,4>>, <tpl_B6,<1,4>>, <tpl_B7,<1,4>>, <tpl_B8,<1,4>>, <tpl_B9,<1,4>>, <tpl_Ba,<1,4>>) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of <wild_X1R,<1,5>>
        { (<tpl_X27,<1,5>>, <tpl_X29,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_X27
        },
        case tup_sws1
        of <wild_X1T,<1,5>>
        { (<tpl_X27,<1,5>>, <tpl_X29,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_X29
        },
        case tup_sws1
        of <wild_X40,<1,5>>
        { (<tpl_X27,<1,5>>, <tpl_X29,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B3
        },
        case tup_sws1
        of <wild_X1X,<1,5>>
        { (<tpl_X27,<1,5>>, <tpl_X29,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B4
        },
        case tup_sws1
        of <wild_X1Z,<1,5>>
        { (<tpl_X27,<1,5>>, <tpl_X29,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B5
        },
        case tup_sws1
        of <wild_X21,<1,5>>
        { (<tpl_X27,<1,5>>, <tpl_X29,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of <wild_X3O,<1,5>>
        { (<tpl_X27,<1,5>>, <tpl_X29,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>, <tpl_Bb,<1,5>>, <tpl_Bc,<1,5>>) ->
        tpl_X27
        },
        case tup_sws1
        of <wild_X25,<1,5>>
        { (<tpl_X27,<1,5>>, <tpl_X29,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>, <tpl_B7,<1,5>>, <tpl_B8,<1,5>>, <tpl_B9,<1,5>>, <tpl_Ba,<1,5>>) ->
        tpl_Ba
        })
       (case tup_XvDe
        of <wild_X27,<1,5>>
        { (<tpl_X4d,<1,5>>, <tpl_X29,<1,5>>, <tpl_B3,<1,5>>, <tpl_B4,<1,5>>, <tpl_B5,<1,5>>, <tpl_B6,<1,5>>) ->
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_sws4
           of <wild_X1L,<1,6>>
           { (<tpl_X20,<1,6>>, <tpl_X22,<1,6>>, <tpl_X5u,<1,6>>, <tpl_X5w,<1,6>>, <tpl_X5y,<1,6>>, <tpl_X5A,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>, <tpl_Bb,<1,6>>, <tpl_Bc,<1,6>>) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
          (case tup_sws4
           of <wild_X1L,<1,6>>
           { (<tpl_X20,<1,6>>, <tpl_X22,<1,6>>, <tpl_X5u,<1,6>>, <tpl_X5w,<1,6>>, <tpl_X5y,<1,6>>, <tpl_X5A,<1,6>>, <tpl_B7,<1,6>>, <tpl_B8,<1,6>>, <tpl_B9,<1,6>>, <tpl_Ba,<1,6>>, <tpl_Bb,<1,6>>, <tpl_Bc,<1,6>>) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
<CLaSH.Sized.Fixed.$fNumFixed,<0,0>>
<CLaSH.Sized.Fixed.$fNumFixed,<0,0>> =
  \ <frac_XuIO,<1,0>>
    <rep_XuIQ,<1,0>>
    <size_XuIS,<1,0>>
    <tup_XvDf,<1,0>> ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ((a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
       `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
               :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> rep_XuIQ size_XuIS)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)))
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
<CLaSH.Sized.Fixed.$fBitVectorFixed,<0,0>>
<CLaSH.Sized.Fixed.$fBitVectorFixed,<0,0>> =
  \ <frac_XuIN,<1,0>>
    <rep_XuIP,<1,0>>
    <size_XuIR,<1,0>>
    <$dBitVector_XvCT,<1,0>> ->
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ((\ <$dKnownNat_avB0,<2,0>> <ds_dw0H,<2,0>> ->
          (let {
             <lvl_sxax,F<1,0>>
             <lvl_sxax,F<1,0>> =
               CLaSH.Class.BitVector.toBV
                 @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
           lvl_sxax)
            ($dKnownNat_avB0
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (ds_dw0H
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                          ~#
                        rep_XuIP size_XuIR)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
               -> (CLaSH.Sized.Vector.Vec
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                     <CLaSH.Bit.Bit>_R)_R
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize
                           (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                        CLaSH.Bit.Bit)))
      ((\ <$dKnownNat_avBa,<2,0>> <bv_auGX,<2,0>> ->
          (let {
             <lvl_sxay,F<1,0>>
             <lvl_sxay,F<1,0>> =
               CLaSH.Class.BitVector.fromBV
                 @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
           lvl_sxay)
            ($dKnownNat_avBa
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (bv_auGX
             `cast` ((CLaSH.Sized.Vector.Vec
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                        <CLaSH.Bit.Bit>_R)_R
                     :: CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> rep_XuIP size_XuIR)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
<a_swC4,<0,0>>
<a_swC4,<0,0>> =
  \ <frac_auGL,<1,0>>
    <rep_auGM,<1,0>>
    <size_auGN,<1,0>>
    <$dDefault_avAe,<1,0>> ->
    $dDefault_avAe
<$cdef_avAg,<0,0>>
<$cdef_avAg,<0,0>> =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))
<CLaSH.Sized.Fixed.$fDefaultFixed,<0,0>>
<CLaSH.Sized.Fixed.$fDefaultFixed,<0,0>> =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))
<CLaSH.Sized.Fixed.$fBoundedFixed,<0,0>>
<CLaSH.Sized.Fixed.$fBoundedFixed,<0,0>> =
  \ <frac_XuIW,<1,0>>
    <rep_XuIY,<1,0>>
    <size_XuJ0,<1,0>>
    <$dBounded_XvCa,<1,0>> ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ((GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
      ((GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
<CLaSH.Sized.Fixed.$fOrdFixed,<0,0>>
<CLaSH.Sized.Fixed.$fOrdFixed,<0,0>> =
  \ <frac_XuIv,<1,0>>
    <rep_XuIx,<1,0>>
    <size_XuIz,<1,0>>
    <$dEq_XvB3,<1,0>>
    <$dOrd_XvB5,<1,0>> ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ((GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Ordering>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Ordering)))
      ((GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
      ((GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
<CLaSH.Sized.Fixed.$fEqFixed,<0,0>>
<CLaSH.Sized.Fixed.$fEqFixed,<0,0>> =
  \ <frac_XuII,<1,0>>
    <rep_XuIK,<1,0>>
    <size_XuIM,<1,0>>
    <$dEq_XvAL,<1,0>> ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ((GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
      ((GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
<a_swC6,<0,0>>
<a_swC6,<0,0>> = GHC.CString.unpackCString# "Fixed"#
<a_swC9,<0,0>>
<a_swC9,<0,0>> = GHC.CString.unpackCString# "clash-prelude-0.5"#
<a_swCb,<0,0>>
<a_swCb,<0,0>> = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#
<a_swC7,<0,0>>
<a_swC7,<0,0>> =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swC9
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCb
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))
<lvl_swwh,<0,0>>
<lvl_swwh,<0,0>> =
  Language.Haskell.TH.Syntax.Name
    (a_swC6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swC7
<a_swCe,<0,0>>
<a_swCe,<0,0>> = GHC.CString.unpackCString# "Fixed"#
<a_swCh,<0,0>>
<a_swCh,<0,0>> = GHC.CString.unpackCString# "clash-prelude-0.5"#
<a_swCj,<0,0>>
<a_swCj,<0,0>> = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#
<a_swCf,<0,0>>
<a_swCf,<0,0>> =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (a_swCh
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCj
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))
<lvl_swwp,<0,0>>
<lvl_swwp,<0,0>> =
  Language.Haskell.TH.Syntax.Name
    (a_swCe
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swCf
<a_swCk,<0,0>>
<a_swCk,<0,0>> =
  \ <m_a4Ni,<1,0>> <eta_a4Nj,<1,0>> ->
    GHC.Base.return
      @ m_a4Ni
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_a4Nj)
      @ Language.Haskell.TH.Syntax.Type
      (let {
         <lvl_sxaz,F<0,0>>
         <lvl_sxaz,F<0,0>> = Language.Haskell.TH.Syntax.ConT lvl_swwp } in
       lvl_sxaz)
<a_swCv,<0,0>>
<a_swCv,<0,0>> =
  \ <frac_auGO,<1,0>>
    <rep_auGP,<1,0>>
    <size_auGQ,<1,0>>
    <$dLift_avAq,<1,0>>
    <$dKnownNat_avAr,<1,0>>
    <$dKnownNat_avAs,<1,0>>
    <$dTypeable_avAt,<1,0>>
    <f_auGR,<1,0>> ->
    let {
      <w1_acZp,<1,1>>
      <w1_acZp,<1,1>> =
        ($dLift_avAq
         `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                   <rep_auGP size_auGQ>_N
                 :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                      ~#
                    (rep_auGP size_auGQ
                     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
          (f_auGR
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                        ~#
                      rep_auGP size_auGQ)) } in
    let {
      <w1_akV2,<1,2>>
      <w1_akV2,<1,2>> =
        letrec {
          <lgo_sxaB,F<0,0>>
          <lgo_sxaB,F<0,0>> =
            \ <z_awhM,<2,0>> <ds_awhN,<2,0>> ->
              case ds_awhN of <wild_awhO,<2,1>> {
                [] -> z_awhM;
                : <x_awhS,<2,1>> <xs_awhT,<2,1>> ->
                  lgo_sxaB
                    ((Language.Haskell.TH.Lib.appT1 z_awhM x_awhS)
                     `cast` (Sym
                               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                  <Language.Haskell.TH.Syntax.Type>_N)
                             :: (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.Type)
                                  ~#
                                Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                    xs_awhT
              }; } in
        lgo_sxaB
          (a_swCk
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          (GHC.Types.:
             @ Language.Haskell.TH.Lib.TypeQ
             (let {
                <l_a5DZ,<1,2>>
                <l_a5DZ,<1,2>> =
                  Language.Haskell.TH.Lib.numTyLit
                    ($dKnownNat_avAr
                     `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                             ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                             :: GHC.TypeLits.KnownNat frac_auGO
                                  ~#
                                GHC.Integer.Type.Integer)) } in
              (\ <m_a5E0,<2,0>> <eta_a5E1,<2,0>> ->
                 GHC.Base.fmap
                   @ m_a5E0
                   (Control.Applicative.$p1Applicative
                      @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                   @ Language.Haskell.TH.Syntax.TyLit
                   @ Language.Haskell.TH.Syntax.Type
                   Language.Haskell.TH.Syntax.LitT
                   ((l_a5DZ
                     `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <Language.Haskell.TH.Syntax.TyLit>_N
                             :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                  ~#
                                (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                      @ m_a5E0 eta_a5E1))
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <Language.Haskell.TH.Syntax.Type>_N)
                      :: (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Type)
                           ~#
                         Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
             (GHC.Types.:
                @ Language.Haskell.TH.Lib.TypeQ
                (let {
                   <x_X4Ts,<1,2>>
                   <x_X4Ts,<1,2>> =
                     case ($dTypeable_avAt
                           `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                                     <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                                   :: Data.Typeable.Internal.Typeable rep_auGP
                                        ~#
                                      (GHC.Prim.Proxy# rep_auGP -> Data.Typeable.Internal.TypeRep)))
                            (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP)
                     of <ww_awCo,<1,2>>
                     { Data.Typeable.Internal.TypeRep <ww1_awCq,<1,2>> <ww2_awCr,<1,2>>
                                                      <ww3_awCs,<1,2>> <ww4_awCt,<1,2>> ->
                     case GHC.List.reverse1
                            @ GHC.Types.Char
                            (Data.Typeable.Internal.$w$cshowsPrec
                               GHC.Show.shows27 ww3_awCs ww4_awCt (GHC.Types.[] @ GHC.Types.Char))
                            (GHC.Types.[] @ GHC.Types.Char)
                     of <wild21_a5F6,<1,3>> {
                       [] ->
                         let {
                           <lvl_sxaC,F<0,0>>
                           <lvl_sxaC,F<0,0>> =
                             Language.Haskell.TH.Syntax.Name
                               ((GHC.Types.[] @ GHC.Types.Char)
                                `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
                                        :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
                               Language.Haskell.TH.Syntax.NameS } in
                         lvl_sxaC;
                       : <ds_a5Fa,<1,3>> <rev_a5Fb,<1,3>> ->
                         case ds_a5Fa
                         of <wild22_a5Fd,<1,4>> { GHC.Types.C# <ds1_a5Ff,<1,4>> ->
                         case ds1_a5Ff of <ds2_a5Fh,<1,5>> {
                           __DEFAULT ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    ds_a5Fa (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of <ww_a5Au,<1,6>> { (# <ww1_a5Aw,<1,6>>, <ww2_a5Ax,<1,6>> #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             };
                           '.' ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    ds_a5Fa (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of <ww_a5Au,<1,6>> { (# <ww1_a5Aw,<1,6>>, <ww2_a5Ax,<1,6>> #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             }
                         }
                         }
                     }
                     } } in
                 (\ <m_X4Tv,<2,0>> <eta_X4Tx,<2,0>> ->
                    GHC.Base.return
                      @ m_X4Tv
                      (Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_X4Tx)
                      @ Language.Haskell.TH.Syntax.Type
                      (let {
                         <lvl_sxaD,F<1,2>>
                         <lvl_sxaD,F<1,2>> = Language.Haskell.TH.Syntax.ConT x_X4Ts } in
                       lvl_sxaD))
                 `cast` (Sym
                           (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.Type>_N)
                         :: (forall (m_a4LE :: * -> *).
                             Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                             m_a4LE Language.Haskell.TH.Syntax.Type)
                              ~#
                            Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                (GHC.Types.:
                   @ Language.Haskell.TH.Lib.TypeQ
                   (let {
                      <l_a5DZ,<1,2>>
                      <l_a5DZ,<1,2>> =
                        Language.Haskell.TH.Lib.numTyLit
                          ($dKnownNat_avAs
                           `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                                   ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                                   :: GHC.TypeLits.KnownNat size_auGQ
                                        ~#
                                      GHC.Integer.Type.Integer)) } in
                    (\ <m_a5E0,<2,0>> <eta_a5E1,<2,0>> ->
                       GHC.Base.fmap
                         @ m_a5E0
                         (Control.Applicative.$p1Applicative
                            @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                         @ Language.Haskell.TH.Syntax.TyLit
                         @ Language.Haskell.TH.Syntax.Type
                         Language.Haskell.TH.Syntax.LitT
                         ((l_a5DZ
                           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <Language.Haskell.TH.Syntax.TyLit>_N
                                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                        ~#
                                      (forall (m_a4LE :: * -> *).
                                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                       m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                            @ m_a5E0 eta_a5E1))
                    `cast` (Sym
                              (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                 <Language.Haskell.TH.Syntax.Type>_N)
                            :: (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.Type)
                                 ~#
                               Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)))) } in
    \ <m_akV3,<2,0>> <w2_akV4,<2,0>> ->
      case w2_akV4
      of <ww_akV5,<2,1>>
      { Language.Haskell.TH.Syntax.D:Quasi <ww1_akV7,<2,1>>
                                           <ww2_akV8,<2,1>> <ww3_akV9,<2,1>> <ww4_akVa,<2,1>>
                                           <ww5_akVb,<2,1>> <ww6_akVc,<2,1>> <ww7_akVd,<2,1>>
                                           <ww8_akVe,<2,1>> <ww9_akVf,<2,1>> <ww10_akVg,<2,1>>
                                           <ww11_akVh,<2,1>> <ww12_akVi,<2,1>> <ww13_akVj,<2,1>>
                                           <ww14_akVk,<2,1>> <ww15_akVl,<2,1>> <ww16_akVm,<2,1>>
                                           <ww17_akVn,<2,1>> <ww18_akVo,<2,1>> ->
      case ww1_akV7
      of <ww19_akVq,<2,2>>
      { GHC.Base.D:Monad <ww20_akVt,<2,2>> <ww21_akVu,<2,2>>
                         <ww22_akVv,<2,2>> <ww23_akVw,<2,2>> ->
      let {
        <a_akVs,<2,3>>
        <a_akVs,<2,3>> =
          GHC.Base.D:Monad
            @ m_akV3 ww20_akVt ww21_akVu ww22_akVv ww23_akVw } in
      let {
        <eta_akVy,<2,4>>
        <eta_akVy,<2,4>> =
          Language.Haskell.TH.Syntax.D:Quasi
            @ m_akV3
            a_akVs
            ww2_akV8
            ww3_akV9
            ww4_akVa
            ww5_akVb
            ww6_akVc
            ww7_akVd
            ww8_akVe
            ww9_akVf
            ww10_akVg
            ww11_akVh
            ww12_akVi
            ww13_akVj
            ww14_akVk
            ww15_akVl
            ww16_akVm
            ww17_akVn
            ww18_akVo } in
      ww20_akVt
        @ Language.Haskell.TH.Syntax.Exp
        @ Language.Haskell.TH.Syntax.Exp
        (let {
           <a_acZP,<2,5>>
           <a_acZP,<2,5>> =
             GHC.Base.D:Monad
               @ m_akV3 ww20_akVt ww21_akVu ww22_akVv ww23_akVw } in
         let {
           <eta_acZV,<2,6>>
           <eta_acZV,<2,6>> =
             Language.Haskell.TH.Syntax.D:Quasi
               @ m_akV3
               a_acZP
               ww2_akV8
               ww3_akV9
               ww4_akVa
               ww5_akVb
               ww6_akVc
               ww7_akVd
               ww8_akVe
               ww9_akVf
               ww10_akVg
               ww11_akVh
               ww12_akVi
               ww13_akVj
               ww14_akVk
               ww15_akVl
               ww16_akVm
               ww17_akVn
               ww18_akVo } in
         ww20_akVt
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_akVv
              @ Language.Haskell.TH.Syntax.Exp
              (let {
                 <lvl_sxaE,F<0,0>>
                 <lvl_sxaE,F<0,0>> = Language.Haskell.TH.Syntax.ConE lvl_swwh } in
               lvl_sxaE))
           (\ <x_acZW,<3,0>> ->
              ww20_akVt
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                (let {
                   <lvl_sxaF,F<2,6>>
                   <lvl_sxaF,F<2,6>> =
                     (w1_acZp
                      `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                <Language.Haskell.TH.Syntax.Exp>_N
                              :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
                                   ~#
                                 (forall (m_a4LE :: * -> *).
                                  Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                  m_a4LE Language.Haskell.TH.Syntax.Exp)))
                       @ m_akV3 eta_acZV } in
                 lvl_sxaF)
                (\ <x1_acZX,<4,0>> ->
                   ww22_akVv
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ <x_akVz,<3,0>> ->
           ww20_akVt
             @ Language.Haskell.TH.Syntax.Type
             @ Language.Haskell.TH.Syntax.Exp
             (let {
                <lvl_sxaG,F<2,4>>
                <lvl_sxaG,F<2,4>> =
                  (w1_akV2
                   `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N
                           :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
                                ~#
                              (forall (m_a4LE :: * -> *).
                               Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                               m_a4LE Language.Haskell.TH.Syntax.Type)))
                    @ m_akV3 eta_akVy } in
              lvl_sxaG)
             (\ <x1_akVA,<4,0>> ->
                ww22_akVv
                  @ Language.Haskell.TH.Syntax.Exp
                  (Language.Haskell.TH.Syntax.SigE x_akVz x1_akVA)))
      }
      }
<$clift_avAv,<0,0>>
<$clift_avAv,<0,0>> =
  a_swCv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))
<CLaSH.Sized.Fixed.$fLiftFixed,<0,0>>
<CLaSH.Sized.Fixed.$fLiftFixed,<0,0>> =
  a_swCv
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))



==================== Float out(FOS {Lam = Just 0, Consts = True, PAPs = True}) ====================
Result size of Float out(FOS {Lam = Just 0,
                              Consts = True,
                              PAPs = True})
  = {terms: 2,289, types: 9,678, coercions: 953}

lvl_sxai :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_sxai = GHC.CString.unpackCString# "Negative exponent"#

lvl_swvg :: GHC.Types.Double
[LclId, Str=DmdType b]
lvl_swvg = GHC.Err.error @ GHC.Types.Double lvl_sxai

lvl_swve :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swve = GHC.Types.D# 1.0

lvl_swv0 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv0 = __integer 1

lvl_swv2 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv2 = __integer 1

lvl_swv4 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv4 = __integer 2

lvl_swv6 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv6 = __integer 2

Rec {
g1_swuY [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 442 0}]
g1_swuY =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP :: GHC.Types.Double) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y1_akDO GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y1_akDO lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x1_akDN x1_akDN)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y1_akDO lvl_swv2) lvl_swv4)
              (GHC.Float.timesDouble x1_akDN z_akDP);
          GHC.Types.True -> GHC.Float.timesDouble x1_akDN z_akDP
        }
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Float.timesDouble x1_akDN x1_akDN)
          (GHC.Integer.Type.quotInteger y1_akDO lvl_swv6)
          z_akDP
    }
    }
end Rec }

lvl_swuS :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuS = __integer 1

lvl_swv8 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv8 = __integer 1

lvl_swva :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swva = __integer 2

lvl_swvc :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvc = __integer 2

Rec {
f_swuQ [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 372 0}]
f_swuQ =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y_akDB GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y_akDB lvl_swuS
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x_akDA x_akDA)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y_akDB lvl_swv8) lvl_swva)
              x_akDA;
          GHC.Types.True -> x_akDA
        }
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Float.timesDouble x_akDA x_akDA)
          (GHC.Integer.Type.quotInteger y_akDB lvl_swvc)
    }
    }
end Rec }

lvl_swuH :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuH = __integer 0

lvl_swuK :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuK = __integer 0

$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 152 0}]
$s^_swu6 =
  \ (eta_akDk :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger# eta1_akDl lvl_swuH
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# eta1_akDl lvl_swuK
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        }
        };
      GHC.Types.True -> lvl_swvg
    }
    }

lvl_swvh :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvh = GHC.Types.D# 2.0

a_swwS :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swwS = GHC.CString.unpackCString# "Fixed"#

a_swwV :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swwV = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swwX :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swwX = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swwT :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swwT =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvo :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvo =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swwT

a_swx0 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 60 0}]
a_swx0 = GHC.CString.unpackCString# "fromInteger"#

a_swx3 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 40 0}]
a_swx3 = GHC.CString.unpackCString# "base"#

a_swx5 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swx5 = GHC.CString.unpackCString# "GHC.Num"#

a_swx1 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swx1 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (a_swx3
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swx5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvw :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvw =
  Language.Haskell.TH.Syntax.Name
    (a_swx0
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swx1

lvl_sxaj :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxaj = __integer 0

lvl_sxak :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxak = __integer 0

lvl_sxal :: Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
lvl_sxal = Language.Haskell.TH.Syntax.ConE lvl_swvo

lvl_sxam :: Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
lvl_sxam = Language.Haskell.TH.Syntax.VarE lvl_swvw

a_swxS
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
a_swxS =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      x_akVD :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      x_akVD =
        let {
          rMax_swu0 :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          rMax_swu0 =
            GHC.Real.toInteger
              @ (rep_avhN size_avhO)
              $dIntegral_avlP
              (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
        let {
          truncated_swu2 :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          truncated_swu2 =
            case a_auGC of _ [Occ=Dead] { GHC.Types.D# x_aw80 ->
            case $s^_swu6
                   lvl_swvh
                   ($dKnownNat_avlM
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                            :: GHC.TypeLits.KnownNat frac_avhM ~# GHC.Integer.Type.Integer))
            of _ [Occ=Dead] { GHC.Types.D# y_aw84 ->
            case GHC.Integer.Type.decodeDoubleInteger
                   (GHC.Prim.*## x_aw80 y_aw84)
            of _ [Occ=Dead] { (# ipv_aw8Q, ipv1_aw8R #) ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ipv1_aw8R 0)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Integer.Type.shiftLInteger ipv_aw8Q ipv1_aw8R;
              GHC.Types.True ->
                let {
                  s_aw8X :: GHC.Prim.Int#
                  [LclId, Str=DmdType]
                  s_aw8X = GHC.Prim.negateInt# ipv1_aw8R } in
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># s_aw8X 52)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger# ipv_aw8Q lvl_sxaj
                    of wild3_aw92 { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild3_aw92
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        case GHC.Integer.Type.integerToInt ipv_aw8Q
                        of n_aw96 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.uncheckedIShiftRA# n_aw96 s_aw8X)
                        };
                      GHC.Types.True ->
                        case GHC.Integer.Type.integerToInt
                               (GHC.Integer.Type.negateInteger ipv_aw8Q)
                        of n_aw99 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.negateInt# (GHC.Prim.uncheckedIShiftRA# n_aw99 s_aw8X))
                        }
                    }
                    };
                  GHC.Types.True -> lvl_sxak
                }
            }
            }
            }
            } } in
        case GHC.Integer.Type.gtInteger# truncated_swu2 rMax_swu0
        of wild_akJ6 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ6
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              rMin_swu1 :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              rMin_swu1 =
                GHC.Real.toInteger
                  @ (rep_avhN size_avhO)
                  $dIntegral_avlP
                  (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
            case GHC.Integer.Type.ltInteger# truncated_swu2 rMin_swu1
            of wild_a4It { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
            of _ [Occ=Dead] {
              GHC.Types.False -> truncated_swu2;
              GHC.Types.True -> rMin_swu1
            }
            };
          GHC.Types.True -> rMax_swu0
        }
        } } in
    let {
      lvl_sxan :: Language.Haskell.TH.Syntax.Exp
      [LclId, Str=DmdType]
      lvl_sxan =
        Language.Haskell.TH.Syntax.LitE
          (Language.Haskell.TH.Syntax.IntegerL x_akVD) } in
    \ (@ (m_awx9 :: * -> *))
      (w1_awxa :: Language.Haskell.TH.Syntax.Quasi m_awx9) ->
      case w1_awxa
      of _ [Occ=Dead]
      { Language.Haskell.TH.Syntax.D:Quasi ww1_awxd ww2_awxe ww3_awxf
                                           ww4_awxg ww5_awxh ww6_awxi ww7_awxj ww8_awxk ww9_awxl
                                           ww10_awxm ww11_awxn ww12_awxo ww13_awxp ww14_awxq
                                           ww15_awxr ww16_awxs ww17_awxt ww18_awxu ->
      case ww1_awxd
      of _ [Occ=Dead]
      { GHC.Base.D:Monad ww20_awxy ww21_awxz ww22_awxA ww23_awxB ->
      let {
        lvl_sxao :: m_awx9 Language.Haskell.TH.Syntax.Exp
        [LclId, Str=DmdType]
        lvl_sxao = ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxan } in
      let {
        lvl_sxap :: m_awx9 Language.Haskell.TH.Syntax.Exp
        [LclId, Str=DmdType]
        lvl_sxap =
          ww20_awxy
            @ Language.Haskell.TH.Syntax.Exp
            @ Language.Haskell.TH.Syntax.Exp
            (ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxam)
            (\ (x_Xd36 :: Language.Haskell.TH.Syntax.Exp) ->
               ww20_awxy
                 @ Language.Haskell.TH.Syntax.Exp
                 @ Language.Haskell.TH.Syntax.Exp
                 lvl_sxao
                 (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                    ww22_awxA
                      @ Language.Haskell.TH.Syntax.Exp
                      (Language.Haskell.TH.Syntax.AppE x_Xd36 x1_acZX))) } in
      ww20_awxy
        @ Language.Haskell.TH.Syntax.Exp
        @ (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
        (ww20_awxy
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxal)
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_awxy
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl_sxap
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_awxA
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_awxD :: Language.Haskell.TH.Syntax.Exp) ->
           ww22_awxA
             @ (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
             (x_awxD
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:TExp[0]
                           <CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO>_N)
                      :: Language.Haskell.TH.Syntax.Exp
                           ~#
                         Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))
      }
      }

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.fLit =
  a_swxS
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      repBV_swtT =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl_B4
           (tpl_B8
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_B1)
        `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        }
        } } in
    let {
      cobox_swtU
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_swtU =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      s_swtS =
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (repBV_swtT
              `cast` ((CLaSH.Sized.Vector.Vec
                         (Sym cobox_dw7d) <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
        } } in
    let {
      cobox_swtV
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId, Str=DmdType]
      cobox_swtV =
        case tup_avmQ
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    case tup_avmQ
    of _ [Occ=Dead]
    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl_Ba eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        };
      GHC.Types.True ->
        case cobox_swtU of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        }
    }
    }

lvl_swvz :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvz = __integer 0

lvl_swvy :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvy = __integer 0

lvl_swvB :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvB = __integer 0

lvl_swvA :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvA = __integer 0

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat_swtH =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_swtI =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_swtI
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat_swtH
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_akJ3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ3
    of _ [Occ=Dead] {
      GHC.Types.False ->
        let {
          $dBounded_swtD :: GHC.Enum.Bounded (rep_avjs size2_avju)
          [LclId, Str=DmdType]
          $dBounded_swtD =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X1u
            } } in
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId, Str=DmdType]
          fMax_swtA =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          $dBits_swtF :: Data.Bits.Bits (rep_avjs size1_avjt)
          [LclId, Str=DmdType]
          $dBits_swtF =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X5L, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId, Str=DmdType]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (case tup_avnK
               of _ [Occ=Dead]
               { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
               (tpl_B6
                `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                        :: CLaSH.Class.Num.Resize rep_avjs
                             ~#
                           (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                            (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                            rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                 @ size2_avju @ size1_avjt $dKnownNat_swtH $dKnownNat_swtI fMax_swtA
               }) } in
        let {
          $dNum_swtE :: GHC.Num.Num (rep_avjs size1_avjt)
          [LclId, Str=DmdType]
          $dNum_swtE =
            case tup_avnK
            of _ [Occ=Dead]
            { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            } } in
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFQ { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFQ)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFQ)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvy)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvz)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_XkFQ wild_akCB)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvA)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swvB)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFG { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFG)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFG)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_XkFG wild_akCB)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 40 20}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_avxa
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_akCB { __DEFAULT ->
    GHC.Types.I# wild_akCB
    }

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

lvl_swvD :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvD = GHC.Types.C# '-'

lvl_swvC :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swvC = __integer 0

lvl_swvG :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvG = GHC.Types.C# '0'

ds_swvM :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
ds_swvM = __integer 1

dt_akMa :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
dt_akMa = __integer 10

lvl_swvV
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40] 191 30}]
lvl_swvV =
  \ (ds_awe3
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    (case ds_awe3 of _ [Occ=Dead] { (x_awe6, y_awe7) ->
     case x_awe6 of _ [Occ=Dead] { GHC.Types.I# x1_awdC ->
     case x1_awdC of wild1_awdE {
       __DEFAULT -> GHC.Types.I# (GHC.Prim.+# x1_awdC 1);
       9223372036854775807 -> GHC.Enum.$fEnumInt2
     }
     }
     },
     case ds_awe3 of _ [Occ=Dead] { (x_aweb, y_awec) ->
     case y_awec of _ [Occ=Dead] { GHC.Real.:% ww1_awdJ ww2_awdK ->
     case GHC.Real.$w$sreduce
            (GHC.Integer.Type.timesInteger ww1_awdJ dt_akMa)
            (GHC.Integer.Type.timesInteger ww2_awdK GHC.Real.$fEnumRatio1)
     of _ [Occ=Dead] { (# ww7_awdU, ww8_awdV #) ->
     GHC.Real.:% @ GHC.Integer.Type.Integer ww7_awdU ww8_awdV
     }
     }
     })

lvl_swvX :: GHC.Types.Int
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvX = GHC.Types.I# 0

lvl_sww5 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww5 = __integer 2

lvl_sww6 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww6 = __integer 1

lvl_sww7 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww7 = __integer 2

lvl_sww8 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww8 = __integer 1

lvl_sww4 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww4 = __integer 0

lvl_sww9 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_sww9 = __integer 2

lvl_sxaq
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[LclId, Str=DmdType]
lvl_sxaq =
  \ (x_awzz
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    (r_awzA [OS=OneShot]
       :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]) ->
    case x_awzz of wild_afnB { (ds1_afnD, y_afnE) ->
    case y_afnE of _ [Occ=Dead] { GHC.Real.:% ds1_awdp y_awdq ->
    case GHC.Integer.Type.eqInteger# y_awdq ds_swvM
    of wild_a2f3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
    of _ [Occ=Dead] {
      GHC.Types.False -> r_awzA;
      GHC.Types.True ->
        GHC.Types.:
          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          x_awzz
          r_awzA
    }
    }
    }
    }

lvl_sxar :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxar = __integer 0

lvl_sxas :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxas = __integer 0

lvl_sxau :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_sxau = GHC.Types.C# '.'

lvl_sxav :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_sxav = GHC.Types.C# '.'

lvl_sxaw :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_sxaw = GHC.Types.C# '.'

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      nF_swti :: GHC.Types.Int
      [LclId, Str=DmdType]
      nF_swti =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_avFx
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        } } in
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      a_swOO :: [GHC.Types.Char]
      [LclId, Str=DmdType]
      a_swOO =
        let {
          eta_awcR
            :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          [LclId, Str=DmdType]
          eta_awcR =
            case GHC.List.iterateFB
                   @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                   @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                   lvl_sxaq
                   lvl_swvV
                   (lvl_swvX,
                    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_sww4
                    of wild_a4It { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of _ [Occ=Dead] {
                          GHC.Types.False ->
                            let {
                              a_swOs :: GHC.Integer.Type.Integer
                              [LclId, Str=DmdType]
                              a_swOs =
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                                of _ [Occ=Dead] {
                                  GHC.Types.False ->
                                    case x_awO9 of wild2_awOe {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_sww9 x_awO9;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of wild2_awOe {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_swtk
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_sww5 x_awO9) lvl_sww6))
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger fRepI_swtk lvl_sxar)
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        };
                      GHC.Types.True ->
                        case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of _ [Occ=Dead] {
                          GHC.Types.False ->
                            let {
                              a_swOy :: GHC.Integer.Type.Integer
                              [LclId, Str=DmdType]
                              a_swOy =
                                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                                of _ [Occ=Dead] {
                                  GHC.Types.False ->
                                    case x_awO9 of wild2_awOe {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_sww9 x_awO9;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of wild2_awOe {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_abs_swtj
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_sww7 x_awO9) lvl_sww8))
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger fRepI_abs_swtj lvl_sxas)
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        }
                    }
                    })
            of _ [Occ=Dead] {
              [] ->
                Data.Maybe.fromJust1
                  @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer);
              : a1_awdh ds1_awdi -> a1_awdh
            } } in
        let {
          str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          str_auHK =
            case eta_awcR of _ [Occ=Dead] { (x_awcZ, y_awd0) ->
            case y_awd0 of _ [Occ=Dead] { GHC.Real.:% x_awcK ds1_awcL ->
            case GHC.Show.$w$cshowsPrec
                   0 x_awcK (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
            }
            }
            } } in
        let {
          lvl_sxat :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          lvl_sxat = GHC.Types.: @ GHC.Types.Char lvl_swvG str_auHK } in
        case eta_awcR of _ [Occ=Dead] { (x_awcU, y_awcV) ->
        case x_awcU of _ [Occ=Dead] { GHC.Types.I# x_akIV ->
        case GHC.List.$wlenAcc @ GHC.Types.Char str_auHK 0
        of ww_awOK { __DEFAULT ->
        let {
          n#_awbi :: GHC.Prim.Int#
          [LclId, Str=DmdType]
          n#_awbi = GHC.Prim.-# x_akIV ww_awOK } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# n#_awbi 0)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            letrec {
              xs_awyT [Occ=LoopBreaker] :: GHC.Prim.Int# -> [GHC.Types.Char]
              [LclId, Arity=1, Str=DmdType]
              xs_awyT =
                \ (m_awz0 :: GHC.Prim.Int#) ->
                  case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# m_awz0 1)
                  of _ [Occ=Dead] {
                    GHC.Types.False ->
                      GHC.Types.:
                        @ GHC.Types.Char lvl_swvG (xs_awyT (GHC.Prim.-# m_awz0 1));
                    GHC.Types.True -> lvl_sxat
                  }; } in
            xs_awyT n#_awbi;
          GHC.Types.True -> str_auHK
        }
        }
        }
        } } in
    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swvC
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
        let {
          ww_al4F :: GHC.Prim.Int#
          [LclId, Str=DmdType]
          ww_al4F = GHC.Prim.negateInt# x_aiKN } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftRInteger
                      fRepI_swtk (GHC.Prim.negateInt# ww_al4F))
                   (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
            };
          GHC.Types.True ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftLInteger fRepI_swtk ww_al4F)
                   (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char lvl_sxav a_swOO)
            }
        }
        };
      GHC.Types.True ->
        GHC.Base.++
          @ GHC.Types.Char
          (GHC.Types.:
             @ GHC.Types.Char
             lvl_swvD
             (case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
              let {
                ww_al4F :: GHC.Prim.Int#
                [LclId, Str=DmdType]
                ww_al4F = GHC.Prim.negateInt# x_aiKN } in
              case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
              of _ [Occ=Dead] {
                GHC.Types.False ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftRInteger
                            fRepI_abs_swtj (GHC.Prim.negateInt# ww_al4F))
                         (GHC.Types.[] @ GHC.Types.Char)
                  of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  };
                GHC.Types.True ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftLInteger fRepI_abs_swtj ww_al4F)
                         (GHC.Types.[] @ GHC.Types.Char)
                  of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  }
              }
              }))
          (GHC.Types.: @ GHC.Types.Char lvl_sxaw a_swOO)
    }
    }

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 90 0}]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.++
      @ GHC.Types.Char
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy
         x_a2fY)
      s_a2fZ

$cshowList_avIE
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId,
 Arity=6,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=6, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0] 150 0}]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_B2 :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta_B1 :: GHC.Base.String) ->
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (\ (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
         (s_a2fZ [OS=OneShot] :: GHC.Base.String) ->
         GHC.Base.++
           @ GHC.Types.Char
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY)
           s_a2fZ)
      eta_B2
      eta_B1

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl_X1B) ->
    case tpl_X1B of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
    ((tpl_X1z
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 430 0}]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swta
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swta =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1L, tpl_X1N, tpl_B3) ->
        tpl_X1N
        } } in
    let {
      $dBounded_swt9
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swt9 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1N
        } } in
    let {
      $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_swt8 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swt7 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swt6
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_swt6 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swt5
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swt5 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swt4
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swt4 =
        case tup_swta
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl_X24, tpl_B3) ->
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits_swt2 =
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X21, tpl_X23, tpl_X5p, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X43, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5q
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X46, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5n
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swta
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 430 0}]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swsS
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swsS =
        case tup_avDN of _ [Occ=Dead] { (tpl_X1M, tpl_X1O, tpl_B3) ->
        tpl_X1O
        } } in
    let {
      $dBounded_swsR
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swsR =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1O
        } } in
    let {
      $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_swsQ =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swsP =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swsO
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_swsO =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swsN
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swsN =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swsM
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swsM =
        case tup_swsS
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl_X25, tpl_B3) ->
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits_swsK =
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X45, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5r
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X48, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5o
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsS
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 130 0}]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    case tpl_X1N
    of _ [Occ=Dead]
    { (tpl_X1M, tpl_X1O, tpl_X3i, tpl_X3k, tpl_X3m, tpl_X3o, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       tpl_B9
       (GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl_B3 eta_X1I)
       (case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl_B3
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup_swsy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId, Str=DmdType]
      tup_swsy =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1V
        } } in
    let {
      $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
      [LclId, Str=DmdType]
      $dKnownNat_swsx =
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId, Str=DmdType]
      tup_swsw =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1X
        } } in
    let {
      $dKnownNat_swsv
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsv =
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsy
           of _ [Occ=Dead]
           { (tpl_X7i, tpl_X7l, tpl_X5n, tpl_X5p, tpl_X5r, tpl_X5t, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5t
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                    :: CLaSH.Class.Num.Resize rep_XuIL
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup_swsq
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId, Str=DmdType]
      tup_swsq =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1W
        } } in
    let {
      $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
      [LclId, Str=DmdType]
      $dKnownNat_swsp =
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId, Str=DmdType]
      tup_swso =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsn
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsn =
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsq
           of _ [Occ=Dead]
           { (tpl_X7k, tpl_X7n, tpl_X5o, tpl_X5q, tpl_X5s, tpl_X5u, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5u
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                    :: CLaSH.Class.Num.Resize rep_XuIM
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup_swsi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId, Str=DmdType]
      tup_swsi =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
      [LclId, Str=DmdType]
      $dKnownNat_swsg =
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId, Str=DmdType]
      tup_swsf =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X22
        } } in
    let {
      $dKnownNat_swse
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swse =
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 222 0}]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup_sws8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId, Str=DmdType]
      tup_sws8 =
        case tup_XvDd
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Z
        } } in
    let {
      $dBits_sws7
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      $dBits_sws7 =
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B3
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B6
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B7
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B8
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B9
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Ba
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bb
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bc
       })
      (case tup_XvDd
       of _ [Occ=Dead]
       { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
       ((tpl_B5
         `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                   <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                 :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                      ~#
                    (rep_XuIO size_XuIQ
                     -> rep_XuIO size_XuIQ
                     -> CLaSH.Class.Num.MResult
                          (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
          (eta_X1U
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ))
          (eta_X3N
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ)))
       `cast` (Sub cobox_dw1a
               ; Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                            GHC.TypeLits.+ size_XuIQ>_N
               :: CLaSH.Class.Num.MResult
                    (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       }
       })

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup_sws4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId, Str=DmdType]
      tup_sws4 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X20
        } } in
    let {
      $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
      [LclId, Str=DmdType]
      $dKnownNat_sws2 =
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      tup_sws1 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X24
        } } in
    let {
      $dKnownNat_sws0
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_sws0 =
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     (a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
                     `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                             -> Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                             :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> rep_XuIQ size_XuIS)
                                  ~#
                                (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS))
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ((a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
       `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
               :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> rep_XuIQ size_XuIS)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)))
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         (\ ($dKnownNat_avB0
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (ds_dw0H
                                               :: CLaSH.Sized.Fixed.Fixed
                                                    frac_XuIN rep_XuIP size_XuIR) ->
                                            CLaSH.Class.BitVector.toBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avB0
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (ds_dw0H
                                               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                                                       :: CLaSH.Sized.Fixed.Fixed
                                                            frac_XuIN rep_XuIP size_XuIR
                                                            ~#
                                                          rep_XuIP size_XuIR)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR>_R
                                                 -> (CLaSH.Sized.Vector.Vec
                                                       (Sym
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))
                                                       <CLaSH.Bit.Bit>_R)_R
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (CLaSH.Sized.Fixed.Fixed
                                                                frac_XuIN rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit))
                                         (\ ($dKnownNat_avBa
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (bv_auGX
                                               :: CLaSH.Sized.Vector.Vec
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))
                                                    CLaSH.Bit.Bit) ->
                                            CLaSH.Class.BitVector.fromBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avBa
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (bv_auGX
                                               `cast` ((CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N)
                                                          <CLaSH.Bit.Bit>_R)_R
                                                       :: CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit
                                                            ~#
                                                          CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit>_R
                                                 -> Sym
                                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> rep_XuIP size_XuIR)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    let {
      lvl_sxax
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           rep_XuIP size_XuIR
           -> CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      lvl_sxax =
        CLaSH.Class.BitVector.toBV
          @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
    let {
      lvl_sxay
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
           -> rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      lvl_sxay =
        CLaSH.Class.BitVector.fromBV
          @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ((\ ($dKnownNat_avB0
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (ds_dw0H
             :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
          lvl_sxax
            ($dKnownNat_avB0
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (ds_dw0H
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                          ~#
                        rep_XuIP size_XuIR)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
               -> (CLaSH.Sized.Vector.Vec
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                     <CLaSH.Bit.Bit>_R)_R
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize
                           (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                        CLaSH.Bit.Bit)))
      ((\ ($dKnownNat_avBa
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (bv_auGX
             :: CLaSH.Sized.Vector.Vec
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                  CLaSH.Bit.Bit) ->
          lvl_sxay
            ($dKnownNat_avBa
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (bv_auGX
             `cast` ((CLaSH.Sized.Vector.Vec
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                        <CLaSH.Bit.Bit>_R)_R
                     :: CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> rep_XuIP size_XuIR)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))

a_swC4
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swC4 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cdef_avAg =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
                          (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ((GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
      ((GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Ordering>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Ordering))
                         (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
                         (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ((GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Ordering>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Ordering)))
      ((GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
      ((GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))
                        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ((GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
      ((GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))

a_swC6 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swC6 = GHC.CString.unpackCString# "Fixed"#

a_swC9 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swC9 = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swCb :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swCb = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swC7 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swC7 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swC9
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCb
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwh :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swwh =
  Language.Haskell.TH.Syntax.Name
    (a_swC6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swC7

a_swCe :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swCe = GHC.CString.unpackCString# "Fixed"#

a_swCh :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swCh = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swCj :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swCj = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swCf :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swCf =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (a_swCh
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swCj
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwp :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swwp =
  Language.Haskell.TH.Syntax.Name
    (a_swCe
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swCf

lvl_sxaz :: Language.Haskell.TH.Syntax.Type
[LclId, Str=DmdType]
lvl_sxaz = Language.Haskell.TH.Syntax.ConT lvl_swwp

a_swCk
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 60 0}]
a_swCk =
  \ (@ (m_a4Ni :: * -> *))
    (eta_a4Nj :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    GHC.Base.return
      @ m_a4Ni
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_a4Nj)
      @ Language.Haskell.TH.Syntax.Type
      lvl_sxaz

Rec {
lgo_sxaB [Occ=LoopBreaker]
  :: Language.Haskell.TH.Lib.TypeQ
     -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
[LclId, Arity=2, Str=DmdType <L,U><S,1*U>]
lgo_sxaB =
  \ (z_awhM :: Language.Haskell.TH.Lib.TypeQ)
    (ds_awhN :: [Language.Haskell.TH.Lib.TypeQ]) ->
    case ds_awhN of _ [Occ=Dead] {
      [] -> z_awhM;
      : x_awhS xs_awhT ->
        lgo_sxaB
          ((Language.Haskell.TH.Lib.appT1 z_awhM x_awhS)
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          xs_awhT
    }
end Rec }

lvl_sxaC :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_sxaC =
  Language.Haskell.TH.Syntax.Name
    ((GHC.Types.[] @ GHC.Types.Char)
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    Language.Haskell.TH.Syntax.NameS

lvl_sxaE :: Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
lvl_sxaE = Language.Haskell.TH.Syntax.ConE lvl_swwh

a_swCv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
a_swCv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    let {
      w1_acZp :: Language.Haskell.TH.Lib.ExpQ
      [LclId, Str=DmdType]
      w1_acZp =
        ($dLift_avAq
         `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                   <rep_auGP size_auGQ>_N
                 :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                      ~#
                    (rep_auGP size_auGQ
                     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
          (f_auGR
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                        ~#
                      rep_auGP size_auGQ)) } in
    let {
      w1_akV2 :: Language.Haskell.TH.Lib.TypeQ
      [LclId, Str=DmdType]
      w1_akV2 =
        lgo_sxaB
          (a_swCk
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          (GHC.Types.:
             @ Language.Haskell.TH.Lib.TypeQ
             (let {
                l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                [LclId, Str=DmdType]
                l_a5DZ =
                  Language.Haskell.TH.Lib.numTyLit
                    ($dKnownNat_avAr
                     `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                             ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                             :: GHC.TypeLits.KnownNat frac_auGO
                                  ~#
                                GHC.Integer.Type.Integer)) } in
              (\ (@ (m_a5E0 :: * -> *))
                 (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                 GHC.Base.fmap
                   @ m_a5E0
                   (Control.Applicative.$p1Applicative
                      @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                   @ Language.Haskell.TH.Syntax.TyLit
                   @ Language.Haskell.TH.Syntax.Type
                   Language.Haskell.TH.Syntax.LitT
                   ((l_a5DZ
                     `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <Language.Haskell.TH.Syntax.TyLit>_N
                             :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                  ~#
                                (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                      @ m_a5E0 eta_a5E1))
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <Language.Haskell.TH.Syntax.Type>_N)
                      :: (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Type)
                           ~#
                         Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
             (GHC.Types.:
                @ Language.Haskell.TH.Lib.TypeQ
                (let {
                   x_X4Ts :: Language.Haskell.TH.Syntax.Name
                   [LclId, Str=DmdType]
                   x_X4Ts =
                     case ($dTypeable_avAt
                           `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                                     <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                                   :: Data.Typeable.Internal.Typeable rep_auGP
                                        ~#
                                      (GHC.Prim.Proxy# rep_auGP -> Data.Typeable.Internal.TypeRep)))
                            (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP)
                     of _ [Occ=Dead]
                     { Data.Typeable.Internal.TypeRep ww1_awCq ww2_awCr ww3_awCs
                                                      ww4_awCt ->
                     case GHC.List.reverse1
                            @ GHC.Types.Char
                            (Data.Typeable.Internal.$w$cshowsPrec
                               GHC.Show.shows27 ww3_awCs ww4_awCt (GHC.Types.[] @ GHC.Types.Char))
                            (GHC.Types.[] @ GHC.Types.Char)
                     of _ [Occ=Dead] {
                       [] -> lvl_sxaC;
                       : ds_a5Fa rev_a5Fb ->
                         case ds_a5Fa of wild22_a5Fd { GHC.Types.C# ds1_a5Ff ->
                         case ds1_a5Ff of _ [Occ=Dead] {
                           __DEFAULT ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    ds_a5Fa (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of _ [Occ=Dead] { (# ww1_a5Aw, ww2_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             };
                           '.' ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    ds_a5Fa (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of _ [Occ=Dead] { (# ww1_a5Aw, ww2_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             }
                         }
                         }
                     }
                     } } in
                 let {
                   lvl_sxaD :: Language.Haskell.TH.Syntax.Type
                   [LclId, Str=DmdType]
                   lvl_sxaD = Language.Haskell.TH.Syntax.ConT x_X4Ts } in
                 (\ (@ (m_X4Tv :: * -> *))
                    (eta_X4Tx :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
                    GHC.Base.return
                      @ m_X4Tv
                      (Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_X4Tx)
                      @ Language.Haskell.TH.Syntax.Type
                      lvl_sxaD)
                 `cast` (Sym
                           (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.Type>_N)
                         :: (forall (m_a4LE :: * -> *).
                             Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                             m_a4LE Language.Haskell.TH.Syntax.Type)
                              ~#
                            Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                (GHC.Types.:
                   @ Language.Haskell.TH.Lib.TypeQ
                   (let {
                      l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                      [LclId, Str=DmdType]
                      l_a5DZ =
                        Language.Haskell.TH.Lib.numTyLit
                          ($dKnownNat_avAs
                           `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                                   ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                                   :: GHC.TypeLits.KnownNat size_auGQ
                                        ~#
                                      GHC.Integer.Type.Integer)) } in
                    (\ (@ (m_a5E0 :: * -> *))
                       (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                       GHC.Base.fmap
                         @ m_a5E0
                         (Control.Applicative.$p1Applicative
                            @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                         @ Language.Haskell.TH.Syntax.TyLit
                         @ Language.Haskell.TH.Syntax.Type
                         Language.Haskell.TH.Syntax.LitT
                         ((l_a5DZ
                           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <Language.Haskell.TH.Syntax.TyLit>_N
                                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                        ~#
                                      (forall (m_a4LE :: * -> *).
                                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                       m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                            @ m_a5E0 eta_a5E1))
                    `cast` (Sym
                              (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                 <Language.Haskell.TH.Syntax.Type>_N)
                            :: (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.Type)
                                 ~#
                               Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)))) } in
    \ (@ (m_akV3 :: * -> *))
      (w2_akV4 :: Language.Haskell.TH.Syntax.Quasi m_akV3) ->
      case w2_akV4
      of _ [Occ=Dead]
      { Language.Haskell.TH.Syntax.D:Quasi ww1_akV7 ww2_akV8 ww3_akV9
                                           ww4_akVa ww5_akVb ww6_akVc ww7_akVd ww8_akVe ww9_akVf
                                           ww10_akVg ww11_akVh ww12_akVi ww13_akVj ww14_akVk
                                           ww15_akVl ww16_akVm ww17_akVn ww18_akVo ->
      case ww1_akV7
      of _ [Occ=Dead]
      { GHC.Base.D:Monad ww20_akVt ww21_akVu ww22_akVv ww23_akVw ->
      let {
        a_akVs :: GHC.Base.Monad m_akV3
        [LclId, Str=DmdType]
        a_akVs =
          GHC.Base.D:Monad
            @ m_akV3 ww20_akVt ww21_akVu ww22_akVv ww23_akVw } in
      let {
        eta_akVy :: Language.Haskell.TH.Syntax.Quasi m_akV3
        [LclId, Str=DmdType]
        eta_akVy =
          Language.Haskell.TH.Syntax.D:Quasi
            @ m_akV3
            a_akVs
            ww2_akV8
            ww3_akV9
            ww4_akVa
            ww5_akVb
            ww6_akVc
            ww7_akVd
            ww8_akVe
            ww9_akVf
            ww10_akVg
            ww11_akVh
            ww12_akVi
            ww13_akVj
            ww14_akVk
            ww15_akVl
            ww16_akVm
            ww17_akVn
            ww18_akVo } in
      let {
        lvl_sxaG :: m_akV3 Language.Haskell.TH.Syntax.Type
        [LclId, Str=DmdType]
        lvl_sxaG =
          (w1_akV2
           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                     <Language.Haskell.TH.Syntax.Type>_N
                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
                        ~#
                      (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)))
            @ m_akV3 eta_akVy } in
      ww20_akVt
        @ Language.Haskell.TH.Syntax.Exp
        @ Language.Haskell.TH.Syntax.Exp
        (let {
           a_acZP :: GHC.Base.Monad m_akV3
           [LclId, Str=DmdType]
           a_acZP =
             GHC.Base.D:Monad
               @ m_akV3 ww20_akVt ww21_akVu ww22_akVv ww23_akVw } in
         let {
           eta_acZV :: Language.Haskell.TH.Syntax.Quasi m_akV3
           [LclId, Str=DmdType]
           eta_acZV =
             Language.Haskell.TH.Syntax.D:Quasi
               @ m_akV3
               a_acZP
               ww2_akV8
               ww3_akV9
               ww4_akVa
               ww5_akVb
               ww6_akVc
               ww7_akVd
               ww8_akVe
               ww9_akVf
               ww10_akVg
               ww11_akVh
               ww12_akVi
               ww13_akVj
               ww14_akVk
               ww15_akVl
               ww16_akVm
               ww17_akVn
               ww18_akVo } in
         let {
           lvl_sxaF :: m_akV3 Language.Haskell.TH.Syntax.Exp
           [LclId, Str=DmdType]
           lvl_sxaF =
             (w1_acZp
              `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N
                      :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
                           ~#
                         (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Exp)))
               @ m_akV3 eta_acZV } in
         ww20_akVt
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_akVv @ Language.Haskell.TH.Syntax.Exp lvl_sxaE)
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_akVt
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl_sxaF
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_akVv
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_akVz :: Language.Haskell.TH.Syntax.Exp) ->
           ww20_akVt
             @ Language.Haskell.TH.Syntax.Type
             @ Language.Haskell.TH.Syntax.Exp
             lvl_sxaG
             (\ (x1_akVA :: Language.Haskell.TH.Syntax.Type) ->
                ww22_akVv
                  @ Language.Haskell.TH.Syntax.Exp
                  (Language.Haskell.TH.Syntax.SigE x_akVz x1_akVA)))
      }
      }

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$clift_avAv =
  a_swCv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                              (rep_XuMX :: GHC.TypeLits.Nat -> *)
                              (size_XuMZ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
                       -> <GHC.TypeLits.KnownNat frac_XuMV>_R
                       -> <GHC.TypeLits.KnownNat size_XuMZ>_R
                       -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
                       :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  a_swCv
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Common sub-expression:

==================== Common sub-expression ====================
Result size of Common sub-expression
  = {terms: 2,225, types: 9,672, coercions: 947}

lvl_sxai :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_sxai = GHC.CString.unpackCString# "Negative exponent"#

lvl_swvg :: GHC.Types.Double
[LclId, Str=DmdType b]
lvl_swvg = GHC.Err.error @ GHC.Types.Double lvl_sxai

lvl_swve :: GHC.Types.Double
[LclId, Str=DmdType]
lvl_swve = GHC.Types.D# 1.0

lvl_swv0 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv0 = __integer 1

lvl_swv2 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv2 = lvl_swv0

lvl_swv4 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv4 = __integer 2

lvl_swv6 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv6 = lvl_swv4

Rec {
g1_swuY [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[LclId, Arity=3, Str=DmdType]
g1_swuY =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP :: GHC.Types.Double) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y1_akDO GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2 of wild4_akDQ {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y1_akDO lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3 of wild5_akDT {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x1_akDN x1_akDN)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y1_akDO lvl_swv0) lvl_swv4)
              (GHC.Float.timesDouble x1_akDN z_akDP);
          GHC.Types.True -> GHC.Float.timesDouble x1_akDN z_akDP
        }
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Float.timesDouble x1_akDN x1_akDN)
          (GHC.Integer.Type.quotInteger y1_akDO lvl_swv4)
          z_akDP
    }
    }
end Rec }

lvl_swuS :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuS = lvl_swv0

lvl_swv8 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv8 = lvl_swv0

lvl_swva :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swva = lvl_swv4

lvl_swvc :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvc = lvl_swv4

Rec {
f_swuQ [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId, Arity=2, Str=DmdType]
f_swuQ =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y_akDB GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2 of wild2_akDC {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y_akDB lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3 of wild3_akDF {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x_akDA x_akDA)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y_akDB lvl_swv0) lvl_swv4)
              x_akDA;
          GHC.Types.True -> x_akDA
        }
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Float.timesDouble x_akDA x_akDA)
          (GHC.Integer.Type.quotInteger y_akDB lvl_swv4)
    }
    }
end Rec }

lvl_swuH :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuH = __integer 0

lvl_swuK :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuK = lvl_swuH

$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId, Arity=2, Str=DmdType]
$s^_swu6 =
  \ (eta_akDk :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger# eta1_akDl lvl_swuH
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# eta1_akDl lvl_swuK
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        }
        };
      GHC.Types.True -> lvl_swvg
    }
    }

lvl_swvh :: GHC.Types.Double
[LclId, Str=DmdType]
lvl_swvh = GHC.Types.D# 2.0

a_swwS :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swwS = GHC.CString.unpackCString# "Fixed"#

a_swwV :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swwV = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swwX :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swwX = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swwT :: Language.Haskell.TH.Syntax.NameFlavour
[LclId, Str=DmdType]
a_swwT =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvo :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swvo =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swwT

a_swx0 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swx0 = GHC.CString.unpackCString# "fromInteger"#

a_swx3 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swx3 = GHC.CString.unpackCString# "base"#

a_swx5 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swx5 = GHC.CString.unpackCString# "GHC.Num"#

a_swx1 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId, Str=DmdType]
a_swx1 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (a_swx3
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swx5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvw :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swvw =
  Language.Haskell.TH.Syntax.Name
    (a_swx0
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swx1

lvl_sxaj :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxaj = lvl_swuH

lvl_sxak :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxak = lvl_swuH

lvl_sxal :: Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
lvl_sxal = Language.Haskell.TH.Syntax.ConE lvl_swvo

lvl_sxam :: Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
lvl_sxam = Language.Haskell.TH.Syntax.VarE lvl_swvw

a_swxS
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[LclId, Arity=5, Str=DmdType]
a_swxS =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      x_akVD :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      x_akVD =
        let {
          rMax_swu0 :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          rMax_swu0 =
            GHC.Real.toInteger
              @ (rep_avhN size_avhO)
              $dIntegral_avlP
              (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
        let {
          truncated_swu2 :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          truncated_swu2 =
            case a_auGC of wild_aw7Y { GHC.Types.D# x_aw80 ->
            case $s^_swu6
                   lvl_swvh
                   ($dKnownNat_avlM
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                            :: GHC.TypeLits.KnownNat frac_avhM ~# GHC.Integer.Type.Integer))
            of wild1_aw82 { GHC.Types.D# y_aw84 ->
            case GHC.Integer.Type.decodeDoubleInteger
                   (GHC.Prim.*## x_aw80 y_aw84)
            of ds_aw8O { (# ipv_aw8Q, ipv1_aw8R #) ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ipv1_aw8R 0)
            of wild1_aw8T {
              GHC.Types.False ->
                GHC.Integer.Type.shiftLInteger ipv_aw8Q ipv1_aw8R;
              GHC.Types.True ->
                let {
                  s_aw8X :: GHC.Prim.Int#
                  [LclId, Str=DmdType]
                  s_aw8X = GHC.Prim.negateInt# ipv1_aw8R } in
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># s_aw8X 52)
                of wild2_aw8Z {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger# ipv_aw8Q lvl_swuH
                    of wild3_aw92 { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild3_aw92
                    of wild4_aw93 {
                      GHC.Types.False ->
                        case GHC.Integer.Type.integerToInt ipv_aw8Q
                        of n_aw96 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.uncheckedIShiftRA# n_aw96 s_aw8X)
                        };
                      GHC.Types.True ->
                        case GHC.Integer.Type.integerToInt
                               (GHC.Integer.Type.negateInteger ipv_aw8Q)
                        of n_aw99 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.negateInt# (GHC.Prim.uncheckedIShiftRA# n_aw99 s_aw8X))
                        }
                    }
                    };
                  GHC.Types.True -> lvl_swuH
                }
            }
            }
            }
            } } in
        case GHC.Integer.Type.gtInteger# truncated_swu2 rMax_swu0
        of wild_akJ6 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ6 of wild_X13 {
          GHC.Types.False ->
            let {
              rMin_swu1 :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              rMin_swu1 =
                GHC.Real.toInteger
                  @ (rep_avhN size_avhO)
                  $dIntegral_avlP
                  (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
            case GHC.Integer.Type.ltInteger# truncated_swu2 rMin_swu1
            of wild_a4It { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It of wild_Xd {
              GHC.Types.False -> truncated_swu2;
              GHC.Types.True -> rMin_swu1
            }
            };
          GHC.Types.True -> rMax_swu0
        }
        } } in
    let {
      lvl_sxan :: Language.Haskell.TH.Syntax.Exp
      [LclId, Str=DmdType]
      lvl_sxan =
        Language.Haskell.TH.Syntax.LitE
          (Language.Haskell.TH.Syntax.IntegerL x_akVD) } in
    \ (@ (m_awx9 :: * -> *))
      (w1_awxa :: Language.Haskell.TH.Syntax.Quasi m_awx9) ->
      case w1_awxa
      of ww_awxb
      { Language.Haskell.TH.Syntax.D:Quasi ww1_awxd ww2_awxe ww3_awxf
                                           ww4_awxg ww5_awxh ww6_awxi ww7_awxj ww8_awxk ww9_awxl
                                           ww10_awxm ww11_awxn ww12_awxo ww13_awxp ww14_awxq
                                           ww15_awxr ww16_awxs ww17_awxt ww18_awxu ->
      case ww1_awxd
      of ww19_awxw
      { GHC.Base.D:Monad ww20_awxy ww21_awxz ww22_awxA ww23_awxB ->
      let {
        lvl_sxao :: m_awx9 Language.Haskell.TH.Syntax.Exp
        [LclId, Str=DmdType]
        lvl_sxao = ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxan } in
      let {
        lvl_sxap :: m_awx9 Language.Haskell.TH.Syntax.Exp
        [LclId, Str=DmdType]
        lvl_sxap =
          ww20_awxy
            @ Language.Haskell.TH.Syntax.Exp
            @ Language.Haskell.TH.Syntax.Exp
            (ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxam)
            (\ (x_Xd36 :: Language.Haskell.TH.Syntax.Exp) ->
               ww20_awxy
                 @ Language.Haskell.TH.Syntax.Exp
                 @ Language.Haskell.TH.Syntax.Exp
                 lvl_sxao
                 (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                    ww22_awxA
                      @ Language.Haskell.TH.Syntax.Exp
                      (Language.Haskell.TH.Syntax.AppE x_Xd36 x1_acZX))) } in
      ww20_awxy
        @ Language.Haskell.TH.Syntax.Exp
        @ (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
        (ww20_awxy
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxal)
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_awxy
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl_sxap
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_awxA
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_awxD :: Language.Haskell.TH.Syntax.Exp) ->
           ww22_awxA
             @ (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
             (x_awxD
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:TExp[0]
                           <CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO>_N)
                      :: Language.Haskell.TH.Syntax.Exp
                           ~#
                         Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))
      }
      }

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX, Arity=5, Str=DmdType]
CLaSH.Sized.Fixed.fLit =
  a_swxS
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      repBV_swtT =
        case tup_avmQ
        of wild_XY
        { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        case tpl_B6 of cobox_avJ3 { GHC.Types.Eq# cobox_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl_B4
           (tpl_B8
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_B1)
        `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        }
        } } in
    let {
      cobox_swtU
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_swtU =
        case tup_avmQ
        of wild_X14
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      s_swtS =
        case cobox_swtU of cobox_avJi { GHC.Types.Eq# cobox_dw7d ->
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (repBV_swtT
              `cast` ((CLaSH.Sized.Vector.Vec
                         (Sym cobox_dw7d) <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
        } } in
    let {
      cobox_swtV
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId, Str=DmdType]
      cobox_swtV =
        case tup_avmQ
        of wild_X10
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    case tup_avmQ
    of wild_X1c
    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl_Ba eta_B1
    of wild_X5J {
      GHC.Types.False ->
        case cobox_swtU of cobox_avJ8 { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of wild_Xu {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of wild_Xv {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of cobox_XvJ5 { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of cobox_XvJ4 { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of wild_Xv {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of cobox_XvJ5 { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of cobox_XvJ4 { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        };
      GHC.Types.True ->
        case cobox_swtU of cobox_avJ8 { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of wild_Xu {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of wild_Xv {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of cobox_XvJ7 { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of cobox_avJl { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of wild_Xv {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of cobox_XvJ7 { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of cobox_avJl { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        }
    }
    }

lvl_swvz :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvz = lvl_swuH

lvl_swvy :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvy = lvl_swuH

lvl_swvB :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvB = lvl_swuH

lvl_swvA :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvA = lvl_swuH

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat_swtH =
        case tup_avnK
        of wild_X12
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_swtI =
        case tup_avnK
        of wild_X10
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_swtI
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat_swtH
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_akJ3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ3 of wild_X1o {
      GHC.Types.False ->
        let {
          $dBounded_swtD :: GHC.Enum.Bounded (rep_avjs size2_avju)
          [LclId, Str=DmdType]
          $dBounded_swtD =
            case tup_avnK
            of wild_X1e
            { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X1u
            } } in
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId, Str=DmdType]
          fMax_swtA =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          $dBits_swtF :: Data.Bits.Bits (rep_avjs size1_avjt)
          [LclId, Str=DmdType]
          $dBits_swtF =
            case tup_avnK
            of wild_X16
            { (tpl_X5L, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId, Str=DmdType]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (case tup_avnK
               of wild_X14
               { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
               (tpl_B6
                `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                        :: CLaSH.Class.Num.Resize rep_avjs
                             ~#
                           (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                            (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                            rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                 @ size2_avju @ size1_avjt $dKnownNat_swtH $dKnownNat_swtI fMax_swtA
               }) } in
        let {
          $dNum_swtE :: GHC.Num.Num (rep_avjs size1_avjt)
          [LclId, Str=DmdType]
          $dNum_swtE =
            case tup_avnK
            of wild_X1a
            { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            } } in
        case tup_avnK
        of wild_X1g
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFQ { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFQ)
        of wild_Xr {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFQ)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swuH)
            of wild_Xv {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of wild_Xw {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swuH)
                of wild_Xw {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_XkFQ wild_akCB)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swuH)
            of wild_Xv {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of wild_Xw {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swuH)
                of wild_Xw {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_avnK
        of wild_X1g
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFG { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFG)
        of wild_Xo {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFG)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_XkFG wild_akCB)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX, Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX, Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_avxa
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_akCB { __DEFAULT ->
    GHC.Types.I# wild_akCB
    }

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId, Arity=1, Str=DmdType]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX, Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId, Arity=2, Str=DmdType]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId, Arity=1, Str=DmdType]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX, Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId, Arity=2, Str=DmdType]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId, Arity=1, Str=DmdType]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]], Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

lvl_swvD :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvD = GHC.Types.C# '-'

lvl_swvC :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvC = lvl_swuH

lvl_swvG :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvG = GHC.Types.C# '0'

ds_swvM :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
ds_swvM = lvl_swv0

dt_akMa :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
dt_akMa = __integer 10

lvl_swvV
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Arity=1, Str=DmdType]
lvl_swvV =
  \ (ds_awe3
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    (case ds_awe3 of wild_awe4 { (x_awe6, y_awe7) ->
     case x_awe6 of wild_awdA { GHC.Types.I# x1_awdC ->
     case x1_awdC of wild1_awdE {
       __DEFAULT -> GHC.Types.I# (GHC.Prim.+# x1_awdC 1);
       9223372036854775807 -> GHC.Enum.$fEnumInt2
     }
     }
     },
     case ds_awe3 of wild_awe9 { (x_aweb, y_awec) ->
     case y_awec of ww_awdH { GHC.Real.:% ww1_awdJ ww2_awdK ->
     case GHC.Real.$w$sreduce
            (GHC.Integer.Type.timesInteger ww1_awdJ dt_akMa)
            (GHC.Integer.Type.timesInteger ww2_awdK GHC.Real.$fEnumRatio1)
     of ww6_awdS { (# ww7_awdU, ww8_awdV #) ->
     GHC.Real.:% @ GHC.Integer.Type.Integer ww7_awdU ww8_awdV
     }
     }
     })

lvl_swvX :: GHC.Types.Int
[LclId, Str=DmdType]
lvl_swvX = GHC.Types.I# 0

lvl_sww5 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww5 = lvl_swv4

lvl_sww6 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww6 = lvl_swv0

lvl_sww7 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww7 = lvl_swv4

lvl_sww8 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww8 = lvl_swv0

lvl_sww4 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww4 = lvl_swuH

lvl_sww9 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww9 = lvl_swv4

lvl_sxaq
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[LclId, Str=DmdType]
lvl_sxaq =
  \ (x_awzz
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    (r_awzA [OS=OneShot]
       :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]) ->
    case x_awzz of wild_afnB { (ds1_afnD, y_afnE) ->
    case y_afnE of wild_awdn { GHC.Real.:% ds1_awdp y_awdq ->
    case GHC.Integer.Type.eqInteger# y_awdq lvl_swv0
    of wild_a2f3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3 of wild_awzB {
      GHC.Types.False -> r_awzA;
      GHC.Types.True ->
        GHC.Types.:
          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          x_awzz
          r_awzA
    }
    }
    }
    }

lvl_sxar :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxar = lvl_swuH

lvl_sxas :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxas = lvl_swuH

lvl_sxau :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_sxau = GHC.Types.C# '.'

lvl_sxav :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_sxav = lvl_sxau

lvl_sxaw :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_sxaw = lvl_sxau

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId, Arity=5, Str=DmdType]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      nF_swti :: GHC.Types.Int
      [LclId, Str=DmdType]
      nF_swti =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_avFx
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        } } in
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      a_swOO :: [GHC.Types.Char]
      [LclId, Str=DmdType]
      a_swOO =
        let {
          eta_awcR
            :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          [LclId, Str=DmdType]
          eta_awcR =
            case GHC.List.iterateFB
                   @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                   @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                   lvl_sxaq
                   lvl_swvV
                   (lvl_swvX,
                    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swuH
                    of wild_a4It { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It of wild_X1C {
                      GHC.Types.False ->
                        case nF_swti of wild_awO7 { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of wild1_awOb {
                          GHC.Types.False ->
                            let {
                              a_swOs :: GHC.Integer.Type.Integer
                              [LclId, Str=DmdType]
                              a_swOs =
                                case wild1_awOb of wild1_XwRo {
                                  GHC.Types.False ->
                                    case x_awO9 of wild2_awOe {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_swv4 x_awO9;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of wild2_awOe {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_swtk
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_swv4 x_awO9) lvl_swv0))
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of ww_awf3 { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger fRepI_swtk lvl_swuH)
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of ww_awf3 { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        };
                      GHC.Types.True ->
                        case nF_swti of wild_awO7 { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of wild1_awOb {
                          GHC.Types.False ->
                            let {
                              a_swOy :: GHC.Integer.Type.Integer
                              [LclId, Str=DmdType]
                              a_swOy =
                                case wild1_awOb of wild1_XwRo {
                                  GHC.Types.False ->
                                    case x_awO9 of wild2_awOe {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_swv4 x_awO9;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of wild2_awOe {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_abs_swtj
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_swv4 x_awO9) lvl_swv0))
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of ww_awf3 { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger fRepI_abs_swtj lvl_swuH)
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of ww_awf3 { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        }
                    }
                    })
            of wild_awde {
              [] ->
                Data.Maybe.fromJust1
                  @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer);
              : a1_awdh ds1_awdi -> a1_awdh
            } } in
        let {
          str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          str_auHK =
            case eta_awcR of wild_awcX { (x_awcZ, y_awd0) ->
            case y_awd0 of wild_awcI { GHC.Real.:% x_awcK ds1_awcL ->
            case GHC.Show.$w$cshowsPrec
                   0 x_awcK (GHC.Types.[] @ GHC.Types.Char)
            of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
            }
            }
            } } in
        let {
          lvl_sxat :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          lvl_sxat = GHC.Types.: @ GHC.Types.Char lvl_swvG str_auHK } in
        case eta_awcR of wild_awcS { (x_awcU, y_awcV) ->
        case x_awcU of wild_akIT { GHC.Types.I# x_akIV ->
        case GHC.List.$wlenAcc @ GHC.Types.Char str_auHK 0
        of ww_awOK { __DEFAULT ->
        let {
          n#_awbi :: GHC.Prim.Int#
          [LclId, Str=DmdType]
          n#_awbi = GHC.Prim.-# x_akIV ww_awOK } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# n#_awbi 0)
        of wild1_awbk {
          GHC.Types.False ->
            letrec {
              xs_awyT [Occ=LoopBreaker] :: GHC.Prim.Int# -> [GHC.Types.Char]
              [LclId, Arity=1, Str=DmdType]
              xs_awyT =
                \ (m_awz0 :: GHC.Prim.Int#) ->
                  case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# m_awz0 1)
                  of wild_awz1 {
                    GHC.Types.False ->
                      GHC.Types.:
                        @ GHC.Types.Char lvl_swvG (xs_awyT (GHC.Prim.-# m_awz0 1));
                    GHC.Types.True -> lvl_sxat
                  }; } in
            xs_awyT n#_awbi;
          GHC.Types.True -> str_auHK
        }
        }
        }
        } } in
    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swuH
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It of wild_X1C {
      GHC.Types.False ->
        case nF_swti of wild_aiKL { GHC.Types.I# x_aiKN ->
        let {
          ww_al4F :: GHC.Prim.Int#
          [LclId, Str=DmdType]
          ww_al4F = GHC.Prim.negateInt# x_aiKN } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
        of wild_al4G {
          GHC.Types.False ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftRInteger
                      fRepI_swtk (GHC.Prim.negateInt# ww_al4F))
                   (GHC.Types.[] @ GHC.Types.Char)
            of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
            };
          GHC.Types.True ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftLInteger fRepI_swtk ww_al4F)
                   (GHC.Types.[] @ GHC.Types.Char)
            of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
            }
        }
        };
      GHC.Types.True ->
        GHC.Base.++
          @ GHC.Types.Char
          (GHC.Types.:
             @ GHC.Types.Char
             lvl_swvD
             (case nF_swti of wild_aiKL { GHC.Types.I# x_aiKN ->
              let {
                ww_al4F :: GHC.Prim.Int#
                [LclId, Str=DmdType]
                ww_al4F = GHC.Prim.negateInt# x_aiKN } in
              case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
              of wild_al4G {
                GHC.Types.False ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftRInteger
                            fRepI_abs_swtj (GHC.Prim.negateInt# ww_al4F))
                         (GHC.Types.[] @ GHC.Types.Char)
                  of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  };
                GHC.Types.True ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftLInteger fRepI_abs_swtj ww_al4F)
                         (GHC.Types.[] @ GHC.Types.Char)
                  of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  }
              }
              }))
          (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
    }
    }

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId, Arity=7, Str=DmdType]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.++
      @ GHC.Types.Char
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy
         x_a2fY)
      s_a2fZ

$cshowList_avIE
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId, Arity=6, Str=DmdType]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_B2 :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta_B1 :: GHC.Base.String) ->
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (\ (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
         (s_a2fZ [OS=OneShot] :: GHC.Base.String) ->
         GHC.Base.++
           @ GHC.Types.Char
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY)
           s_a2fZ)
      eta_B2
      eta_B1

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId, Arity=3, Str=DmdType]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_avFg of wild_X1y { (tpl_X1z, tpl_X1B) ->
    case tpl_X1B of cobox_XvFS { GHC.Types.Eq# cobox_dw3M ->
    ((tpl_X1z
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId, Arity=3, Str=DmdType]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId, Arity=3, Str=DmdType]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swta
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swta =
        case tup_avDN of wild_X1A { (tpl_X1L, tpl_X1N, tpl_B3) ->
        tpl_X1N
        } } in
    let {
      $dBounded_swt9
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swt9 =
        case tup_swta
        of wild_X1C
        { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1N
        } } in
    let {
      $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_swt8 =
        case tup_swta
        of wild_X3v
        { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swt7 =
        case tup_swta
        of wild_X1M
        { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swt6
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_swt6 =
        case tup_swta
        of wild_X1O
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swt5
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swt5 =
        case tup_swta
        of wild_X1S
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swt4
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swt4 =
        case tup_swta
        of wild_X1U
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of wild_X2g { (tpl_X22, tpl_X24, tpl_B3) ->
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits_swt2 =
            case tpl_X22
            of wild_X26
            { (tpl_X21, tpl_X23, tpl_X5p, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tpl_X22
            of wild_X7m
            { (tpl_X43, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5q
            },
            case tpl_X22
            of wild_X7o
            { (tpl_X7n, tpl_X46, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tpl_X22
            of wild_X2a
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl_X22
            of wild_X2c
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X22
            of wild_X2e
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tup_swta
            of wild_X1E
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5n
            },
            case tup_swta
            of wild_X1G
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tup_swta
            of wild_X1Q
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tup_swta
            of wild_X1W
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swta
            of wild_X1Y
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId, Arity=3, Str=DmdType]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    let {
      tup_swsS
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_auHe
             frac2_auHg
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
             size2_auHh
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      tup_swsS =
        case tup_avDN of wild_X1B { (tpl_X1M, tpl_X1O, tpl_B3) ->
        tpl_X1O
        } } in
    let {
      $dBounded_swsR
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swsR =
        case tup_swsS
        of wild_X1D
        { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1O
        } } in
    let {
      $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      $dBits_swsQ =
        case tup_swsS
        of wild_X3x
        { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    let {
      $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swsP =
        case tup_swsS
        of wild_X1N
        { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dKnownNat_swsO
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat_swsO =
        case tup_swsS
        of wild_X1P
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dBits_swsN
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swsN =
        case tup_swsS
        of wild_X1T
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swsM
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swsM =
        case tup_swsS
        of wild_X1V
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    case tup_avDN of wild_X2h { (tpl_X23, tpl_X25, tpl_B3) ->
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits_swsK =
            case tpl_X23
            of wild_X27
            { (tpl_X22, tpl_X24, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tpl_X23
            of wild_X7o
            { (tpl_X45, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5r
            },
            case tpl_X23
            of wild_X7q
            { (tpl_X7p, tpl_X48, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tpl_X23
            of wild_X2b
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl_X23
            of wild_X2d
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X23
            of wild_X2f
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       ((CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tup_swsS
            of wild_X1F
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5o
            },
            case tup_swsS
            of wild_X1H
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tup_swsS
            of wild_X1R
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tup_swsS
            of wild_X1X
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tup_swsS
            of wild_X1Z
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=2, Str=DmdType]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    case tup_avBm
    of wild_X1B { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    case tpl_X1N
    of wild_X1F
    { (tpl_X1M, tpl_X1O, tpl_X3i, tpl_X3k, tpl_X3m, tpl_X3o, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       tpl_B9
       (GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl_B3 eta_X1I)
       (case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId, Arity=2, Str=DmdType]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_avBm
    of wild_X1C { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl_B3
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=2, Str=DmdType]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup_swsy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId, Str=DmdType]
      tup_swsy =
        case tup_XvDa
        of wild_X1D { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1V
        } } in
    let {
      $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
      [LclId, Str=DmdType]
      $dKnownNat_swsx =
        case tup_swsy
        of wild_X1H
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId, Str=DmdType]
      tup_swsw =
        case tup_XvDa
        of wild_X3E { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1X
        } } in
    let {
      $dKnownNat_swsv
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsv =
        case tup_swsw
        of wild_X1X
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of wild_X1L
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of wild_X1N
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of wild_X1P
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of wild_X1R
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of wild_X1T
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of wild_X1V
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of wild_X1F
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of wild_X1Z
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDa
        of wild_X23 { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsy
           of wild_X21
           { (tpl_X7i, tpl_X7l, tpl_X5n, tpl_X5p, tpl_X5r, tpl_X5t, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5t
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                    :: CLaSH.Class.Num.Resize rep_XuIL
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=2, Str=DmdType]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup_swsq
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId, Str=DmdType]
      tup_swsq =
        case tup_XvDb
        of wild_X1E { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1W
        } } in
    let {
      $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
      [LclId, Str=DmdType]
      $dKnownNat_swsp =
        case tup_swsq
        of wild_X1I
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId, Str=DmdType]
      tup_swso =
        case tup_XvDb
        of wild_X1K { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsn
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsn =
        case tup_swso
        of wild_X1Y
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of wild_X1M
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of wild_X1O
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of wild_X1Q
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of wild_X1S
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of wild_X1U
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of wild_X1W
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of wild_X1G
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of wild_X20
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDb
        of wild_X24 { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsq
           of wild_X22
           { (tpl_X7k, tpl_X7n, tpl_X5o, tpl_X5q, tpl_X5s, tpl_X5u, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5u
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                    :: CLaSH.Class.Num.Resize rep_XuIM
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=3, Str=DmdType]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup_swsi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId, Str=DmdType]
      tup_swsi =
        case tup_XvDc
        of wild_X1F { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
      [LclId, Str=DmdType]
      $dKnownNat_swsg =
        case tup_swsi
        of wild_X1L
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId, Str=DmdType]
      tup_swsf =
        case tup_XvDc
        of wild_X1N { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X22
        } } in
    let {
      $dKnownNat_swse
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swse =
        case tup_swsf
        of wild_X21
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of wild_X1P
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of wild_X1R
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of wild_X3W
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of wild_X1V
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of wild_X1X
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of wild_X1Z
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of wild_X1H
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of wild_X23
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDc
        of wild_X25 { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsi
           of wild_X3F
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
          (case tup_swsi
           of wild_X3F
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=3, Str=DmdType]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup_sws8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId, Str=DmdType]
      tup_sws8 =
        case tup_XvDd
        of wild_X1G { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Z
        } } in
    let {
      $dBits_sws7
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      $dBits_sws7 =
        case tup_sws8
        of wild_X1O
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of wild_X1I
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of wild_X1K
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B3
       },
       case tup_sws8
       of wild_X1M
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of wild_X1S
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B6
       },
       case tup_sws8
       of wild_X3S
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B7
       },
       case tup_sws8
       of wild_X1W
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B8
       },
       case tup_sws8
       of wild_X1Y
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B9
       },
       case tup_sws8
       of wild_X20
       { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Ba
       },
       case tup_sws8
       of wild_X22
       { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bb
       },
       case tup_sws8
       of wild_X24
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bc
       })
      (case tup_XvDd
       of wild_X26 { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       case tpl_B6 of cobox_XvCT { GHC.Types.Eq# cobox_dw1a ->
       ((tpl_B5
         `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                   <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                 :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                      ~#
                    (rep_XuIO size_XuIQ
                     -> rep_XuIO size_XuIQ
                     -> CLaSH.Class.Num.MResult
                          (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
          (eta_X1U
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ))
          (eta_X3N
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ)))
       `cast` (Sub cobox_dw1a
               ; Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                            GHC.TypeLits.+ size_XuIQ>_N
               :: CLaSH.Class.Num.MResult
                    (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       }
       })

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=3, Str=DmdType]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup_sws4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId, Str=DmdType]
      tup_sws4 =
        case tup_XvDe
        of wild_X1H { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X20
        } } in
    let {
      $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
      [LclId, Str=DmdType]
      $dKnownNat_sws2 =
        case tup_sws4
        of wild_X1N
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      tup_sws1 =
        case tup_XvDe
        of wild_X1P { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X24
        } } in
    let {
      $dKnownNat_sws0
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_sws0 =
        case tup_sws1
        of wild_X23
        { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of wild_X1R
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of wild_X1T
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of wild_X40
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of wild_X1X
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of wild_X1Z
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of wild_X21
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of wild_X3O
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of wild_X25
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDe
        of wild_X27 { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_sws4
           of wild_X1L
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
          (case tup_sws4
           of wild_X1L
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     (a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
                     `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                             -> Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                             :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> rep_XuIQ size_XuIS)
                                  ~#
                                (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS))
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ((a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
       `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
               :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> rep_XuIQ size_XuIS)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)))
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         (\ ($dKnownNat_avB0
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (ds_dw0H
                                               :: CLaSH.Sized.Fixed.Fixed
                                                    frac_XuIN rep_XuIP size_XuIR) ->
                                            CLaSH.Class.BitVector.toBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avB0
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (ds_dw0H
                                               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                                                       :: CLaSH.Sized.Fixed.Fixed
                                                            frac_XuIN rep_XuIP size_XuIR
                                                            ~#
                                                          rep_XuIP size_XuIR)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR>_R
                                                 -> (CLaSH.Sized.Vector.Vec
                                                       (Sym
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))
                                                       <CLaSH.Bit.Bit>_R)_R
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (CLaSH.Sized.Fixed.Fixed
                                                                frac_XuIN rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit))
                                         (\ ($dKnownNat_avBa
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (bv_auGX
                                               :: CLaSH.Sized.Vector.Vec
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))
                                                    CLaSH.Bit.Bit) ->
                                            CLaSH.Class.BitVector.fromBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avBa
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (bv_auGX
                                               `cast` ((CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N)
                                                          <CLaSH.Bit.Bit>_R)_R
                                                       :: CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit
                                                            ~#
                                                          CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit>_R
                                                 -> Sym
                                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> rep_XuIP size_XuIR)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    let {
      lvl_sxax
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           rep_XuIP size_XuIR
           -> CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      lvl_sxax =
        CLaSH.Class.BitVector.toBV
          @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
    let {
      lvl_sxay
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
           -> rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      lvl_sxay =
        CLaSH.Class.BitVector.fromBV
          @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ((\ ($dKnownNat_avB0
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (ds_dw0H
             :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
          lvl_sxax
            ($dKnownNat_avB0
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (ds_dw0H
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                          ~#
                        rep_XuIP size_XuIR)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
               -> (CLaSH.Sized.Vector.Vec
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                     <CLaSH.Bit.Bit>_R)_R
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize
                           (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                        CLaSH.Bit.Bit)))
      ((\ ($dKnownNat_avBa
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (bv_auGX
             :: CLaSH.Sized.Vector.Vec
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                  CLaSH.Bit.Bit) ->
          lvl_sxay
            ($dKnownNat_avBa
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (bv_auGX
             `cast` ((CLaSH.Sized.Vector.Vec
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                        <CLaSH.Bit.Bit>_R)_R
                     :: CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> rep_XuIP size_XuIR)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))

a_swC4
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[LclId, Arity=1, Str=DmdType]
a_swC4 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId, Arity=1, Str=DmdType]
$cdef_avAg =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
                          (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ((GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
      ((GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Ordering>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Ordering))
                         (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
                         (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ((GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Ordering>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Ordering)))
      ((GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
      ((GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))
                        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ((GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
      ((GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))

a_swC6 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swC6 = a_swwS

a_swC9 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swC9 = a_swwV

a_swCb :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swCb = a_swwX

a_swC7 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId, Str=DmdType]
a_swC7 = a_swwT

lvl_swwh :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swwh = lvl_swvo

a_swCe :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swCe = a_swwS

a_swCh :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swCh = a_swwV

a_swCj :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swCj = a_swwX

a_swCf :: Language.Haskell.TH.Syntax.NameFlavour
[LclId, Str=DmdType]
a_swCf =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwp :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swwp =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swCf

lvl_sxaz :: Language.Haskell.TH.Syntax.Type
[LclId, Str=DmdType]
lvl_sxaz = Language.Haskell.TH.Syntax.ConT lvl_swwp

a_swCk
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[LclId, Arity=1, Str=DmdType]
a_swCk =
  \ (@ (m_a4Ni :: * -> *))
    (eta_a4Nj :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    GHC.Base.return
      @ m_a4Ni
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_a4Nj)
      @ Language.Haskell.TH.Syntax.Type
      lvl_sxaz

Rec {
lgo_sxaB [Occ=LoopBreaker]
  :: Language.Haskell.TH.Lib.TypeQ
     -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
[LclId, Arity=2, Str=DmdType <L,U><S,1*U>]
lgo_sxaB =
  \ (z_awhM :: Language.Haskell.TH.Lib.TypeQ)
    (ds_awhN :: [Language.Haskell.TH.Lib.TypeQ]) ->
    case ds_awhN of wild_awhO {
      [] -> z_awhM;
      : x_awhS xs_awhT ->
        lgo_sxaB
          ((Language.Haskell.TH.Lib.appT1 z_awhM x_awhS)
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          xs_awhT
    }
end Rec }

lvl_sxaC :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_sxaC =
  Language.Haskell.TH.Syntax.Name
    ((GHC.Types.[] @ GHC.Types.Char)
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    Language.Haskell.TH.Syntax.NameS

lvl_sxaE :: Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
lvl_sxaE = lvl_sxal

a_swCv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[LclId, Arity=5, Str=DmdType]
a_swCv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    let {
      w1_acZp :: Language.Haskell.TH.Lib.ExpQ
      [LclId, Str=DmdType]
      w1_acZp =
        ($dLift_avAq
         `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                   <rep_auGP size_auGQ>_N
                 :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                      ~#
                    (rep_auGP size_auGQ
                     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
          (f_auGR
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                        ~#
                      rep_auGP size_auGQ)) } in
    let {
      w1_akV2 :: Language.Haskell.TH.Lib.TypeQ
      [LclId, Str=DmdType]
      w1_akV2 =
        lgo_sxaB
          (a_swCk
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          (GHC.Types.:
             @ Language.Haskell.TH.Lib.TypeQ
             (let {
                l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                [LclId, Str=DmdType]
                l_a5DZ =
                  Language.Haskell.TH.Lib.numTyLit
                    ($dKnownNat_avAr
                     `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                             ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                             :: GHC.TypeLits.KnownNat frac_auGO
                                  ~#
                                GHC.Integer.Type.Integer)) } in
              (\ (@ (m_a5E0 :: * -> *))
                 (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                 GHC.Base.fmap
                   @ m_a5E0
                   (Control.Applicative.$p1Applicative
                      @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                   @ Language.Haskell.TH.Syntax.TyLit
                   @ Language.Haskell.TH.Syntax.Type
                   Language.Haskell.TH.Syntax.LitT
                   ((l_a5DZ
                     `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <Language.Haskell.TH.Syntax.TyLit>_N
                             :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                  ~#
                                (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                      @ m_a5E0 eta_a5E1))
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <Language.Haskell.TH.Syntax.Type>_N)
                      :: (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Type)
                           ~#
                         Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
             (GHC.Types.:
                @ Language.Haskell.TH.Lib.TypeQ
                (let {
                   x_X4Ts :: Language.Haskell.TH.Syntax.Name
                   [LclId, Str=DmdType]
                   x_X4Ts =
                     case ($dTypeable_avAt
                           `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                                     <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                                   :: Data.Typeable.Internal.Typeable rep_auGP
                                        ~#
                                      (GHC.Prim.Proxy# rep_auGP -> Data.Typeable.Internal.TypeRep)))
                            (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP)
                     of ww_awCo
                     { Data.Typeable.Internal.TypeRep ww1_awCq ww2_awCr ww3_awCs
                                                      ww4_awCt ->
                     case GHC.List.reverse1
                            @ GHC.Types.Char
                            (Data.Typeable.Internal.$w$cshowsPrec
                               GHC.Show.shows27 ww3_awCs ww4_awCt (GHC.Types.[] @ GHC.Types.Char))
                            (GHC.Types.[] @ GHC.Types.Char)
                     of wild21_a5F6 {
                       [] -> lvl_sxaC;
                       : ds_a5Fa rev_a5Fb ->
                         case ds_a5Fa of wild22_a5Fd { GHC.Types.C# ds1_a5Ff ->
                         case ds1_a5Ff of ds2_a5Fh {
                           __DEFAULT ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    ds_a5Fa (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of ww_a5Au { (# ww1_a5Aw, ww2_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             };
                           '.' ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    ds_a5Fa (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of ww_a5Au { (# ww1_a5Aw, ww2_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             }
                         }
                         }
                     }
                     } } in
                 let {
                   lvl_sxaD :: Language.Haskell.TH.Syntax.Type
                   [LclId, Str=DmdType]
                   lvl_sxaD = Language.Haskell.TH.Syntax.ConT x_X4Ts } in
                 (\ (@ (m_X4Tv :: * -> *))
                    (eta_X4Tx :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
                    GHC.Base.return
                      @ m_X4Tv
                      (Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_X4Tx)
                      @ Language.Haskell.TH.Syntax.Type
                      lvl_sxaD)
                 `cast` (Sym
                           (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.Type>_N)
                         :: (forall (m_a4LE :: * -> *).
                             Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                             m_a4LE Language.Haskell.TH.Syntax.Type)
                              ~#
                            Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                (GHC.Types.:
                   @ Language.Haskell.TH.Lib.TypeQ
                   (let {
                      l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                      [LclId, Str=DmdType]
                      l_a5DZ =
                        Language.Haskell.TH.Lib.numTyLit
                          ($dKnownNat_avAs
                           `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                                   ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                                   :: GHC.TypeLits.KnownNat size_auGQ
                                        ~#
                                      GHC.Integer.Type.Integer)) } in
                    (\ (@ (m_a5E0 :: * -> *))
                       (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                       GHC.Base.fmap
                         @ m_a5E0
                         (Control.Applicative.$p1Applicative
                            @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                         @ Language.Haskell.TH.Syntax.TyLit
                         @ Language.Haskell.TH.Syntax.Type
                         Language.Haskell.TH.Syntax.LitT
                         ((l_a5DZ
                           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <Language.Haskell.TH.Syntax.TyLit>_N
                                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                        ~#
                                      (forall (m_a4LE :: * -> *).
                                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                       m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                            @ m_a5E0 eta_a5E1))
                    `cast` (Sym
                              (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                 <Language.Haskell.TH.Syntax.Type>_N)
                            :: (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.Type)
                                 ~#
                               Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)))) } in
    \ (@ (m_akV3 :: * -> *))
      (w2_akV4 :: Language.Haskell.TH.Syntax.Quasi m_akV3) ->
      case w2_akV4
      of ww_akV5
      { Language.Haskell.TH.Syntax.D:Quasi ww1_akV7 ww2_akV8 ww3_akV9
                                           ww4_akVa ww5_akVb ww6_akVc ww7_akVd ww8_akVe ww9_akVf
                                           ww10_akVg ww11_akVh ww12_akVi ww13_akVj ww14_akVk
                                           ww15_akVl ww16_akVm ww17_akVn ww18_akVo ->
      case ww1_akV7
      of ww19_akVq
      { GHC.Base.D:Monad ww20_akVt ww21_akVu ww22_akVv ww23_akVw ->
      let {
        a_akVs :: GHC.Base.Monad m_akV3
        [LclId, Str=DmdType]
        a_akVs = ww1_akV7 } in
      let {
        eta_akVy :: Language.Haskell.TH.Syntax.Quasi m_akV3
        [LclId, Str=DmdType]
        eta_akVy = w2_akV4 } in
      let {
        lvl_sxaG :: m_akV3 Language.Haskell.TH.Syntax.Type
        [LclId, Str=DmdType]
        lvl_sxaG =
          (w1_akV2
           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                     <Language.Haskell.TH.Syntax.Type>_N
                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
                        ~#
                      (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)))
            @ m_akV3 w2_akV4 } in
      ww20_akVt
        @ Language.Haskell.TH.Syntax.Exp
        @ Language.Haskell.TH.Syntax.Exp
        (let {
           a_acZP :: GHC.Base.Monad m_akV3
           [LclId, Str=DmdType]
           a_acZP = ww1_akV7 } in
         let {
           eta_acZV :: Language.Haskell.TH.Syntax.Quasi m_akV3
           [LclId, Str=DmdType]
           eta_acZV = w2_akV4 } in
         let {
           lvl_sxaF :: m_akV3 Language.Haskell.TH.Syntax.Exp
           [LclId, Str=DmdType]
           lvl_sxaF =
             (w1_acZp
              `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N
                      :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
                           ~#
                         (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Exp)))
               @ m_akV3 w2_akV4 } in
         ww20_akVt
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_akVv @ Language.Haskell.TH.Syntax.Exp lvl_sxal)
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_akVt
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl_sxaF
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_akVv
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_akVz :: Language.Haskell.TH.Syntax.Exp) ->
           ww20_akVt
             @ Language.Haskell.TH.Syntax.Type
             @ Language.Haskell.TH.Syntax.Exp
             lvl_sxaG
             (\ (x1_akVA :: Language.Haskell.TH.Syntax.Type) ->
                ww22_akVv
                  @ Language.Haskell.TH.Syntax.Exp
                  (Language.Haskell.TH.Syntax.SigE x_akVz x1_akVA)))
      }
      }

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId, Arity=5, Str=DmdType]
$clift_avAv =
  a_swCv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                              (rep_XuMX :: GHC.TypeLits.Nat -> *)
                              (size_XuMZ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
                       -> <GHC.TypeLits.KnownNat frac_XuMV>_R
                       -> <GHC.TypeLits.KnownNat size_XuMZ>_R
                       -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
                       :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  a_swCv
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Float inwards:

==================== Float inwards ====================
Result size of Float inwards
  = {terms: 2,225, types: 9,672, coercions: 947}

lvl_sxai :: [GHC.Types.Char]
[LclId, Str=DmdType]
lvl_sxai = GHC.CString.unpackCString# "Negative exponent"#

lvl_swvg :: GHC.Types.Double
[LclId, Str=DmdType b]
lvl_swvg = GHC.Err.error @ GHC.Types.Double lvl_sxai

lvl_swve :: GHC.Types.Double
[LclId, Str=DmdType]
lvl_swve = GHC.Types.D# 1.0

lvl_swv0 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv0 = __integer 1

lvl_swv2 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv2 = lvl_swv0

lvl_swv4 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv4 = __integer 2

lvl_swv6 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv6 = lvl_swv4

Rec {
g1_swuY [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[LclId, Arity=3, Str=DmdType]
g1_swuY =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP :: GHC.Types.Double) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y1_akDO GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2 of wild4_akDQ {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y1_akDO lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3 of wild5_akDT {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x1_akDN x1_akDN)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y1_akDO lvl_swv0) lvl_swv4)
              (GHC.Float.timesDouble x1_akDN z_akDP);
          GHC.Types.True -> GHC.Float.timesDouble x1_akDN z_akDP
        }
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Float.timesDouble x1_akDN x1_akDN)
          (GHC.Integer.Type.quotInteger y1_akDO lvl_swv4)
          z_akDP
    }
    }
end Rec }

lvl_swuS :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuS = lvl_swv0

lvl_swv8 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swv8 = lvl_swv0

lvl_swva :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swva = lvl_swv4

lvl_swvc :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvc = lvl_swv4

Rec {
f_swuQ [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId, Arity=2, Str=DmdType]
f_swuQ =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y_akDB GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2 of wild2_akDC {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y_akDB lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3 of wild3_akDF {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x_akDA x_akDA)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y_akDB lvl_swv0) lvl_swv4)
              x_akDA;
          GHC.Types.True -> x_akDA
        }
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Float.timesDouble x_akDA x_akDA)
          (GHC.Integer.Type.quotInteger y_akDB lvl_swv4)
    }
    }
end Rec }

lvl_swuH :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuH = __integer 0

lvl_swuK :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swuK = lvl_swuH

$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId, Arity=2, Str=DmdType]
$s^_swu6 =
  \ (eta_akDk :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger# eta1_akDl lvl_swuH
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# eta1_akDl lvl_swuK
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        }
        };
      GHC.Types.True -> lvl_swvg
    }
    }

lvl_swvh :: GHC.Types.Double
[LclId, Str=DmdType]
lvl_swvh = GHC.Types.D# 2.0

a_swwS :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swwS = GHC.CString.unpackCString# "Fixed"#

a_swwV :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swwV = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swwX :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swwX = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swwT :: Language.Haskell.TH.Syntax.NameFlavour
[LclId, Str=DmdType]
a_swwT =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvo :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swvo =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swwT

a_swx0 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swx0 = GHC.CString.unpackCString# "fromInteger"#

a_swx3 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swx3 = GHC.CString.unpackCString# "base"#

a_swx5 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swx5 = GHC.CString.unpackCString# "GHC.Num"#

a_swx1 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId, Str=DmdType]
a_swx1 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (a_swx3
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swx5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvw :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swvw =
  Language.Haskell.TH.Syntax.Name
    (a_swx0
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swx1

lvl_sxaj :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxaj = lvl_swuH

lvl_sxak :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxak = lvl_swuH

lvl_sxal :: Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
lvl_sxal = Language.Haskell.TH.Syntax.ConE lvl_swvo

lvl_sxam :: Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
lvl_sxam = Language.Haskell.TH.Syntax.VarE lvl_swvw

a_swxS
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[LclId, Arity=5, Str=DmdType]
a_swxS =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      x_akVD :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      x_akVD =
        let {
          truncated_swu2 :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          truncated_swu2 =
            case a_auGC of wild_aw7Y { GHC.Types.D# x_aw80 ->
            case $s^_swu6
                   lvl_swvh
                   ($dKnownNat_avlM
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                            :: GHC.TypeLits.KnownNat frac_avhM ~# GHC.Integer.Type.Integer))
            of wild1_aw82 { GHC.Types.D# y_aw84 ->
            case GHC.Integer.Type.decodeDoubleInteger
                   (GHC.Prim.*## x_aw80 y_aw84)
            of ds_aw8O { (# ipv_aw8Q, ipv1_aw8R #) ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ipv1_aw8R 0)
            of wild1_aw8T {
              GHC.Types.False ->
                GHC.Integer.Type.shiftLInteger ipv_aw8Q ipv1_aw8R;
              GHC.Types.True ->
                let {
                  s_aw8X :: GHC.Prim.Int#
                  [LclId, Str=DmdType]
                  s_aw8X = GHC.Prim.negateInt# ipv1_aw8R } in
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># s_aw8X 52)
                of wild2_aw8Z {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger# ipv_aw8Q lvl_swuH
                    of wild3_aw92 { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild3_aw92
                    of wild4_aw93 {
                      GHC.Types.False ->
                        case GHC.Integer.Type.integerToInt ipv_aw8Q
                        of n_aw96 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.uncheckedIShiftRA# n_aw96 s_aw8X)
                        };
                      GHC.Types.True ->
                        case GHC.Integer.Type.integerToInt
                               (GHC.Integer.Type.negateInteger ipv_aw8Q)
                        of n_aw99 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.negateInt# (GHC.Prim.uncheckedIShiftRA# n_aw99 s_aw8X))
                        }
                    }
                    };
                  GHC.Types.True -> lvl_swuH
                }
            }
            }
            }
            } } in
        let {
          rMax_swu0 :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          rMax_swu0 =
            GHC.Real.toInteger
              @ (rep_avhN size_avhO)
              $dIntegral_avlP
              (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
        case GHC.Integer.Type.gtInteger# truncated_swu2 rMax_swu0
        of wild_akJ6 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ6 of wild_X13 {
          GHC.Types.False ->
            let {
              rMin_swu1 :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              rMin_swu1 =
                GHC.Real.toInteger
                  @ (rep_avhN size_avhO)
                  $dIntegral_avlP
                  (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
            case GHC.Integer.Type.ltInteger# truncated_swu2 rMin_swu1
            of wild_a4It { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It of wild_Xd {
              GHC.Types.False -> truncated_swu2;
              GHC.Types.True -> rMin_swu1
            }
            };
          GHC.Types.True -> rMax_swu0
        }
        } } in
    let {
      lvl_sxan :: Language.Haskell.TH.Syntax.Exp
      [LclId, Str=DmdType]
      lvl_sxan =
        Language.Haskell.TH.Syntax.LitE
          (Language.Haskell.TH.Syntax.IntegerL x_akVD) } in
    \ (@ (m_awx9 :: * -> *))
      (w1_awxa :: Language.Haskell.TH.Syntax.Quasi m_awx9) ->
      case w1_awxa
      of ww_awxb
      { Language.Haskell.TH.Syntax.D:Quasi ww1_awxd ww2_awxe ww3_awxf
                                           ww4_awxg ww5_awxh ww6_awxi ww7_awxj ww8_awxk ww9_awxl
                                           ww10_awxm ww11_awxn ww12_awxo ww13_awxp ww14_awxq
                                           ww15_awxr ww16_awxs ww17_awxt ww18_awxu ->
      case ww1_awxd
      of ww19_awxw
      { GHC.Base.D:Monad ww20_awxy ww21_awxz ww22_awxA ww23_awxB ->
      ww20_awxy
        @ Language.Haskell.TH.Syntax.Exp
        @ (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
        (let {
           lvl_sxap :: m_awx9 Language.Haskell.TH.Syntax.Exp
           [LclId, Str=DmdType]
           lvl_sxap =
             let {
               lvl_sxao :: m_awx9 Language.Haskell.TH.Syntax.Exp
               [LclId, Str=DmdType]
               lvl_sxao = ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxan } in
             ww20_awxy
               @ Language.Haskell.TH.Syntax.Exp
               @ Language.Haskell.TH.Syntax.Exp
               (ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxam)
               (\ (x_Xd36 :: Language.Haskell.TH.Syntax.Exp) ->
                  ww20_awxy
                    @ Language.Haskell.TH.Syntax.Exp
                    @ Language.Haskell.TH.Syntax.Exp
                    lvl_sxao
                    (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                       ww22_awxA
                         @ Language.Haskell.TH.Syntax.Exp
                         (Language.Haskell.TH.Syntax.AppE x_Xd36 x1_acZX))) } in
         ww20_awxy
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxal)
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_awxy
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl_sxap
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_awxA
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_awxD :: Language.Haskell.TH.Syntax.Exp) ->
           ww22_awxA
             @ (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
             (x_awxD
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:TExp[0]
                           <CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO>_N)
                      :: Language.Haskell.TH.Syntax.Exp
                           ~#
                         Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))
      }
      }

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX, Arity=5, Str=DmdType]
CLaSH.Sized.Fixed.fLit =
  a_swxS
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    case tup_avmQ
    of wild_X1c
    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
    let {
      cobox_swtV
        :: CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz) ~ n_aviz
      [LclId, Str=DmdType]
      cobox_swtV =
        case tup_avmQ
        of wild_X10
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        } } in
    let {
      cobox_swtU
        :: ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (n_aviz GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      cobox_swtU =
        case tup_avmQ
        of wild_X14
        { (tpl_X1l, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B2
        } } in
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      repBV_swtT =
        case tup_avmQ
        of wild_XY
        { (tpl_X1g, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        case tpl_B6 of cobox_avJ3 { GHC.Types.Eq# cobox_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl_B4
           (tpl_B8
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_B1)
        `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        }
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      s_swtS =
        case cobox_swtU of cobox_avJi { GHC.Types.Eq# cobox_dw7d ->
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (repBV_swtT
              `cast` ((CLaSH.Sized.Vector.Vec
                         (Sym cobox_dw7d) <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
        } } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl_Ba eta_B1
    of wild_X5J {
      GHC.Types.False ->
        case cobox_swtU of cobox_avJ8 { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of wild_Xu {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of wild_Xv {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of cobox_XvJ5 { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of cobox_XvJ4 { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of wild_Xv {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of cobox_XvJ5 { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of cobox_XvJ4 { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        };
      GHC.Types.True ->
        case cobox_swtU of cobox_avJ8 { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of wild_Xu {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of wild_Xv {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of cobox_XvJ7 { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of cobox_avJl { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of wild_Xv {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case cobox_swtV of cobox_XvJ7 { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case cobox_swtV of cobox_avJl { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        }
    }
    }

lvl_swvz :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvz = lvl_swuH

lvl_swvy :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvy = lvl_swuH

lvl_swvB :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvB = lvl_swuH

lvl_swvA :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvA = lvl_swuH

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_swtI =
        case tup_avnK
        of wild_X10
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat_swtH =
        case tup_avnK
        of wild_X12
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_swtI
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat_swtH
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_akJ3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ3 of wild_X1o {
      GHC.Types.False ->
        case tup_avnK
        of wild_X1g
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFQ { __DEFAULT ->
        let {
          $dNum_swtE :: GHC.Num.Num (rep_avjs size1_avjt)
          [LclId, Str=DmdType]
          $dNum_swtE =
            case tup_avnK
            of wild_X1a
            { (tpl_X1r, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            } } in
        let {
          $dBits_swtF :: Data.Bits.Bits (rep_avjs size1_avjt)
          [LclId, Str=DmdType]
          $dBits_swtF =
            case tup_avnK
            of wild_X16
            { (tpl_X5L, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        let {
          $dBounded_swtD :: GHC.Enum.Bounded (rep_avjs size2_avju)
          [LclId, Str=DmdType]
          $dBounded_swtD =
            case tup_avnK
            of wild_X1e
            { (tpl_X1u, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X1u
            } } in
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId, Str=DmdType]
          fMax_swtA =
            GHC.Enum.maxBound @ (rep_avjs size2_avju) $dBounded_swtD } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId, Str=DmdType]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              $dBits_swtF
              (case tup_avnK
               of wild_X14
               { (tpl_X1m, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
               (tpl_B6
                `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                        :: CLaSH.Class.Num.Resize rep_avjs
                             ~#
                           (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                            (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                            rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                 @ size2_avju @ size1_avjt $dKnownNat_swtH $dKnownNat_swtI fMax_swtA
               }) } in
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFQ)
        of wild_Xr {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFQ)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swuH)
            of wild_Xv {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       mask_swtz
                of wild_Xw {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swuH)
                of wild_Xw {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  $dBits_swtF
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_XkFQ wild_akCB)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swuH)
            of wild_Xv {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       mask_swtz
                of wild_Xw {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) $dBounded_swtD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) $dBits_swtF)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) $dBits_swtF shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) $dNum_swtE lvl_swuH)
                of wild_Xw {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_avnK
        of wild_X1g
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFG { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFG)
        of wild_Xo {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFG)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_XkFG wild_akCB)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX, Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX, Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_avxa
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_akCB { __DEFAULT ->
    GHC.Types.I# wild_akCB
    }

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId, Arity=1, Str=DmdType]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX, Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId, Arity=2, Str=DmdType]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId, Arity=1, Str=DmdType]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX, Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId, Arity=2, Str=DmdType]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX, Arity=2, Str=DmdType]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId, Arity=1, Str=DmdType]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]], Arity=1, Str=DmdType]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

lvl_swvD :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvD = GHC.Types.C# '-'

lvl_swvC :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_swvC = lvl_swuH

lvl_swvG :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_swvG = GHC.Types.C# '0'

ds_swvM :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
ds_swvM = lvl_swv0

dt_akMa :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
dt_akMa = __integer 10

lvl_swvV
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId, Arity=1, Str=DmdType]
lvl_swvV =
  \ (ds_awe3
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    (case ds_awe3 of wild_awe4 { (x_awe6, y_awe7) ->
     case x_awe6 of wild_awdA { GHC.Types.I# x1_awdC ->
     case x1_awdC of wild1_awdE {
       __DEFAULT -> GHC.Types.I# (GHC.Prim.+# x1_awdC 1);
       9223372036854775807 -> GHC.Enum.$fEnumInt2
     }
     }
     },
     case ds_awe3 of wild_awe9 { (x_aweb, y_awec) ->
     case y_awec of ww_awdH { GHC.Real.:% ww1_awdJ ww2_awdK ->
     case GHC.Real.$w$sreduce
            (GHC.Integer.Type.timesInteger ww1_awdJ dt_akMa)
            (GHC.Integer.Type.timesInteger ww2_awdK GHC.Real.$fEnumRatio1)
     of ww6_awdS { (# ww7_awdU, ww8_awdV #) ->
     GHC.Real.:% @ GHC.Integer.Type.Integer ww7_awdU ww8_awdV
     }
     }
     })

lvl_swvX :: GHC.Types.Int
[LclId, Str=DmdType]
lvl_swvX = GHC.Types.I# 0

lvl_sww5 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww5 = lvl_swv4

lvl_sww6 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww6 = lvl_swv0

lvl_sww7 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww7 = lvl_swv4

lvl_sww8 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww8 = lvl_swv0

lvl_sww4 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww4 = lvl_swuH

lvl_sww9 :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sww9 = lvl_swv4

lvl_sxaq
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[LclId, Str=DmdType]
lvl_sxaq =
  \ (x_awzz
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    (r_awzA [OS=OneShot]
       :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]) ->
    case x_awzz of wild_afnB { (ds1_afnD, y_afnE) ->
    case y_afnE of wild_awdn { GHC.Real.:% ds1_awdp y_awdq ->
    case GHC.Integer.Type.eqInteger# y_awdq lvl_swv0
    of wild_a2f3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3 of wild_awzB {
      GHC.Types.False -> r_awzA;
      GHC.Types.True ->
        GHC.Types.:
          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          x_awzz
          r_awzA
    }
    }
    }
    }

lvl_sxar :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxar = lvl_swuH

lvl_sxas :: GHC.Integer.Type.Integer
[LclId, Str=DmdType]
lvl_sxas = lvl_swuH

lvl_sxau :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_sxau = GHC.Types.C# '.'

lvl_sxav :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_sxav = lvl_sxau

lvl_sxaw :: GHC.Types.Char
[LclId, Str=DmdType]
lvl_sxaw = lvl_sxau

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId, Arity=5, Str=DmdType]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swuH
    of wild_a4It { __DEFAULT ->
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      nF_swti :: GHC.Types.Int
      [LclId, Str=DmdType]
      nF_swti =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_avFx
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        } } in
    let {
      a_swOO :: [GHC.Types.Char]
      [LclId, Str=DmdType]
      a_swOO =
        let {
          eta_awcR
            :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          [LclId, Str=DmdType]
          eta_awcR =
            case GHC.List.iterateFB
                   @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
                   @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
                   lvl_sxaq
                   lvl_swvV
                   (lvl_swvX,
                    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swuH
                    of wild_a4It { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It of wild_X1C {
                      GHC.Types.False ->
                        case nF_swti of wild_awO7 { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of wild1_awOb {
                          GHC.Types.False ->
                            let {
                              a_swOs :: GHC.Integer.Type.Integer
                              [LclId, Str=DmdType]
                              a_swOs =
                                case wild1_awOb of wild1_XwRo {
                                  GHC.Types.False ->
                                    case x_awO9 of wild2_awOe {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_swv4 x_awO9;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of wild2_awOe {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_swtk
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_swv4 x_awO9) lvl_swv0))
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of ww_awf3 { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger fRepI_swtk lvl_swuH)
                                          (GHC.Integer.Type.signumInteger a_swOs))
                                       (GHC.Integer.Type.absInteger a_swOs)
                                of ww_awf3 { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        };
                      GHC.Types.True ->
                        case nF_swti of wild_awO7 { GHC.Types.I# x_awO9 ->
                        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                        of wild1_awOb {
                          GHC.Types.False ->
                            let {
                              a_swOy :: GHC.Integer.Type.Integer
                              [LclId, Str=DmdType]
                              a_swOy =
                                case wild1_awOb of wild1_XwRo {
                                  GHC.Types.False ->
                                    case x_awO9 of wild2_awOe {
                                      __DEFAULT -> GHC.Real.$wf1 lvl_swv4 x_awO9;
                                      0 -> GHC.Real.$fEnumRatio1
                                    };
                                  GHC.Types.True -> GHC.Real.^3
                                } } in
                            case x_awO9 of wild2_awOe {
                              __DEFAULT ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger
                                             fRepI_abs_swtj
                                             (GHC.Integer.Type.minusInteger
                                                (GHC.Real.$wf1 lvl_swv4 x_awO9) lvl_swv0))
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of ww_awf3 { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                };
                              0 ->
                                case GHC.Real.$w$sreduce
                                       (GHC.Integer.Type.timesInteger
                                          (GHC.Integer.Type.andInteger fRepI_abs_swtj lvl_swuH)
                                          (GHC.Integer.Type.signumInteger a_swOy))
                                       (GHC.Integer.Type.absInteger a_swOy)
                                of ww_awf3 { (# ww1_awf5, ww2_awf6 #) ->
                                GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                                }
                            };
                          GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                        }
                        }
                    }
                    })
            of wild_awde {
              [] ->
                Data.Maybe.fromJust1
                  @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer);
              : a1_awdh ds1_awdi -> a1_awdh
            } } in
        case eta_awcR of wild_awcS { (x_awcU, y_awcV) ->
        case x_awcU of wild_akIT { GHC.Types.I# x_akIV ->
        let {
          str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          str_auHK =
            case eta_awcR of wild_awcX { (x_awcZ, y_awd0) ->
            case y_awd0 of wild_awcI { GHC.Real.:% x_awcK ds1_awcL ->
            case GHC.Show.$w$cshowsPrec
                   0 x_awcK (GHC.Types.[] @ GHC.Types.Char)
            of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
            }
            }
            } } in
        case GHC.List.$wlenAcc @ GHC.Types.Char str_auHK 0
        of ww_awOK { __DEFAULT ->
        let {
          n#_awbi :: GHC.Prim.Int#
          [LclId, Str=DmdType]
          n#_awbi = GHC.Prim.-# x_akIV ww_awOK } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# n#_awbi 0)
        of wild1_awbk {
          GHC.Types.False ->
            (let {
               lvl_sxat :: [GHC.Types.Char]
               [LclId, Str=DmdType]
               lvl_sxat = GHC.Types.: @ GHC.Types.Char lvl_swvG str_auHK } in
             letrec {
               xs_awyT [Occ=LoopBreaker] :: GHC.Prim.Int# -> [GHC.Types.Char]
               [LclId, Arity=1, Str=DmdType]
               xs_awyT =
                 \ (m_awz0 :: GHC.Prim.Int#) ->
                   case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# m_awz0 1)
                   of wild_awz1 {
                     GHC.Types.False ->
                       GHC.Types.:
                         @ GHC.Types.Char lvl_swvG (xs_awyT (GHC.Prim.-# m_awz0 1));
                     GHC.Types.True -> lvl_sxat
                   }; } in
             xs_awyT)
              n#_awbi;
          GHC.Types.True -> str_auHK
        }
        }
        }
        } } in
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It of wild_X1C {
      GHC.Types.False ->
        case nF_swti of wild_aiKL { GHC.Types.I# x_aiKN ->
        let {
          ww_al4F :: GHC.Prim.Int#
          [LclId, Str=DmdType]
          ww_al4F = GHC.Prim.negateInt# x_aiKN } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
        of wild_al4G {
          GHC.Types.False ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftRInteger
                      fRepI_swtk (GHC.Prim.negateInt# ww_al4F))
                   (GHC.Types.[] @ GHC.Types.Char)
            of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
            };
          GHC.Types.True ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftLInteger fRepI_swtk ww_al4F)
                   (GHC.Types.[] @ GHC.Types.Char)
            of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
            }
        }
        };
      GHC.Types.True ->
        GHC.Base.++
          @ GHC.Types.Char
          (GHC.Types.:
             @ GHC.Types.Char
             lvl_swvD
             (case nF_swti of wild_aiKL { GHC.Types.I# x_aiKN ->
              let {
                ww_al4F :: GHC.Prim.Int#
                [LclId, Str=DmdType]
                ww_al4F = GHC.Prim.negateInt# x_aiKN } in
              case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
              of wild_al4G {
                GHC.Types.False ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftRInteger
                            fRepI_abs_swtj (GHC.Prim.negateInt# ww_al4F))
                         (GHC.Types.[] @ GHC.Types.Char)
                  of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  };
                GHC.Types.True ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftLInteger fRepI_abs_swtj ww_al4F)
                         (GHC.Types.[] @ GHC.Types.Char)
                  of ww2_a2hY { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  }
              }
              }))
          (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
    }
    }

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId, Arity=7, Str=DmdType]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.++
      @ GHC.Types.Char
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy
         x_a2fY)
      s_a2fZ

$cshowList_avIE
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId, Arity=6, Str=DmdType]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_B2 :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta_B1 :: GHC.Base.String) ->
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (\ (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
         (s_a2fZ [OS=OneShot] :: GHC.Base.String) ->
         GHC.Base.++
           @ GHC.Types.Char
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY)
           s_a2fZ)
      eta_B2
      eta_B1

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId, Arity=3, Str=DmdType]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_avFg of wild_X1y { (tpl_X1z, tpl_X1B) ->
    case tpl_X1B of cobox_XvFS { GHC.Types.Eq# cobox_dw3M ->
    ((tpl_X1z
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId, Arity=3, Str=DmdType]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId, Arity=3, Str=DmdType]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_avDN of wild_X2g { (tpl_X22, tpl_X24, tpl_B3) ->
    (let {
       tup_swta
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_auHe
              frac2_auHg
              (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
              size2_auHh
              (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
       [LclId, Str=DmdType]
       tup_swta =
         case tup_avDN of wild_X1A { (tpl_X1L, tpl_X1N, tpl_B3) ->
         tpl_X1N
         } } in
     let {
       $dKnownNat_swt4
         :: GHC.TypeLits.KnownNat
              (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
       [LclId, Str=DmdType]
       $dKnownNat_swt4 =
         case tup_swta
         of wild_X1U
         { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_Ba
         } } in
     let {
       $dBits_swt5
         :: Data.Bits.Bits
              (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
       [LclId, Str=DmdType]
       $dBits_swt5 =
         case tup_swta
         of wild_X1S
         { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B9
         } } in
     let {
       $dKnownNat_swt6
         :: GHC.TypeLits.KnownNat
              (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
       [LclId, Str=DmdType]
       $dKnownNat_swt6 =
         case tup_swta
         of wild_X1O
         { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         } } in
     let {
       $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
       [LclId, Str=DmdType]
       $dResize_swt7 =
         case tup_swta
         of wild_X1M
         { (tpl_X1R, tpl_X1T, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B6
         } } in
     let {
       $dBounded_swt9
         :: GHC.Enum.Bounded
              (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
       [LclId, Str=DmdType]
       $dBounded_swt9 =
         case tup_swta
         of wild_X1C
         { (tpl_X1N, tpl_X1P, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_X1N
         } } in
     GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (((let {
            $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
            [LclId, Str=DmdType]
            $dBits_swt2 =
              case tpl_X22
              of wild_X26
              { (tpl_X21, tpl_X23, tpl_X5p, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B5
              } } in
          CLaSH.Sized.Fixed.resizeF
            @ frac1_auHd
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size1_auHf
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            ($dBounded_swt9,
             Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
             case tpl_X22
             of wild_X7m
             { (tpl_X43, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_X5q
             },
             case tpl_X22
             of wild_X7o
             { (tpl_X7n, tpl_X46, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B4
             },
             $dBits_swt2,
             $dResize_swt7,
             $dKnownNat_swt6,
             case tpl_X22
             of wild_X2a
             { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B8
             },
             $dBits_swt5,
             $dKnownNat_swt4,
             case tpl_X22
             of wild_X2c
             { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bb
             },
             case tpl_X22
             of wild_X2e
             { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bc
             }))
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       (((let {
            $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
            [LclId, Str=DmdType]
            $dBits_swt8 =
              case tup_swta
              of wild_X3v
              { (tpl_X1P, tpl_X1R, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B5
              } } in
          CLaSH.Sized.Fixed.resizeF
            @ frac2_auHg
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size2_auHh
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            ($dBounded_swt9,
             Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
             case tup_swta
             of wild_X1E
             { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_X5n
             },
             case tup_swta
             of wild_X1G
             { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B4
             },
             $dBits_swt8,
             $dResize_swt7,
             $dKnownNat_swt6,
             case tup_swta
             of wild_X1Q
             { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B8
             },
             $dBits_swt5,
             $dKnownNat_swt4,
             case tup_swta
             of wild_X1W
             { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bb
             },
             case tup_swta
             of wild_X1Y
             { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bc
             }))
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId, Arity=3, Str=DmdType]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_avDN of wild_X2h { (tpl_X23, tpl_X25, tpl_B3) ->
    (let {
       tup_swsS
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_auHe
              frac2_auHg
              (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
              size2_auHh
              (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
       [LclId, Str=DmdType]
       tup_swsS =
         case tup_avDN of wild_X1B { (tpl_X1M, tpl_X1O, tpl_B3) ->
         tpl_X1O
         } } in
     let {
       $dKnownNat_swsM
         :: GHC.TypeLits.KnownNat
              (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
       [LclId, Str=DmdType]
       $dKnownNat_swsM =
         case tup_swsS
         of wild_X1V
         { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_Ba
         } } in
     let {
       $dBits_swsN
         :: Data.Bits.Bits
              (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
       [LclId, Str=DmdType]
       $dBits_swsN =
         case tup_swsS
         of wild_X1T
         { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B9
         } } in
     let {
       $dKnownNat_swsO
         :: GHC.TypeLits.KnownNat
              (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
       [LclId, Str=DmdType]
       $dKnownNat_swsO =
         case tup_swsS
         of wild_X1P
         { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         } } in
     let {
       $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
       [LclId, Str=DmdType]
       $dResize_swsP =
         case tup_swsS
         of wild_X1N
         { (tpl_X1S, tpl_X1U, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B6
         } } in
     let {
       $dBounded_swsR
         :: GHC.Enum.Bounded
              (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1))
       [LclId, Str=DmdType]
       $dBounded_swsR =
         case tup_swsS
         of wild_X1D
         { (tpl_X1O, tpl_X1Q, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_X1O
         } } in
     GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (((let {
            $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
            [LclId, Str=DmdType]
            $dBits_swsK =
              case tpl_X23
              of wild_X27
              { (tpl_X22, tpl_X24, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B5
              } } in
          CLaSH.Sized.Fixed.resizeF
            @ frac1_auHd
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size1_auHf
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            ($dBounded_swsR,
             Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
             case tpl_X23
             of wild_X7o
             { (tpl_X45, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_X5r
             },
             case tpl_X23
             of wild_X7q
             { (tpl_X7p, tpl_X48, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B4
             },
             $dBits_swsK,
             $dResize_swsP,
             $dKnownNat_swsO,
             case tpl_X23
             of wild_X2b
             { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B8
             },
             $dBits_swsN,
             $dKnownNat_swsM,
             case tpl_X23
             of wild_X2d
             { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bb
             },
             case tpl_X23
             of wild_X2f
             { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bc
             }))
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       (((let {
            $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
            [LclId, Str=DmdType]
            $dBits_swsQ =
              case tup_swsS
              of wild_X3x
              { (tpl_X1Q, tpl_X1S, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
              tpl_B5
              } } in
          CLaSH.Sized.Fixed.resizeF
            @ frac2_auHg
            @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
            @ rep_auHe
            @ size2_auHh
            @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
            ($dBounded_swsR,
             Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
             case tup_swsS
             of wild_X1F
             { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_X5o
             },
             case tup_swsS
             of wild_X1H
             { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B4
             },
             $dBits_swsQ,
             $dResize_swsP,
             $dKnownNat_swsO,
             case tup_swsS
             of wild_X1R
             { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_B8
             },
             $dBits_swsN,
             $dKnownNat_swsM,
             case tup_swsS
             of wild_X1X
             { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bb
             },
             case tup_swsS
             of wild_X1Z
             { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
             tpl_Bc
             }))
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=2, Str=DmdType]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    case tup_avBm
    of wild_X1B { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    case tpl_X1N
    of wild_X1F
    { (tpl_X1M, tpl_X1O, tpl_X3i, tpl_X3k, tpl_X3m, tpl_X3o, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       tpl_B9
       (GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl_B3 eta_X1I)
       (case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId, Arity=2, Str=DmdType]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_avBm
    of wild_X1C { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl_B3
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=2, Str=DmdType]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    (let {
       tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
       [LclId, Str=DmdType]
       tup_swsw =
         case tup_XvDa
         of wild_X3E { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1X
         } } in
     let {
       $dKnownNat_swsv
         :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
       [LclId, Str=DmdType]
       $dKnownNat_swsv =
         case tup_swsw
         of wild_X1X
         { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
         tpl_B8
         } } in
     let {
       tup_swsy
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIL
              (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
              frac_XuIJ
              (size_XuIN GHC.TypeLits.+ size_XuIN)
              size_XuIN
       [LclId, Str=DmdType]
       tup_swsy =
         case tup_XvDa
         of wild_X1D { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1V
         } } in
     let {
       $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
       [LclId, Str=DmdType]
       $dKnownNat_swsx =
         case tup_swsy
         of wild_X1H
         { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         } } in
     CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of wild_X1L
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of wild_X1N
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of wild_X1P
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of wild_X1R
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of wild_X1T
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of wild_X1V
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of wild_X1F
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of wild_X1Z
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDa
        of wild_X23 { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsy
           of wild_X21
           { (tpl_X7i, tpl_X7l, tpl_X5n, tpl_X5p, tpl_X5r, tpl_X5t, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5t
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                    :: CLaSH.Class.Num.Resize rep_XuIL
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=2, Str=DmdType]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    (let {
       tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
       [LclId, Str=DmdType]
       tup_swso =
         case tup_XvDb
         of wild_X1K { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1Y
         } } in
     let {
       $dKnownNat_swsn
         :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
       [LclId, Str=DmdType]
       $dKnownNat_swsn =
         case tup_swso
         of wild_X1Y
         { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
         tpl_B8
         } } in
     let {
       tup_swsq
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIM
              (frac_XuIK GHC.TypeLits.+ frac_XuIK)
              frac_XuIK
              (size_XuIO GHC.TypeLits.+ size_XuIO)
              size_XuIO
       [LclId, Str=DmdType]
       tup_swsq =
         case tup_XvDb
         of wild_X1E { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1W
         } } in
     let {
       $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
       [LclId, Str=DmdType]
       $dKnownNat_swsp =
         case tup_swsq
         of wild_X1I
         { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         } } in
     CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of wild_X1M
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of wild_X1O
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of wild_X1Q
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of wild_X1S
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of wild_X1U
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of wild_X1W
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of wild_X1G
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of wild_X20
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDb
        of wild_X24 { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsq
           of wild_X22
           { (tpl_X7k, tpl_X7n, tpl_X5o, tpl_X5q, tpl_X5s, tpl_X5u, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5u
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                    :: CLaSH.Class.Num.Resize rep_XuIM
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=3, Str=DmdType]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    (let {
       tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
       [LclId, Str=DmdType]
       tup_swsf =
         case tup_XvDc
         of wild_X1N { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X22
         } } in
     let {
       $dKnownNat_swse
         :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
       [LclId, Str=DmdType]
       $dKnownNat_swse =
         case tup_swsf
         of wild_X21
         { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
         tpl_B8
         } } in
     let {
       tup_swsi
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIN
              (frac_XuIL GHC.TypeLits.+ frac_XuIL)
              frac_XuIL
              (size_XuIP GHC.TypeLits.+ size_XuIP)
              size_XuIP
       [LclId, Str=DmdType]
       tup_swsi =
         case tup_XvDc
         of wild_X1F { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1Y
         } } in
     let {
       $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
       [LclId, Str=DmdType]
       $dKnownNat_swsg =
         case tup_swsi
         of wild_X1L
         { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         } } in
     CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of wild_X1P
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of wild_X1R
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of wild_X3W
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of wild_X1V
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of wild_X1X
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of wild_X1Z
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of wild_X1H
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of wild_X23
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDc
        of wild_X25 { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsi
           of wild_X3F
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
          (case tup_swsi
           of wild_X3F
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=3, Str=DmdType]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    (let {
       tup_sws8
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIO
              (frac_XuIM GHC.TypeLits.+ frac_XuIM)
              frac_XuIM
              (size_XuIQ GHC.TypeLits.+ size_XuIQ)
              size_XuIQ
       [LclId, Str=DmdType]
       tup_sws8 =
         case tup_XvDd
         of wild_X1G { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X1Z
         } } in
     let {
       $dBits_sws7
         :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       [LclId, Str=DmdType]
       $dBits_sws7 =
         case tup_sws8
         of wild_X1O
         { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B5
         } } in
     CLaSH.Sized.Fixed.resizeF
       @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
       @ frac_XuIM
       @ rep_XuIO
       @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
       @ size_XuIQ
       (case tup_sws8
        of wild_X1I
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        Data.Bits.$p1Bits
          @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
        case tup_sws8
        of wild_X1K
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B3
        },
        case tup_sws8
        of wild_X1M
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B4
        },
        $dBits_sws7,
        case tup_sws8
        of wild_X1S
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        },
        case tup_sws8
        of wild_X3S
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        },
        case tup_sws8
        of wild_X1W
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        },
        case tup_sws8
        of wild_X1Y
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        },
        case tup_sws8
        of wild_X20
        { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        },
        case tup_sws8
        of wild_X22
        { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Bb
        },
        case tup_sws8
        of wild_X24
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Bc
        }))
      (case tup_XvDd
       of wild_X26 { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       case tpl_B6 of cobox_XvCT { GHC.Types.Eq# cobox_dw1a ->
       ((tpl_B5
         `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                   <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                 :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                      ~#
                    (rep_XuIO size_XuIQ
                     -> rep_XuIO size_XuIQ
                     -> CLaSH.Class.Num.MResult
                          (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
          (eta_X1U
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ))
          (eta_X3N
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ)))
       `cast` (Sub cobox_dw1a
               ; Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                            GHC.TypeLits.+ size_XuIQ>_N
               :: CLaSH.Class.Num.MResult
                    (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       }
       })

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId, Arity=3, Str=DmdType]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    (let {
       tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
       [LclId, Str=DmdType]
       tup_sws1 =
         case tup_XvDe
         of wild_X1P { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X24
         } } in
     let {
       $dKnownNat_sws0
         :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
       [LclId, Str=DmdType]
       $dKnownNat_sws0 =
         case tup_sws1
         of wild_X23
         { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
         tpl_B8
         } } in
     let {
       tup_sws4
         :: CLaSH.Sized.Fixed.ResizeFC
              rep_XuIP
              (frac_XuIN GHC.TypeLits.+ frac_XuIN)
              frac_XuIN
              (size_XuIR GHC.TypeLits.+ size_XuIR)
              size_XuIR
       [LclId, Str=DmdType]
       tup_sws4 =
         case tup_XvDe
         of wild_X1H { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
         tpl_X20
         } } in
     let {
       $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
       [LclId, Str=DmdType]
       $dKnownNat_sws2 =
         case tup_sws4
         of wild_X1N
         { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
         tpl_B7
         } } in
     CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of wild_X1R
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of wild_X1T
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of wild_X40
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of wild_X1X
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of wild_X1Z
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of wild_X21
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of wild_X3O
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of wild_X25
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDe
        of wild_X27 { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_sws4
           of wild_X1L
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
          (case tup_sws4
           of wild_X1L
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     (a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
                     `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                             -> Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                             :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> rep_XuIQ size_XuIS)
                                  ~#
                                (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS))
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ((a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
       `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
               :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> rep_XuIQ size_XuIS)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)))
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         (\ ($dKnownNat_avB0
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (ds_dw0H
                                               :: CLaSH.Sized.Fixed.Fixed
                                                    frac_XuIN rep_XuIP size_XuIR) ->
                                            CLaSH.Class.BitVector.toBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avB0
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (ds_dw0H
                                               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                                                       :: CLaSH.Sized.Fixed.Fixed
                                                            frac_XuIN rep_XuIP size_XuIR
                                                            ~#
                                                          rep_XuIP size_XuIR)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR>_R
                                                 -> (CLaSH.Sized.Vector.Vec
                                                       (Sym
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))
                                                       <CLaSH.Bit.Bit>_R)_R
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (CLaSH.Sized.Fixed.Fixed
                                                                frac_XuIN rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit))
                                         (\ ($dKnownNat_avBa
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (bv_auGX
                                               :: CLaSH.Sized.Vector.Vec
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))
                                                    CLaSH.Bit.Bit) ->
                                            CLaSH.Class.BitVector.fromBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avBa
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (bv_auGX
                                               `cast` ((CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N)
                                                          <CLaSH.Bit.Bit>_R)_R
                                                       :: CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit
                                                            ~#
                                                          CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit>_R
                                                 -> Sym
                                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> rep_XuIP size_XuIR)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    let {
      lvl_sxay
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
           -> rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      lvl_sxay =
        CLaSH.Class.BitVector.fromBV
          @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
    (let {
       lvl_sxax
         :: GHC.TypeLits.KnownNat
              (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
            rep_XuIP size_XuIR
            -> CLaSH.Sized.Vector.Vec
                 (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
       [LclId, Str=DmdType]
       lvl_sxax =
         CLaSH.Class.BitVector.toBV
           @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
     CLaSH.Class.BitVector.D:BitVector
       @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
       ((\ ($dKnownNat_avB0
              :: GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
           (ds_dw0H
              :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
           lvl_sxax
             ($dKnownNat_avB0
              `cast` ((GHC.TypeLits.KnownNat
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                      :: GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize
                              (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                           ~#
                         GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
             (ds_dw0H
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))
        `cast` (<GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
                -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
                -> (CLaSH.Sized.Vector.Vec
                      (Sym
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                      <CLaSH.Bit.Bit>_R)_R
                :: (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                    -> CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                     ~#
                   (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                    -> CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize
                            (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                         CLaSH.Bit.Bit))))
      ((\ ($dKnownNat_avBa
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (bv_auGX
             :: CLaSH.Sized.Vector.Vec
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                  CLaSH.Bit.Bit) ->
          lvl_sxay
            ($dKnownNat_avBa
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (bv_auGX
             `cast` ((CLaSH.Sized.Vector.Vec
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                        <CLaSH.Bit.Bit>_R)_R
                     :: CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> rep_XuIP size_XuIR)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))

a_swC4
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[LclId, Arity=1, Str=DmdType]
a_swC4 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId, Arity=1, Str=DmdType]
$cdef_avAg =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
                          (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ((GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
      ((GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Ordering>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Ordering))
                         (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
                         (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ((GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Ordering>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Ordering)))
      ((GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
      ((GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))
                        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ((GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
      ((GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))

a_swC6 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swC6 = a_swwS

a_swC9 :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swC9 = a_swwV

a_swCb :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swCb = a_swwX

a_swC7 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId, Str=DmdType]
a_swC7 = a_swwT

lvl_swwh :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swwh = lvl_swvo

a_swCe :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swCe = a_swwS

a_swCh :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swCh = a_swwV

a_swCj :: [GHC.Types.Char]
[LclId, Str=DmdType]
a_swCj = a_swwX

a_swCf :: Language.Haskell.TH.Syntax.NameFlavour
[LclId, Str=DmdType]
a_swCf =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwp :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_swwp =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swCf

lvl_sxaz :: Language.Haskell.TH.Syntax.Type
[LclId, Str=DmdType]
lvl_sxaz = Language.Haskell.TH.Syntax.ConT lvl_swwp

a_swCk
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[LclId, Arity=1, Str=DmdType]
a_swCk =
  \ (@ (m_a4Ni :: * -> *))
    (eta_a4Nj :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    GHC.Base.return
      @ m_a4Ni
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_a4Nj)
      @ Language.Haskell.TH.Syntax.Type
      lvl_sxaz

Rec {
lgo_sxaB [Occ=LoopBreaker]
  :: Language.Haskell.TH.Lib.TypeQ
     -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
[LclId, Arity=2, Str=DmdType <L,U><S,1*U>]
lgo_sxaB =
  \ (z_awhM :: Language.Haskell.TH.Lib.TypeQ)
    (ds_awhN :: [Language.Haskell.TH.Lib.TypeQ]) ->
    case ds_awhN of wild_awhO {
      [] -> z_awhM;
      : x_awhS xs_awhT ->
        lgo_sxaB
          ((Language.Haskell.TH.Lib.appT1 z_awhM x_awhS)
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          xs_awhT
    }
end Rec }

lvl_sxaC :: Language.Haskell.TH.Syntax.Name
[LclId, Str=DmdType]
lvl_sxaC =
  Language.Haskell.TH.Syntax.Name
    ((GHC.Types.[] @ GHC.Types.Char)
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    Language.Haskell.TH.Syntax.NameS

lvl_sxaE :: Language.Haskell.TH.Syntax.Exp
[LclId, Str=DmdType]
lvl_sxaE = lvl_sxal

a_swCv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[LclId, Arity=5, Str=DmdType]
a_swCv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    let {
      w1_akV2 :: Language.Haskell.TH.Lib.TypeQ
      [LclId, Str=DmdType]
      w1_akV2 =
        lgo_sxaB
          (a_swCk
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          (GHC.Types.:
             @ Language.Haskell.TH.Lib.TypeQ
             ((let {
                 l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                 [LclId, Str=DmdType]
                 l_a5DZ =
                   Language.Haskell.TH.Lib.numTyLit
                     ($dKnownNat_avAr
                      `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                              ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                              :: GHC.TypeLits.KnownNat frac_auGO
                                   ~#
                                 GHC.Integer.Type.Integer)) } in
               \ (@ (m_a5E0 :: * -> *))
                 (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                 GHC.Base.fmap
                   @ m_a5E0
                   (Control.Applicative.$p1Applicative
                      @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                   @ Language.Haskell.TH.Syntax.TyLit
                   @ Language.Haskell.TH.Syntax.Type
                   Language.Haskell.TH.Syntax.LitT
                   ((l_a5DZ
                     `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <Language.Haskell.TH.Syntax.TyLit>_N
                             :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                  ~#
                                (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                      @ m_a5E0 eta_a5E1))
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <Language.Haskell.TH.Syntax.Type>_N)
                      :: (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Type)
                           ~#
                         Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
             (GHC.Types.:
                @ Language.Haskell.TH.Lib.TypeQ
                ((let {
                    x_X4Ts :: Language.Haskell.TH.Syntax.Name
                    [LclId, Str=DmdType]
                    x_X4Ts =
                      case ($dTypeable_avAt
                            `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                                      <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                                    :: Data.Typeable.Internal.Typeable rep_auGP
                                         ~#
                                       (GHC.Prim.Proxy# rep_auGP
                                        -> Data.Typeable.Internal.TypeRep)))
                             (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP)
                      of ww_awCo
                      { Data.Typeable.Internal.TypeRep ww1_awCq ww2_awCr ww3_awCs
                                                       ww4_awCt ->
                      case GHC.List.reverse1
                             @ GHC.Types.Char
                             (Data.Typeable.Internal.$w$cshowsPrec
                                GHC.Show.shows27 ww3_awCs ww4_awCt (GHC.Types.[] @ GHC.Types.Char))
                             (GHC.Types.[] @ GHC.Types.Char)
                      of wild21_a5F6 {
                        [] -> lvl_sxaC;
                        : ds_a5Fa rev_a5Fb ->
                          case ds_a5Fa of wild22_a5Fd { GHC.Types.C# ds1_a5Ff ->
                          case ds1_a5Ff of ds2_a5Fh {
                            __DEFAULT ->
                              case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                     ds_a5Fa (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                              of ww_a5Au { (# ww1_a5Aw, ww2_a5Ax #) ->
                              Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                              };
                            '.' ->
                              case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                     ds_a5Fa (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                              of ww_a5Au { (# ww1_a5Aw, ww2_a5Ax #) ->
                              Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                              }
                          }
                          }
                      }
                      } } in
                  let {
                    lvl_sxaD :: Language.Haskell.TH.Syntax.Type
                    [LclId, Str=DmdType]
                    lvl_sxaD = Language.Haskell.TH.Syntax.ConT x_X4Ts } in
                  \ (@ (m_X4Tv :: * -> *))
                    (eta_X4Tx :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
                    GHC.Base.return
                      @ m_X4Tv
                      (Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_X4Tx)
                      @ Language.Haskell.TH.Syntax.Type
                      lvl_sxaD)
                 `cast` (Sym
                           (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.Type>_N)
                         :: (forall (m_a4LE :: * -> *).
                             Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                             m_a4LE Language.Haskell.TH.Syntax.Type)
                              ~#
                            Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                (GHC.Types.:
                   @ Language.Haskell.TH.Lib.TypeQ
                   ((let {
                       l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                       [LclId, Str=DmdType]
                       l_a5DZ =
                         Language.Haskell.TH.Lib.numTyLit
                           ($dKnownNat_avAs
                            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                                    ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                                    :: GHC.TypeLits.KnownNat size_auGQ
                                         ~#
                                       GHC.Integer.Type.Integer)) } in
                     \ (@ (m_a5E0 :: * -> *))
                       (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                       GHC.Base.fmap
                         @ m_a5E0
                         (Control.Applicative.$p1Applicative
                            @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                         @ Language.Haskell.TH.Syntax.TyLit
                         @ Language.Haskell.TH.Syntax.Type
                         Language.Haskell.TH.Syntax.LitT
                         ((l_a5DZ
                           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <Language.Haskell.TH.Syntax.TyLit>_N
                                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                        ~#
                                      (forall (m_a4LE :: * -> *).
                                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                       m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                            @ m_a5E0 eta_a5E1))
                    `cast` (Sym
                              (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                 <Language.Haskell.TH.Syntax.Type>_N)
                            :: (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.Type)
                                 ~#
                               Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)))) } in
    let {
      w1_acZp :: Language.Haskell.TH.Lib.ExpQ
      [LclId, Str=DmdType]
      w1_acZp =
        ($dLift_avAq
         `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                   <rep_auGP size_auGQ>_N
                 :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                      ~#
                    (rep_auGP size_auGQ
                     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
          (f_auGR
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                        ~#
                      rep_auGP size_auGQ)) } in
    \ (@ (m_akV3 :: * -> *))
      (w2_akV4 :: Language.Haskell.TH.Syntax.Quasi m_akV3) ->
      case w2_akV4
      of ww_akV5
      { Language.Haskell.TH.Syntax.D:Quasi ww1_akV7 ww2_akV8 ww3_akV9
                                           ww4_akVa ww5_akVb ww6_akVc ww7_akVd ww8_akVe ww9_akVf
                                           ww10_akVg ww11_akVh ww12_akVi ww13_akVj ww14_akVk
                                           ww15_akVl ww16_akVm ww17_akVn ww18_akVo ->
      case ww1_akV7
      of ww19_akVq
      { GHC.Base.D:Monad ww20_akVt ww21_akVu ww22_akVv ww23_akVw ->
      let {
        a_akVs :: GHC.Base.Monad m_akV3
        [LclId, Str=DmdType]
        a_akVs = ww1_akV7 } in
      let {
        eta_akVy :: Language.Haskell.TH.Syntax.Quasi m_akV3
        [LclId, Str=DmdType]
        eta_akVy = w2_akV4 } in
      let {
        lvl_sxaG :: m_akV3 Language.Haskell.TH.Syntax.Type
        [LclId, Str=DmdType]
        lvl_sxaG =
          (w1_akV2
           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                     <Language.Haskell.TH.Syntax.Type>_N
                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
                        ~#
                      (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)))
            @ m_akV3 w2_akV4 } in
      ww20_akVt
        @ Language.Haskell.TH.Syntax.Exp
        @ Language.Haskell.TH.Syntax.Exp
        (let {
           a_acZP :: GHC.Base.Monad m_akV3
           [LclId, Str=DmdType]
           a_acZP = ww1_akV7 } in
         let {
           eta_acZV :: Language.Haskell.TH.Syntax.Quasi m_akV3
           [LclId, Str=DmdType]
           eta_acZV = w2_akV4 } in
         let {
           lvl_sxaF :: m_akV3 Language.Haskell.TH.Syntax.Exp
           [LclId, Str=DmdType]
           lvl_sxaF =
             (w1_acZp
              `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N
                      :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
                           ~#
                         (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Exp)))
               @ m_akV3 w2_akV4 } in
         ww20_akVt
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_akVv @ Language.Haskell.TH.Syntax.Exp lvl_sxal)
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_akVt
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl_sxaF
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_akVv
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_akVz :: Language.Haskell.TH.Syntax.Exp) ->
           ww20_akVt
             @ Language.Haskell.TH.Syntax.Type
             @ Language.Haskell.TH.Syntax.Exp
             lvl_sxaG
             (\ (x1_akVA :: Language.Haskell.TH.Syntax.Type) ->
                ww22_akVv
                  @ Language.Haskell.TH.Syntax.Exp
                  (Language.Haskell.TH.Syntax.SigE x_akVz x1_akVA)))
      }
      }

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId, Arity=5, Str=DmdType]
$clift_avAv =
  a_swCv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                              (rep_XuMX :: GHC.TypeLits.Nat -> *)
                              (size_XuMZ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
                       -> <GHC.TypeLits.KnownNat frac_XuMV>_R
                       -> <GHC.TypeLits.KnownNat size_XuMZ>_R
                       -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
                       :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  a_swCv
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Simplifier:
SimplBind [lvl_sxai{v} [lid]]
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [lvl_swuK{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [lvl_sxal{v} [lid]]
SimplBind [lvl_sxam{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sxaq{v} [lid]]
SimplBind [lvl_sxau{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [lvl_sxaz{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [lgo{v sxaB} [lid]]
SimplBind [lvl_sxaC{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]
Result size of Simplifier iteration=1
  = {terms: 2,098, types: 9,178, coercions: 947}
SimplBind [lvl_sxai{v} [lid]]
SimplBind [lvl_swvg{v} [lid]]
SimplBind [lvl_swve{v} [lid]]
SimplBind [lvl_swv0{v} [lid]]
SimplBind [lvl_swv4{v} [lid]]
SimplBind [g1{v swuY} [lid]]
SimplBind [f{v swuQ} [lid]]
SimplBind [lvl_swuH{v} [lid]]
SimplBind [$s^{v swu6} [lid]]
SimplBind [lvl_swvh{v} [lid]]
SimplBind [a_swwS{v} [lid]]
SimplBind [a_swwV{v} [lid]]
SimplBind [a_swwX{v} [lid]]
SimplBind [a_swwT{v} [lid]]
SimplBind [lvl_swvo{v} [lid]]
SimplBind [a_swx0{v} [lid]]
SimplBind [a_swx3{v} [lid]]
SimplBind [a_swx5{v} [lid]]
SimplBind [a_swx1{v} [lid]]
SimplBind [lvl_swvw{v} [lid]]
SimplBind [lvl_sxal{v} [lid]]
SimplBind [lvl_sxam{v} [lid]]
SimplBind [a_swxS{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.fLit{v ruEL} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.satN2{v ruEK} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.resizeF{v ruEJ} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asRepProxy{v ruEG} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.asFracProxy{v ruEF} [lidx]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.fracShift{v ruEH} [lidx]]
SimplBind [a_swaI{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unUF{v ruEE} [lidx]]
SimplBind [a_swaJ{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.uf{v ruED} [lidx]]
SimplBind [a_swaK{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.unSF{v ruEC} [lidx]]
SimplBind [a_swaL{v} [lid]]
SimplBind [clash-prelude-0.5:CLaSH.Sized.Fixed.sf{v ruEB} [lidx]]
SimplBind [a_swaM{v} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.unFixed{v ruEA} [lidx[[RecSel]]]]
SimplBind [lvl_swvD{v} [lid]]
SimplBind [lvl_swvG{v} [lid]]
SimplBind [dt{v akMa} [lid]]
SimplBind [lvl_swvV{v} [lid]]
SimplBind [lvl_swvX{v} [lid]]
SimplBind [lvl_sxaq{v} [lid]]
SimplBind [lvl_sxau{v} [lid]]
SimplBind [$cshow{v avFD} [lid]]
SimplBind [$cshowsPrec{v avFB} [lid]]
SimplBind [$cshowList{v avIE} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fShowFixed{v ruTI} [lidx[DFunId]]]
SimplBind [a_swjx{v} [lid]]
SimplBind [$cmult{v avFi} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fMultFixedFixed{v ruTC} [lidx[DFunId(nt)]]]
SimplBind [$cminus{v avEx} [lid]]
SimplBind [$cplus{v avDP} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fAddFixedFixed{v ruSO} [lidx[DFunId]]]
SimplBind [$cfromInteger{v avDp} [lid]]
SimplBind [a_swkh{v} [lid]]
SimplBind [$cabs{v avCW} [lid]]
SimplBind [$cnegate{v avCC} [lid]]
SimplBind [$c-{v avCb} [lid]]
SimplBind [$c*{v avBP} [lid]]
SimplBind [$c+{v avBo} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fNumFixed{v ruPB} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBitVectorFixed{v ruPx} [lidx[DFunId]]]
SimplBind [a_swC4{v} [lid]]
SimplBind [$cdef{v avAg} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fDefaultFixed{v ruO2} [lidx[DFunId(nt)]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fBoundedFixed{v ruHR} [lidx[DFunId]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fOrdFixed{v ruUw} [lidx[DFunId[1]]]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fEqFixed{v ruUr} [lidx[DFunId]]]
SimplBind [a_swCf{v} [lid]]
SimplBind [lvl_swwp{v} [lid]]
SimplBind [lvl_sxaz{v} [lid]]
SimplBind [a_swCk{v} [lid]]
SimplBind [lgo{v sxaB} [lid]]
SimplBind [lvl_sxaC{v} [lid]]
SimplBind [a_swCv{v} [lid]]
SimplBind [$clift{v avAv} [lid]]
SimplBind
    [clash-prelude-0.5:CLaSH.Sized.Fixed.$fLiftFixed{v ruOs} [lidx[DFunId(nt)]]]

==================== Simplifier ====================
  Max iterations = 4
  SimplMode {Phase = 0 [final],
             inline,
             rules,
             eta-expand,
             case-of-case}
Result size of Simplifier
  = {terms: 2,096, types: 9,177, coercions: 947}

lvl_sxai :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
lvl_sxai = GHC.CString.unpackCString# "Negative exponent"#

lvl_swvg :: GHC.Types.Double
[LclId, Str=DmdType b]
lvl_swvg = GHC.Err.error @ GHC.Types.Double lvl_sxai

lvl_swve :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swve = GHC.Types.D# 1.0

lvl_swv0 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv0 = __integer 1

lvl_swv4 :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swv4 = __integer 2

Rec {
g1_swuY [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 442 0}]
g1_swuY =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP :: GHC.Types.Double) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y1_akDO GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y1_akDO lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x1_akDN x1_akDN)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y1_akDO lvl_swv0) lvl_swv4)
              (GHC.Float.timesDouble x1_akDN z_akDP);
          GHC.Types.True -> GHC.Float.timesDouble x1_akDN z_akDP
        }
        };
      GHC.Types.True ->
        g1_swuY
          (GHC.Float.timesDouble x1_akDN x1_akDN)
          (GHC.Integer.Type.quotInteger y1_akDO lvl_swv4)
          z_akDP
    }
    }
end Rec }

Rec {
f_swuQ [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 372 0}]
f_swuQ =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y_akDB GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# y_akDB lvl_swv0
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            g1_swuY
              (GHC.Float.timesDouble x_akDA x_akDA)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger y_akDB lvl_swv0) lvl_swv4)
              x_akDA;
          GHC.Types.True -> x_akDA
        }
        };
      GHC.Types.True ->
        f_swuQ
          (GHC.Float.timesDouble x_akDA x_akDA)
          (GHC.Integer.Type.quotInteger y_akDB lvl_swv4)
    }
    }
end Rec }

lvl_swuH :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
lvl_swuH = __integer 0

$s^_swu6 [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 152 0}]
$s^_swu6 =
  \ (eta_akDk :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger# eta1_akDl lvl_swuH
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger# eta1_akDl lvl_swuH
        of wild_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False -> f_swuQ eta_akDk eta1_akDl;
          GHC.Types.True -> lvl_swve
        }
        };
      GHC.Types.True -> lvl_swvg
    }
    }

lvl_swvh :: GHC.Types.Double
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvh = GHC.Types.D# 2.0

a_swwS :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swwS = GHC.CString.unpackCString# "Fixed"#

a_swwV :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swwV = GHC.CString.unpackCString# "clash-prelude-0.5"#

a_swwX :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
a_swwX = GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

a_swwT :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swwT =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvo :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvo =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swwT

a_swx0 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 60 0}]
a_swx0 = GHC.CString.unpackCString# "fromInteger"#

a_swx3 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 40 0}]
a_swx3 = GHC.CString.unpackCString# "base"#

a_swx5 :: [GHC.Types.Char]
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
a_swx5 = GHC.CString.unpackCString# "GHC.Num"#

a_swx1 :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swx1 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (a_swx3
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swx5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swvw :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swvw =
  Language.Haskell.TH.Syntax.Name
    (a_swx0
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swx1

lvl_sxal :: Language.Haskell.TH.Syntax.Exp
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_sxal = Language.Haskell.TH.Syntax.ConE lvl_swvo

lvl_sxam :: Language.Haskell.TH.Syntax.Exp
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_sxam = Language.Haskell.TH.Syntax.VarE lvl_swvw

a_swxS
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
a_swxS =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      x_akVD :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 592 0}]
      x_akVD =
        let {
          truncated_swu2 :: GHC.Integer.Type.Integer
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 340 0}]
          truncated_swu2 =
            case a_auGC of _ [Occ=Dead] { GHC.Types.D# x_aw80 ->
            case $s^_swu6
                   lvl_swvh
                   ($dKnownNat_avlM
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                            :: GHC.TypeLits.KnownNat frac_avhM ~# GHC.Integer.Type.Integer))
            of _ [Occ=Dead] { GHC.Types.D# y_aw84 ->
            case GHC.Integer.Type.decodeDoubleInteger
                   (GHC.Prim.*## x_aw80 y_aw84)
            of _ [Occ=Dead] { (# ipv_aw8Q, ipv1_aw8R #) ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ipv1_aw8R 0)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Integer.Type.shiftLInteger ipv_aw8Q ipv1_aw8R;
              GHC.Types.True ->
                let {
                  s_aw8X :: GHC.Prim.Int#
                  [LclId,
                   Str=DmdType,
                   Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                           ConLike=False, WorkFree=False, Expandable=True,
                           Guidance=IF_ARGS [] 1 0}]
                  s_aw8X = GHC.Prim.negateInt# ipv1_aw8R } in
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># s_aw8X 52)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger# ipv_aw8Q lvl_swuH
                    of wild3_aw92 { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild3_aw92
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        case GHC.Integer.Type.integerToInt ipv_aw8Q
                        of n_aw96 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.uncheckedIShiftRA# n_aw96 s_aw8X)
                        };
                      GHC.Types.True ->
                        case GHC.Integer.Type.integerToInt
                               (GHC.Integer.Type.negateInteger ipv_aw8Q)
                        of n_aw99 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.negateInt# (GHC.Prim.uncheckedIShiftRA# n_aw99 s_aw8X))
                        }
                    }
                    };
                  GHC.Types.True -> lvl_swuH
                }
            }
            }
            }
            } } in
        let {
          rMax_swu0 :: GHC.Integer.Type.Integer
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 50 0}]
          rMax_swu0 =
            GHC.Real.toInteger
              @ (rep_avhN size_avhO)
              $dIntegral_avlP
              (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
        case GHC.Integer.Type.gtInteger# truncated_swu2 rMax_swu0
        of wild_akJ6 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ6
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              rMin_swu1 :: GHC.Integer.Type.Integer
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 50 0}]
              rMin_swu1 =
                GHC.Real.toInteger
                  @ (rep_avhN size_avhO)
                  $dIntegral_avlP
                  (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
            case GHC.Integer.Type.ltInteger# truncated_swu2 rMin_swu1
            of wild_a4It { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
            of _ [Occ=Dead] {
              GHC.Types.False -> truncated_swu2;
              GHC.Types.True -> rMin_swu1
            }
            };
          GHC.Types.True -> rMax_swu0
        }
        } } in
    let {
      a_sxb9 :: Language.Haskell.TH.Syntax.Lit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=True,
               ConLike=True, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 20}]
      a_sxb9 = Language.Haskell.TH.Syntax.IntegerL x_akVD } in
    let {
      lvl_sxan :: Language.Haskell.TH.Syntax.Exp
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=True,
               ConLike=True, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 20}]
      lvl_sxan = Language.Haskell.TH.Syntax.LitE a_sxb9 } in
    \ (@ (m_awx9 :: * -> *))
      (w1_awxa :: Language.Haskell.TH.Syntax.Quasi m_awx9) ->
      case w1_awxa
      of _ [Occ=Dead]
      { Language.Haskell.TH.Syntax.D:Quasi ww1_awxd ww2_awxe ww3_awxf
                                           ww4_awxg ww5_awxh ww6_awxi ww7_awxj ww8_awxk ww9_awxl
                                           ww10_awxm ww11_awxn ww12_awxo ww13_awxp ww14_awxq
                                           ww15_awxr ww16_awxs ww17_awxt ww18_awxu ->
      case ww1_awxd
      of _ [Occ=Dead]
      { GHC.Base.D:Monad ww20_awxy ww21_awxz ww22_awxA ww23_awxB ->
      ww20_awxy
        @ Language.Haskell.TH.Syntax.Exp
        @ (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
        (let {
           lvl_sxap :: m_awx9 Language.Haskell.TH.Syntax.Exp
           [LclId,
            Str=DmdType,
            Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                    ConLike=False, WorkFree=False, Expandable=False,
                    Guidance=IF_ARGS [] 160 0}]
           lvl_sxap =
             let {
               lvl_sxao :: m_awx9 Language.Haskell.TH.Syntax.Exp
               [LclId,
                Str=DmdType,
                Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                        ConLike=False, WorkFree=False, Expandable=False,
                        Guidance=IF_ARGS [] 20 0}]
               lvl_sxao = ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxan } in
             ww20_awxy
               @ Language.Haskell.TH.Syntax.Exp
               @ Language.Haskell.TH.Syntax.Exp
               (ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxam)
               (\ (x_Xd36 :: Language.Haskell.TH.Syntax.Exp) ->
                  ww20_awxy
                    @ Language.Haskell.TH.Syntax.Exp
                    @ Language.Haskell.TH.Syntax.Exp
                    lvl_sxao
                    (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                       ww22_awxA
                         @ Language.Haskell.TH.Syntax.Exp
                         (Language.Haskell.TH.Syntax.AppE x_Xd36 x1_acZX))) } in
         ww20_awxy
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl_sxal)
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_awxy
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl_sxap
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_awxA
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_awxD :: Language.Haskell.TH.Syntax.Exp) ->
           ww22_awxA
             @ (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
             (x_awxD
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:TExp[0]
                           <CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO>_N)
                      :: Language.Haskell.TH.Syntax.Exp
                           ~#
                         Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))
      }
      }

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.fLit =
  a_swxS
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    case tup_avmQ
    of _ [Occ=Dead]
    { (tpl_X1t, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 50 0}]
      repBV_swtT =
        case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl_B4
           (tpl_B8
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_B1)
        `cast` ((CLaSH.Sized.Vector.Vec cobox_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 50 0}]
      s_swtS =
        case tpl_B2 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7d ->
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (repBV_swtT
              `cast` ((CLaSH.Sized.Vector.Vec
                         (Sym cobox_dw7d) <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
        } } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl_Ba eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case tpl_B2 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case tpl_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case tpl_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case tpl_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7b ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case tpl_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        };
      GHC.Types.True ->
        case tpl_B2 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case tpl_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case tpl_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl_B9
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl_B3
                  (case tpl_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw79 ->
                   tpl_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case tpl_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        }
    }
    }

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swtI =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B8
        } } in
    let {
      $dKnownNat_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swtH =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_swtI
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat_swtH
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_akJ3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ3
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFQ { __DEFAULT ->
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 20 0}]
          fMax_swtA = GHC.Enum.maxBound @ (rep_avjs size2_avju) tpl_X1y } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=False,
                   Guidance=IF_ARGS [] 33 0}]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              tpl_B5
              ((tpl_B6
                `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                        :: CLaSH.Class.Num.Resize rep_avjs
                             ~#
                           (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                            (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                            rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                 @ size2_avju
                 @ size1_avjt
                 $dKnownNat_swtH
                 $dKnownNat_swtI
                 fMax_swtA) } in
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFQ)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 51 0}]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  tpl_B5
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFQ)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) tpl_B4 lvl_swuH)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl_B5)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) tpl_B5 shiftedR_swty mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) tpl_X1y)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl_B5)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) tpl_B5 shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) tpl_B4 lvl_swuH)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 51 0}]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  tpl_B5
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild_XkFQ wild_akCB)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger @ (rep_avjs size1_avjt) tpl_B4 lvl_swuH)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl_B5)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) tpl_B5 shiftedL_swtK mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) tpl_X1y)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl_B5)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) tpl_B5 shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger @ (rep_avjs size1_avjt) tpl_B4 lvl_swuH)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl_B2, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild_XkFG { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild_akCB wild_XkFG)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_akCB wild_XkFG)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               tpl_B9
               ((tpl_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild_XkFG wild_akCB)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 40 20}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_avxa
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_akCB { __DEFAULT ->
    GHC.Types.I# wild_akCB
    }

a_swaI
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaI =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  a_swaI
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

a_swaJ
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaJ =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  a_swaJ
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

a_swaK
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaK =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[LclIdX,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  a_swaK
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

a_swaL
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaL =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  a_swaL
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

a_swaM
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swaM =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[LclIdX[[RecSel]],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  a_swaM
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

lvl_swvD :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvD = GHC.Types.C# '-'

lvl_swvG :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvG = GHC.Types.C# '0'

dt_akMa :: GHC.Integer.Type.Integer
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
dt_akMa = __integer 10

lvl_swvV
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40] 191 30}]
lvl_swvV =
  \ (ds_awe3
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    (case ds_awe3 of _ [Occ=Dead] { (x_awe6, y_awe7) ->
     case x_awe6 of _ [Occ=Dead] { GHC.Types.I# x1_awdC ->
     case x1_awdC of wild1_awdE {
       __DEFAULT -> GHC.Types.I# (GHC.Prim.+# wild1_awdE 1);
       9223372036854775807 -> GHC.Enum.$fEnumInt2
     }
     }
     },
     case ds_awe3 of _ [Occ=Dead] { (x_aweb, y_awec) ->
     case y_awec of _ [Occ=Dead] { GHC.Real.:% ww1_awdJ ww2_awdK ->
     case GHC.Real.$w$sreduce
            (GHC.Integer.Type.timesInteger ww1_awdJ dt_akMa)
            (GHC.Integer.Type.timesInteger ww2_awdK GHC.Real.$fEnumRatio1)
     of _ [Occ=Dead] { (# ww7_awdU, ww8_awdV #) ->
     GHC.Real.:% @ GHC.Integer.Type.Integer ww7_awdU ww8_awdV
     }
     }
     })

lvl_swvX :: GHC.Types.Int
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_swvX = GHC.Types.I# 0

lvl_sxaq
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 91 30}]
lvl_sxaq =
  \ (x_awzz
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    (r_awzA [OS=OneShot]
       :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]) ->
    case x_awzz of wild_afnB { (ds1_afnD, y_afnE) ->
    case y_afnE of _ [Occ=Dead] { GHC.Real.:% ds1_awdp y_awdq ->
    case GHC.Integer.Type.eqInteger# y_awdq lvl_swv0
    of wild_a2f3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a2f3
    of _ [Occ=Dead] {
      GHC.Types.False -> r_awzA;
      GHC.Types.True ->
        GHC.Types.:
          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          wild_afnB
          r_awzA
    }
    }
    }
    }

lvl_sxau :: GHC.Types.Char
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_sxau = GHC.Types.C# '.'

$cshow_avFD
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
$cshow_avFD =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 30 0}]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swuH
    of wild_a4It { __DEFAULT ->
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 20 0}]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      nF_swti :: GHC.Types.Int
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 40 20}]
      nF_swti =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_avFx
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        } } in
    let {
      a_swOO :: [GHC.Types.Char]
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False, Guidance=NEVER}]
      a_swOO =
        case GHC.List.iterateFB
               @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
               @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
               lvl_sxaq
               lvl_swvV
               (lvl_swvX,
                case GHC.Integer.Type.ltInteger# fRepI_swtk lvl_swuH
                of wild_X4KP { __DEFAULT ->
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_X4KP
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_awO9 ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        let {
                          a_swOs :: GHC.Integer.Type.Integer
                          [LclId,
                           Str=DmdType,
                           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                   ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 50 0}]
                          a_swOs =
                            case x_awO9 of wild2_awOe {
                              __DEFAULT -> GHC.Real.$wf1 lvl_swv4 wild2_awOe;
                              0 -> GHC.Real.$fEnumRatio1
                            } } in
                        case x_awO9 of wild2_awOe {
                          __DEFAULT ->
                            case GHC.Real.$w$sreduce
                                   (GHC.Integer.Type.timesInteger
                                      (GHC.Integer.Type.andInteger
                                         fRepI_swtk
                                         (GHC.Integer.Type.minusInteger
                                            (GHC.Real.$wf1 lvl_swv4 wild2_awOe) lvl_swv0))
                                      (GHC.Integer.Type.signumInteger a_swOs))
                                   (GHC.Integer.Type.absInteger a_swOs)
                            of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                            GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                            };
                          0 ->
                            case GHC.Real.$w$sreduce
                                   (GHC.Integer.Type.timesInteger
                                      (GHC.Integer.Type.andInteger fRepI_swtk lvl_swuH)
                                      (GHC.Integer.Type.signumInteger a_swOs))
                                   (GHC.Integer.Type.absInteger a_swOs)
                            of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                            GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                            }
                        };
                      GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                    }
                    };
                  GHC.Types.True ->
                    case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_awO9 ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        let {
                          a_swOy :: GHC.Integer.Type.Integer
                          [LclId,
                           Str=DmdType,
                           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                                   ConLike=False, WorkFree=False, Expandable=False,
                                   Guidance=IF_ARGS [] 50 0}]
                          a_swOy =
                            case x_awO9 of wild2_awOe {
                              __DEFAULT -> GHC.Real.$wf1 lvl_swv4 wild2_awOe;
                              0 -> GHC.Real.$fEnumRatio1
                            } } in
                        case x_awO9 of wild2_awOe {
                          __DEFAULT ->
                            case GHC.Real.$w$sreduce
                                   (GHC.Integer.Type.timesInteger
                                      (GHC.Integer.Type.andInteger
                                         fRepI_abs_swtj
                                         (GHC.Integer.Type.minusInteger
                                            (GHC.Real.$wf1 lvl_swv4 wild2_awOe) lvl_swv0))
                                      (GHC.Integer.Type.signumInteger a_swOy))
                                   (GHC.Integer.Type.absInteger a_swOy)
                            of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                            GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                            };
                          0 ->
                            case GHC.Real.$w$sreduce
                                   (GHC.Integer.Type.timesInteger
                                      (GHC.Integer.Type.andInteger fRepI_abs_swtj lvl_swuH)
                                      (GHC.Integer.Type.signumInteger a_swOy))
                                   (GHC.Integer.Type.absInteger a_swOy)
                            of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                            GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                            }
                        };
                      GHC.Types.True -> case GHC.Real.^3 of wild_00 { }
                    }
                    }
                }
                })
        of _ [Occ=Dead] {
          [] -> case Data.Maybe.fromJust1 of wild_00 { };
          : a1_awdh ds1_awdi ->
            case a1_awdh of _ [Occ=Dead] { (x_awcU, y_awcV) ->
            case x_awcU of _ [Occ=Dead] { GHC.Types.I# x_akIV ->
            let {
              str_auHK [OS=ProbOneShot] :: [GHC.Types.Char]
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=False,
                       Guidance=IF_ARGS [] 70 30}]
              str_auHK =
                case y_awcV of _ [Occ=Dead] { GHC.Real.:% x_awcK ds1_awcL ->
                case GHC.Show.$w$cshowsPrec
                       0 x_awcK (GHC.Types.[] @ GHC.Types.Char)
                of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                }
                } } in
            case GHC.List.$wlenAcc @ GHC.Types.Char str_auHK 0
            of ww_awOK { __DEFAULT ->
            let {
              n#_awbi :: GHC.Prim.Int#
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                       ConLike=False, WorkFree=False, Expandable=True,
                       Guidance=IF_ARGS [] 1 0}]
              n#_awbi = GHC.Prim.-# x_akIV ww_awOK } in
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# n#_awbi 0)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                let {
                  lvl_sxat :: [GHC.Types.Char]
                  [LclId,
                   Str=DmdType,
                   Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=True,
                           ConLike=True, WorkFree=True, Expandable=True,
                           Guidance=IF_ARGS [] 10 30}]
                  lvl_sxat = GHC.Types.: @ GHC.Types.Char lvl_swvG str_auHK } in
                letrec {
                  xs_awyT [Occ=LoopBreaker] :: GHC.Prim.Int# -> [GHC.Types.Char]
                  [LclId,
                   Arity=1,
                   Str=DmdType,
                   Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=1, Value=True,
                           ConLike=True, WorkFree=True, Expandable=True,
                           Guidance=IF_ARGS [0] 53 30}]
                  xs_awyT =
                    \ (m_awz0 :: GHC.Prim.Int#) ->
                      case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# m_awz0 1)
                      of _ [Occ=Dead] {
                        GHC.Types.False ->
                          GHC.Types.:
                            @ GHC.Types.Char lvl_swvG (xs_awyT (GHC.Prim.-# m_awz0 1));
                        GHC.Types.True -> lvl_sxat
                      }; } in
                xs_awyT n#_awbi;
              GHC.Types.True -> str_auHK
            }
            }
            }
            }
        } } in
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
        let {
          ww_al4F :: GHC.Prim.Int#
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=False, Expandable=True,
                   Guidance=IF_ARGS [] 1 0}]
          ww_al4F = GHC.Prim.negateInt# x_aiKN } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftRInteger
                      fRepI_swtk (GHC.Prim.negateInt# ww_al4F))
                   (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
            };
          GHC.Types.True ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftLInteger fRepI_swtk ww_al4F)
                   (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
            }
        }
        };
      GHC.Types.True ->
        GHC.Base.++
          @ GHC.Types.Char
          (GHC.Types.:
             @ GHC.Types.Char
             lvl_swvD
             (case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
              let {
                ww_al4F :: GHC.Prim.Int#
                [LclId,
                 Str=DmdType,
                 Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                         ConLike=False, WorkFree=False, Expandable=True,
                         Guidance=IF_ARGS [] 1 0}]
                ww_al4F = GHC.Prim.negateInt# x_aiKN } in
              case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
              of _ [Occ=Dead] {
                GHC.Types.False ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftRInteger
                            fRepI_abs_swtj (GHC.Prim.negateInt# ww_al4F))
                         (GHC.Types.[] @ GHC.Types.Char)
                  of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  };
                GHC.Types.True ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftLInteger fRepI_abs_swtj ww_al4F)
                         (GHC.Types.[] @ GHC.Types.Char)
                  of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  }
              }
              }))
          (GHC.Types.: @ GHC.Types.Char lvl_sxau a_swOO)
    }
    }

$cshowsPrec_avFB
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[LclId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 90 0}]
$cshowsPrec_avFB =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.++
      @ GHC.Types.Char
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy
         x_a2fY)
      s_a2fZ

$cshowList_avIE
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[LclId,
 Arity=6,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=6, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0] 150 0}]
$cshowList_avIE =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_B2 :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta_B1 :: GHC.Base.String) ->
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (\ (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
         (s_a2fZ [OS=OneShot] :: GHC.Base.String) ->
         GHC.Base.++
           @ GHC.Types.Char
           ($cshow_avFD
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY)
           s_a2fZ)
      eta_B2
      eta_B1

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[LclIdX[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       $cshowsPrec_avFB
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshow_avFD
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       $cshowList_avIE
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      ($cshowsPrec_avFB
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshow_avFD
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      ($cshowList_avIE
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

a_swjx
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swjx =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl_X1B) ->
    case tpl_X1B of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw3M ->
    ((tpl_X1z
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

$cmult_avFi
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cmult_avFi =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[LclIdX[DFunId(nt)],
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cmult_avFi
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  a_swjx
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

$cminus_avEx
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0 0] 410 0}]
$cminus_avEx =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl_X24, tpl_B3) ->
    let {
      $dKnownNat_swt4
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swt4 =
        case tpl_X24
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_X2y, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    let {
      $dBits_swt5
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swt5 =
        case tpl_X24
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_X2A, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swt6
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swt6 =
        case tpl_X24
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_X2C, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_swt7 =
        case tpl_X24
        of _ [Occ=Dead]
        { (tpl_X1R, tpl_X1T, tpl_X2E, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dBounded_swt9
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_swt9 =
        case tpl_X24
        of _ [Occ=Dead]
        { (tpl_X1N, tpl_X1P, tpl_X2G, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1N
        } } in
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swt2 =
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X21, tpl_X23, tpl_X5p, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swt2,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X43, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5q
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X46, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt2,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl_X7n, tpl_X7q, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       (let {
          $dBits_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swt8 =
            case tpl_X24
            of _ [Occ=Dead]
            { (tpl_X1P, tpl_X1R, tpl_X2I, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swt8,
            case tpl_X24
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5n
            },
            case tpl_X24
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swt8,
            $dResize_swt7,
            $dKnownNat_swt6,
            case tpl_X24
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl_X24
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X24
            of _ [Occ=Dead]
            { (tpl_X7k, tpl_X7n, tpl_X5n, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

$cplus_avDP
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0 0] 410 0}]
$cplus_avDP =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl_X25, tpl_B3) ->
    let {
      $dKnownNat_swsM
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsM =
        case tpl_X25
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_X2z, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_Ba
        } } in
    let {
      $dBits_swsN
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_swsN =
        case tpl_X25
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_X2B, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B9
        } } in
    let {
      $dKnownNat_swsO
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsO =
        case tpl_X25
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_X2D, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    let {
      $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dResize_swsP =
        case tpl_X25
        of _ [Occ=Dead]
        { (tpl_X1S, tpl_X1U, tpl_X2F, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B6
        } } in
    let {
      $dBounded_swsR
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBounded_swsR =
        case tpl_X25
        of _ [Occ=Dead]
        { (tpl_X1O, tpl_X1Q, tpl_X2H, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X1O
        } } in
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl_B3
       (let {
          $dBits_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swsK =
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X22, tpl_X24, tpl_X5q, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits_swsK,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X45, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5r
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X48, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsK,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl_X7p, tpl_X7s, tpl_X5r, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       (let {
          $dBits_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
          [LclId,
           Str=DmdType,
           Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                   ConLike=False, WorkFree=True, Expandable=True,
                   Guidance=IF_ARGS [] 10 0}]
          $dBits_swsQ =
            case tpl_X25
            of _ [Occ=Dead]
            { (tpl_X1Q, tpl_X1S, tpl_X2J, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits_swsQ,
            case tpl_X25
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_X5o
            },
            case tpl_X25
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B4
            },
            $dBits_swsQ,
            $dResize_swsP,
            $dKnownNat_swsO,
            case tpl_X25
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl_X25
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bb
            },
            case tpl_X25
            of _ [Occ=Dead]
            { (tpl_X7m, tpl_X7p, tpl_X5o, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
            tpl_Bc
            })
           eta_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             $cplus_avDP
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             $cminus_avEx
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      ($cplus_avDP
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      ($cminus_avEx
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

$cfromInteger_avDp
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 130 0}]
$cfromInteger_avDp =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    case tpl_X1N
    of _ [Occ=Dead]
    { (tpl_X1M, tpl_X1O, tpl_X3i, tpl_X3k, tpl_X3m, tpl_X3o, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       tpl_B9
       (GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl_B3 eta_X1I)
       (case GHC.Integer.Type.integerToInt
               (tpl_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild_akCB { __DEFAULT ->
        GHC.Types.I# wild_akCB
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

a_swkh
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
a_swkh =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl_X1N, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl_B3
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

$cabs_avCW
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cabs_avCW =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsw =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1X
        } } in
    let {
      $dKnownNat_swsv
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsv =
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    let {
      tup_swsy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsy =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1T, tpl_X1V, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1V
        } } in
    let {
      $dKnownNat_swsx :: GHC.TypeLits.KnownNat size_XuIN
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsx =
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X1V, tpl_X1X, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X22
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsx,
        $dKnownNat_swsv,
        case tup_swsy
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X20
        },
        case tup_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsy
           of _ [Occ=Dead]
           { (tpl_X7i, tpl_X7l, tpl_X5n, tpl_X5p, tpl_X5r, tpl_X5t, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5t
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                    :: CLaSH.Class.Num.Resize rep_XuIL
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

$cnegate_avCC
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
$cnegate_avCC =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swso =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsn
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsn =
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    let {
      tup_swsq
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsq =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1U, tpl_X1W, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1W
        } } in
    let {
      $dKnownNat_swsp :: GHC.TypeLits.KnownNat size_XuIO
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsp =
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X23
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsp,
        $dKnownNat_swsn,
        case tup_swsq
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X21
        },
        case tup_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X21, tpl_X23, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsq
           of _ [Occ=Dead]
           { (tpl_X7k, tpl_X7n, tpl_X5o, tpl_X5q, tpl_X5s, tpl_X5u, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5u
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                    :: CLaSH.Class.Num.Resize rep_XuIM
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

$c-_avCb
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c-_avCb =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsf =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X22
        } } in
    let {
      $dKnownNat_swse
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swse =
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    let {
      tup_swsi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_swsi =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X1W, tpl_X1Y, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsg :: GHC.TypeLits.KnownNat size_XuIP
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_swsg =
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_swsg,
        $dKnownNat_swse,
        case tup_swsi
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X25
        },
        case tup_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X49, tpl_X27, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
          (case tup_swsi
           of _ [Occ=Dead]
           { (tpl_X1Y, tpl_X20, tpl_X5s, tpl_X5u, tpl_X5w, tpl_X5y, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat_swsg
             $dKnownNat_swse
             (eta_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

$c*_avBP
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 222 0}]
$c*_avBP =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup_sws8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws8 =
        case tup_XvDd
        of _ [Occ=Dead]
        { (tpl_X1X, tpl_X1Z, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X1Z
        } } in
    let {
      $dBits_sws7
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dBits_sws7 =
        case tup_sws8
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl_X21, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B5
        } } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B3
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B4
       },
       $dBits_sws7,
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B6
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B7
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B8
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_B9
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X3Z, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Ba
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X42, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bb
       },
       case tup_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl_X22, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
       tpl_Bc
       })
      (case tup_XvDd
       of _ [Occ=Dead]
       { (tpl_Xk, tpl_Xm, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
       case tpl_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox_dw1a ->
       ((tpl_B5
         `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                   <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                 :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                      ~#
                    (rep_XuIO size_XuIQ
                     -> rep_XuIO size_XuIQ
                     -> CLaSH.Class.Num.MResult
                          (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
          (eta_X1U
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ))
          (eta_X3N
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ)))
       `cast` (Sub cobox_dw1a
               ; Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                            GHC.TypeLits.+ size_XuIQ>_N
               :: CLaSH.Class.Num.MResult
                    (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       }
       })

$c+_avBo
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[LclId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
$c+_avBo =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws1 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X24, tpl_X26, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X24
        } } in
    let {
      $dKnownNat_sws0
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_sws0 =
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X26, tpl_X28, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B8
        } } in
    let {
      tup_sws4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      tup_sws4 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl_X20, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        tpl_X20
        } } in
    let {
      $dKnownNat_sws2 :: GHC.TypeLits.KnownNat size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=True, Expandable=True,
               Guidance=IF_ARGS [] 10 0}]
      $dKnownNat_sws2 =
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X22, tpl_X24, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_B7
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_X29
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B3
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B4
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B5
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_B6
        },
        $dKnownNat_sws2,
        $dKnownNat_sws0,
        case tup_sws4
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
        tpl_X27
        },
        case tup_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6, tpl_B7, tpl_B8, tpl_B9, tpl_Ba) ->
        tpl_Ba
        })
       (case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X4d, tpl_X29, tpl_B3, tpl_B4, tpl_B5, tpl_B6) ->
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl_B4
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
          (case tup_sws4
           of _ [Occ=Dead]
           { (tpl_X20, tpl_X22, tpl_X5u, tpl_X5w, tpl_X5y, tpl_X5A, tpl_B7, tpl_B8, tpl_B9, tpl_Ba, tpl_Bb, tpl_Bc) ->
           (tpl_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat_sws2
             $dKnownNat_sws0
             (eta_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     $c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     $cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     (a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
                     `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                             -> Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                             :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> rep_XuIQ size_XuIS)
                                  ~#
                                (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS))
                     $cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      ($c+_avBo @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c*_avBP @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($c-_avCb @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cnegate_avCC @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ($cabs_avCW @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ((a_swkh @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
       `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
               :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> rep_XuIQ size_XuIS)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)))
      ($cfromInteger_avDp @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         (\ ($dKnownNat_avB0
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (ds_dw0H
                                               :: CLaSH.Sized.Fixed.Fixed
                                                    frac_XuIN rep_XuIP size_XuIR) ->
                                            CLaSH.Class.BitVector.toBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avB0
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (ds_dw0H
                                               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                                                       :: CLaSH.Sized.Fixed.Fixed
                                                            frac_XuIN rep_XuIP size_XuIR
                                                            ~#
                                                          rep_XuIP size_XuIR)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR>_R
                                                 -> (CLaSH.Sized.Vector.Vec
                                                       (Sym
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))
                                                       <CLaSH.Bit.Bit>_R)_R
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (CLaSH.Sized.Fixed.Fixed
                                                                frac_XuIN rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit))
                                         (\ ($dKnownNat_avBa
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (bv_auGX
                                               :: CLaSH.Sized.Vector.Vec
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))
                                                    CLaSH.Bit.Bit) ->
                                            CLaSH.Class.BitVector.fromBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avBa
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (bv_auGX
                                               `cast` ((CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N)
                                                          <CLaSH.Bit.Bit>_R)_R
                                                       :: CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit
                                                            ~#
                                                          CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit>_R
                                                 -> Sym
                                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> rep_XuIP size_XuIR)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    let {
      lvl_sxay
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
           -> rep_XuIP size_XuIR
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=True,
               Guidance=IF_ARGS [] 20 0}]
      lvl_sxay =
        CLaSH.Class.BitVector.fromBV
          @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
    let {
      lvl_sxax
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           rep_XuIP size_XuIR
           -> CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=True,
               Guidance=IF_ARGS [] 20 0}]
      lvl_sxax =
        CLaSH.Class.BitVector.toBV
          @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ((\ ($dKnownNat_avB0
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (ds_dw0H
             :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
          lvl_sxax
            ($dKnownNat_avB0
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (ds_dw0H
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                          ~#
                        rep_XuIP size_XuIR)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
               -> (CLaSH.Sized.Vector.Vec
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                     <CLaSH.Bit.Bit>_R)_R
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize
                           (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                        CLaSH.Bit.Bit)))
      ((\ ($dKnownNat_avBa
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (bv_auGX
             :: CLaSH.Sized.Vector.Vec
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                  CLaSH.Bit.Bit) ->
          lvl_sxay
            ($dKnownNat_avBa
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (bv_auGX
             `cast` ((CLaSH.Sized.Vector.Vec
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                        <CLaSH.Bit.Bit>_R)_R
                     :: CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> rep_XuIP size_XuIR)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))

a_swC4
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
a_swC4 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_avAe

$cdef_avAg
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$cdef_avAg =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[LclIdX[DFunId(nt)],
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $cdef_avAg
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  a_swC4
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
                          (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ((GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
      ((GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId[1]],
 Arity=2,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Ordering>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Ordering))
                         (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
                         (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ((GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Ordering>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Ordering)))
      ((GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
      ((GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[LclIdX[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))
                        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ((GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
      ((GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))

a_swCf :: Language.Haskell.TH.Syntax.NameFlavour
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
a_swCf =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (a_swwV
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (a_swwX
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

lvl_swwp :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_swwp =
  Language.Haskell.TH.Syntax.Name
    (a_swwS
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    a_swCf

lvl_sxaz :: Language.Haskell.TH.Syntax.Type
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
lvl_sxaz = Language.Haskell.TH.Syntax.ConT lvl_swwp

a_swCk
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[LclId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
a_swCk =
  \ (@ (m_a4Ni :: * -> *))
    (eta_a4Nj :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    GHC.Base.return
      @ m_a4Ni
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_a4Nj)
      @ Language.Haskell.TH.Syntax.Type
      lvl_sxaz

Rec {
lgo_sxaB [Occ=LoopBreaker]
  :: Language.Haskell.TH.Lib.TypeQ
     -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
[LclId,
 Arity=2,
 Str=DmdType <L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 80 0}]
lgo_sxaB =
  \ (z_awhM :: Language.Haskell.TH.Lib.TypeQ)
    (ds_awhN :: [Language.Haskell.TH.Lib.TypeQ]) ->
    case ds_awhN of _ [Occ=Dead] {
      [] -> z_awhM;
      : x_awhS xs_awhT ->
        lgo_sxaB
          ((Language.Haskell.TH.Lib.appT1 z_awhM x_awhS)
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          xs_awhT
    }
end Rec }

lvl_sxaC :: Language.Haskell.TH.Syntax.Name
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
lvl_sxaC =
  Language.Haskell.TH.Syntax.Name
    ((GHC.Types.[] @ GHC.Types.Char)
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    Language.Haskell.TH.Syntax.NameS

a_swCv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
a_swCv =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    let {
      w1_akV2 :: Language.Haskell.TH.Lib.TypeQ
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 653 0}]
      w1_akV2 =
        lgo_sxaB
          (a_swCk
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          (GHC.Types.:
             @ Language.Haskell.TH.Lib.TypeQ
             (let {
                l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                [LclId,
                 Str=DmdType,
                 Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                         ConLike=False, WorkFree=False, Expandable=False,
                         Guidance=IF_ARGS [] 20 0}]
                l_a5DZ =
                  Language.Haskell.TH.Lib.numTyLit
                    ($dKnownNat_avAr
                     `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                             ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                             :: GHC.TypeLits.KnownNat frac_auGO
                                  ~#
                                GHC.Integer.Type.Integer)) } in
              (\ (@ (m_a5E0 :: * -> *))
                 (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                 GHC.Base.fmap
                   @ m_a5E0
                   (Control.Applicative.$p1Applicative
                      @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                   @ Language.Haskell.TH.Syntax.TyLit
                   @ Language.Haskell.TH.Syntax.Type
                   Language.Haskell.TH.Syntax.LitT
                   ((l_a5DZ
                     `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <Language.Haskell.TH.Syntax.TyLit>_N
                             :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                  ~#
                                (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                      @ m_a5E0 eta_a5E1))
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <Language.Haskell.TH.Syntax.Type>_N)
                      :: (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Type)
                           ~#
                         Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
             (GHC.Types.:
                @ Language.Haskell.TH.Lib.TypeQ
                (let {
                   x_X4Ts :: Language.Haskell.TH.Syntax.Name
                   [LclId,
                    Str=DmdType,
                    Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                            ConLike=False, WorkFree=False, Expandable=False,
                            Guidance=IF_ARGS [] 261 60}]
                   x_X4Ts =
                     case ($dTypeable_avAt
                           `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                                     <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                                   :: Data.Typeable.Internal.Typeable rep_auGP
                                        ~#
                                      (GHC.Prim.Proxy# rep_auGP -> Data.Typeable.Internal.TypeRep)))
                            (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP)
                     of _ [Occ=Dead]
                     { Data.Typeable.Internal.TypeRep ww1_awCq ww2_awCr ww3_awCs
                                                      ww4_awCt ->
                     case GHC.List.reverse1
                            @ GHC.Types.Char
                            (Data.Typeable.Internal.$w$cshowsPrec
                               GHC.Show.shows27 ww3_awCs ww4_awCt (GHC.Types.[] @ GHC.Types.Char))
                            (GHC.Types.[] @ GHC.Types.Char)
                     of _ [Occ=Dead] {
                       [] -> lvl_sxaC;
                       : ds_a5Fa rev_a5Fb ->
                         case ds_a5Fa of wild22_a5Fd { GHC.Types.C# ds1_a5Ff ->
                         case ds1_a5Ff of _ [Occ=Dead] {
                           __DEFAULT ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    wild22_a5Fd (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of _ [Occ=Dead] { (# ww1_a5Aw, ww2_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             };
                           '.' ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    wild22_a5Fd (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of _ [Occ=Dead] { (# ww1_a5Aw, ww2_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww1_a5Aw ww2_a5Ax
                             }
                         }
                         }
                     }
                     } } in
                 let {
                   lvl_sxaD :: Language.Haskell.TH.Syntax.Type
                   [LclId,
                    Str=DmdType,
                    Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=True,
                            ConLike=True, WorkFree=True, Expandable=True,
                            Guidance=IF_ARGS [] 10 20}]
                   lvl_sxaD = Language.Haskell.TH.Syntax.ConT x_X4Ts } in
                 (\ (@ (m_X4Tv :: * -> *))
                    (eta_X4Tx :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
                    GHC.Base.return
                      @ m_X4Tv
                      (Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_X4Tx)
                      @ Language.Haskell.TH.Syntax.Type
                      lvl_sxaD)
                 `cast` (Sym
                           (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.Type>_N)
                         :: (forall (m_a4LE :: * -> *).
                             Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                             m_a4LE Language.Haskell.TH.Syntax.Type)
                              ~#
                            Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                (GHC.Types.:
                   @ Language.Haskell.TH.Lib.TypeQ
                   (let {
                      l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                      [LclId,
                       Str=DmdType,
                       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                               ConLike=False, WorkFree=False, Expandable=False,
                               Guidance=IF_ARGS [] 20 0}]
                      l_a5DZ =
                        Language.Haskell.TH.Lib.numTyLit
                          ($dKnownNat_avAs
                           `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                                   ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                                   :: GHC.TypeLits.KnownNat size_auGQ
                                        ~#
                                      GHC.Integer.Type.Integer)) } in
                    (\ (@ (m_a5E0 :: * -> *))
                       (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                       GHC.Base.fmap
                         @ m_a5E0
                         (Control.Applicative.$p1Applicative
                            @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                         @ Language.Haskell.TH.Syntax.TyLit
                         @ Language.Haskell.TH.Syntax.Type
                         Language.Haskell.TH.Syntax.LitT
                         ((l_a5DZ
                           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <Language.Haskell.TH.Syntax.TyLit>_N
                                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                        ~#
                                      (forall (m_a4LE :: * -> *).
                                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                       m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                            @ m_a5E0 eta_a5E1))
                    `cast` (Sym
                              (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                 <Language.Haskell.TH.Syntax.Type>_N)
                            :: (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.Type)
                                 ~#
                               Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)))) } in
    let {
      w1_acZp :: Language.Haskell.TH.Lib.ExpQ
      [LclId,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
               ConLike=False, WorkFree=False, Expandable=False,
               Guidance=IF_ARGS [] 1 0}]
      w1_acZp =
        ($dLift_avAq
         `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                   <rep_auGP size_auGQ>_N
                 :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                      ~#
                    (rep_auGP size_auGQ
                     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
          (f_auGR
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                        ~#
                      rep_auGP size_auGQ)) } in
    \ (@ (m_akV3 :: * -> *))
      (w2_akV4 :: Language.Haskell.TH.Syntax.Quasi m_akV3) ->
      case w2_akV4
      of ww_akV5
      { Language.Haskell.TH.Syntax.D:Quasi ww1_akV7 ww2_akV8 ww3_akV9
                                           ww4_akVa ww5_akVb ww6_akVc ww7_akVd ww8_akVe ww9_akVf
                                           ww10_akVg ww11_akVh ww12_akVi ww13_akVj ww14_akVk
                                           ww15_akVl ww16_akVm ww17_akVn ww18_akVo ->
      case ww1_akV7
      of _ [Occ=Dead]
      { GHC.Base.D:Monad ww20_akVt ww21_akVu ww22_akVv ww23_akVw ->
      let {
        lvl_sxaG :: m_akV3 Language.Haskell.TH.Syntax.Type
        [LclId,
         Str=DmdType,
         Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                 ConLike=False, WorkFree=False, Expandable=False,
                 Guidance=IF_ARGS [] 1 0}]
        lvl_sxaG =
          (w1_akV2
           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                     <Language.Haskell.TH.Syntax.Type>_N
                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
                        ~#
                      (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)))
            @ m_akV3 ww_akV5 } in
      ww20_akVt
        @ Language.Haskell.TH.Syntax.Exp
        @ Language.Haskell.TH.Syntax.Exp
        (let {
           lvl_sxaF :: m_akV3 Language.Haskell.TH.Syntax.Exp
           [LclId,
            Str=DmdType,
            Unf=Unf{Src=<vanilla>, TopLvl=False, Arity=0, Value=False,
                    ConLike=False, WorkFree=False, Expandable=False,
                    Guidance=IF_ARGS [] 1 0}]
           lvl_sxaF =
             (w1_acZp
              `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N
                      :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
                           ~#
                         (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Exp)))
               @ m_akV3 ww_akV5 } in
         ww20_akVt
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_akVv @ Language.Haskell.TH.Syntax.Exp lvl_sxal)
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_akVt
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl_sxaF
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_akVv
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_akVz :: Language.Haskell.TH.Syntax.Exp) ->
           ww20_akVt
             @ Language.Haskell.TH.Syntax.Type
             @ Language.Haskell.TH.Syntax.Exp
             lvl_sxaG
             (\ (x1_akVA :: Language.Haskell.TH.Syntax.Type) ->
                ww22_akVv
                  @ Language.Haskell.TH.Syntax.Exp
                  (Language.Haskell.TH.Syntax.SigE x_akVz x1_akVA)))
      }
      }

$clift_avAv
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[LclId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
$clift_avAv =
  a_swCv
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[LclIdX[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= $clift_avAv
               `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                              (rep_XuMX :: GHC.TypeLits.Nat -> *)
                              (size_XuMZ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
                       -> <GHC.TypeLits.KnownNat frac_XuMV>_R
                       -> <GHC.TypeLits.KnownNat size_XuMZ>_R
                       -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
                       :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  a_swCv
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = $s^_swu6


*** Tidy Core:

==================== Tidy Core ====================
Result size of Tidy Core
  = {terms: 2,096, types: 9,177, coercions: 947}

lvl_rxjb :: [GHC.Types.Char]
[GblId, Str=DmdType]
lvl_rxjb = GHC.CString.unpackCString# "Negative exponent"#

CLaSH.Sized.Fixed.$s^1 :: GHC.Types.Double
[GblId, Str=DmdType b]
CLaSH.Sized.Fixed.$s^1 = GHC.Err.error @ GHC.Types.Double lvl_rxjb

CLaSH.Sized.Fixed.$s^2 :: GHC.Types.Double
[GblId,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
CLaSH.Sized.Fixed.$s^2 = GHC.Types.D# 1.0

CLaSH.Sized.Fixed.$fShowFixed4 :: GHC.Integer.Type.Integer
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
CLaSH.Sized.Fixed.$fShowFixed4 = __integer 1

CLaSH.Sized.Fixed.$fShowFixed5 :: GHC.Integer.Type.Integer
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
CLaSH.Sized.Fixed.$fShowFixed5 = __integer 2

Rec {
CLaSH.Sized.Fixed.$s^_g1 [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[GblId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0] 442 0}]
CLaSH.Sized.Fixed.$s^_g1 =
  \ (x1_akDN :: GHC.Types.Double)
    (y1_akDO :: GHC.Integer.Type.Integer)
    (z_akDP :: GHC.Types.Double) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y1_akDO GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger#
               y1_akDO CLaSH.Sized.Fixed.$fShowFixed4
        of wild1_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            CLaSH.Sized.Fixed.$s^_g1
              (GHC.Float.timesDouble x1_akDN x1_akDN)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger
                    y1_akDO CLaSH.Sized.Fixed.$fShowFixed4)
                 CLaSH.Sized.Fixed.$fShowFixed5)
              (GHC.Float.timesDouble x1_akDN z_akDP);
          GHC.Types.True -> GHC.Float.timesDouble x1_akDN z_akDP
        }
        };
      GHC.Types.True ->
        CLaSH.Sized.Fixed.$s^_g1
          (GHC.Float.timesDouble x1_akDN x1_akDN)
          (GHC.Integer.Type.quotInteger
             y1_akDO CLaSH.Sized.Fixed.$fShowFixed5)
          z_akDP
    }
    }
end Rec }

Rec {
CLaSH.Sized.Fixed.$s^_f [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[GblId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 372 0}]
CLaSH.Sized.Fixed.$s^_f =
  \ (x_akDA :: GHC.Types.Double)
    (y_akDB :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.eqInteger#
           (GHC.Integer.Type.remInteger y_akDB GHC.Real.even2) GHC.Real.even1
    of wild_akF2 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akF2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger#
               y_akDB CLaSH.Sized.Fixed.$fShowFixed4
        of wild1_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False ->
            CLaSH.Sized.Fixed.$s^_g1
              (GHC.Float.timesDouble x_akDA x_akDA)
              (GHC.Integer.Type.quotInteger
                 (GHC.Integer.Type.minusInteger
                    y_akDB CLaSH.Sized.Fixed.$fShowFixed4)
                 CLaSH.Sized.Fixed.$fShowFixed5)
              x_akDA;
          GHC.Types.True -> x_akDA
        }
        };
      GHC.Types.True ->
        CLaSH.Sized.Fixed.$s^_f
          (GHC.Float.timesDouble x_akDA x_akDA)
          (GHC.Integer.Type.quotInteger
             y_akDB CLaSH.Sized.Fixed.$fShowFixed5)
    }
    }
end Rec }

CLaSH.Sized.Fixed.resizeF1 :: GHC.Integer.Type.Integer
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
CLaSH.Sized.Fixed.resizeF1 = __integer 0

CLaSH.Sized.Fixed.$s^ [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[GblId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 152 0}]
CLaSH.Sized.Fixed.$s^ =
  \ (eta_akDk :: GHC.Types.Double)
    (eta1_akDl :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger#
           eta1_akDl CLaSH.Sized.Fixed.resizeF1
    of wild_a4It { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger#
               eta1_akDl CLaSH.Sized.Fixed.resizeF1
        of wild2_a2f3 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2_a2f3
        of _ [Occ=Dead] {
          GHC.Types.False -> CLaSH.Sized.Fixed.$s^_f eta_akDk eta1_akDl;
          GHC.Types.True -> CLaSH.Sized.Fixed.$s^2
        }
        };
      GHC.Types.True -> CLaSH.Sized.Fixed.$s^1
    }
    }

CLaSH.Sized.Fixed.fLit8 :: GHC.Types.Double
[GblId,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
CLaSH.Sized.Fixed.fLit8 = GHC.Types.D# 2.0

CLaSH.Sized.Fixed.$fLiftFixed7 :: [GHC.Types.Char]
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
CLaSH.Sized.Fixed.$fLiftFixed7 =
  GHC.CString.unpackCString# "Fixed"#

CLaSH.Sized.Fixed.$fLiftFixed6 :: [GHC.Types.Char]
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
CLaSH.Sized.Fixed.$fLiftFixed6 =
  GHC.CString.unpackCString# "clash-prelude-0.5"#

CLaSH.Sized.Fixed.$fLiftFixed5 :: [GHC.Types.Char]
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 80 0}]
CLaSH.Sized.Fixed.$fLiftFixed5 =
  GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

CLaSH.Sized.Fixed.$fLiftFixed4
  :: Language.Haskell.TH.Syntax.NameFlavour
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
CLaSH.Sized.Fixed.$fLiftFixed4 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (CLaSH.Sized.Fixed.$fLiftFixed6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (CLaSH.Sized.Fixed.$fLiftFixed5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

CLaSH.Sized.Fixed.$fLiftFixed3 :: Language.Haskell.TH.Syntax.Name
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
CLaSH.Sized.Fixed.$fLiftFixed3 =
  Language.Haskell.TH.Syntax.Name
    (CLaSH.Sized.Fixed.$fLiftFixed7
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    CLaSH.Sized.Fixed.$fLiftFixed4

CLaSH.Sized.Fixed.fLit7 :: [GHC.Types.Char]
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 60 0}]
CLaSH.Sized.Fixed.fLit7 = GHC.CString.unpackCString# "fromInteger"#

CLaSH.Sized.Fixed.fLit6 :: [GHC.Types.Char]
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 40 0}]
CLaSH.Sized.Fixed.fLit6 = GHC.CString.unpackCString# "base"#

CLaSH.Sized.Fixed.fLit5 :: [GHC.Types.Char]
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=False,
         ConLike=False, WorkFree=False, Expandable=False,
         Guidance=IF_ARGS [] 50 0}]
CLaSH.Sized.Fixed.fLit5 = GHC.CString.unpackCString# "GHC.Num"#

CLaSH.Sized.Fixed.fLit4 :: Language.Haskell.TH.Syntax.NameFlavour
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
CLaSH.Sized.Fixed.fLit4 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (CLaSH.Sized.Fixed.fLit6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (CLaSH.Sized.Fixed.fLit5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

CLaSH.Sized.Fixed.fLit3 :: Language.Haskell.TH.Syntax.Name
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
CLaSH.Sized.Fixed.fLit3 =
  Language.Haskell.TH.Syntax.Name
    (CLaSH.Sized.Fixed.fLit7
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    CLaSH.Sized.Fixed.fLit4

CLaSH.Sized.Fixed.$fLiftFixed2 :: Language.Haskell.TH.Syntax.Exp
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
CLaSH.Sized.Fixed.$fLiftFixed2 =
  Language.Haskell.TH.Syntax.ConE CLaSH.Sized.Fixed.$fLiftFixed3

CLaSH.Sized.Fixed.fLit2 :: Language.Haskell.TH.Syntax.Exp
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
CLaSH.Sized.Fixed.fLit2 =
  Language.Haskell.TH.Syntax.VarE CLaSH.Sized.Fixed.fLit3

CLaSH.Sized.Fixed.fLit1
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[GblId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.fLit1 =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_avlM :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_avlO :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_avlP :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_auGC :: GHC.Types.Double) ->
    let {
      x_akVD :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      x_akVD =
        let {
          truncated_swu2 :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          truncated_swu2 =
            case a_auGC of _ [Occ=Dead] { GHC.Types.D# x1_aw80 ->
            case CLaSH.Sized.Fixed.$s^
                   CLaSH.Sized.Fixed.fLit8
                   ($dKnownNat_avlM
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                            :: GHC.TypeLits.KnownNat frac_avhM ~# GHC.Integer.Type.Integer))
            of _ [Occ=Dead] { GHC.Types.D# y_aw84 ->
            case GHC.Integer.Type.decodeDoubleInteger
                   (GHC.Prim.*## x1_aw80 y_aw84)
            of _ [Occ=Dead] { (# ipv_aw8Q, ipv1_aw8R #) ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# ipv1_aw8R 0)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Integer.Type.shiftLInteger ipv_aw8Q ipv1_aw8R;
              GHC.Types.True ->
                let {
                  s_aw8X :: GHC.Prim.Int#
                  [LclId, Str=DmdType]
                  s_aw8X = GHC.Prim.negateInt# ipv1_aw8R } in
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.># s_aw8X 52)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger#
                           ipv_aw8Q CLaSH.Sized.Fixed.resizeF1
                    of wild4_aw92 { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4_aw92
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        case GHC.Integer.Type.integerToInt ipv_aw8Q
                        of n_aw96 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.uncheckedIShiftRA# n_aw96 s_aw8X)
                        };
                      GHC.Types.True ->
                        case GHC.Integer.Type.integerToInt
                               (GHC.Integer.Type.negateInteger ipv_aw8Q)
                        of n_aw99 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger
                          (GHC.Prim.negateInt# (GHC.Prim.uncheckedIShiftRA# n_aw99 s_aw8X))
                        }
                    }
                    };
                  GHC.Types.True -> CLaSH.Sized.Fixed.resizeF1
                }
            }
            }
            }
            } } in
        let {
          rMax_swu0 :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          rMax_swu0 =
            GHC.Real.toInteger
              @ (rep_avhN size_avhO)
              $dIntegral_avlP
              (GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
        case GHC.Integer.Type.gtInteger# truncated_swu2 rMax_swu0
        of wild_akJ6 { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ6
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              rMin_swu1 :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              rMin_swu1 =
                GHC.Real.toInteger
                  @ (rep_avhN size_avhO)
                  $dIntegral_avlP
                  (GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_avlO) } in
            case GHC.Integer.Type.ltInteger# truncated_swu2 rMin_swu1
            of wild2_a4It { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2_a4It
            of _ [Occ=Dead] {
              GHC.Types.False -> truncated_swu2;
              GHC.Types.True -> rMin_swu1
            }
            };
          GHC.Types.True -> rMax_swu0
        }
        } } in
    let {
      a1_sxb9 :: Language.Haskell.TH.Syntax.Lit
      [LclId, Str=DmdType]
      a1_sxb9 = Language.Haskell.TH.Syntax.IntegerL x_akVD } in
    let {
      lvl1_sxan :: Language.Haskell.TH.Syntax.Exp
      [LclId, Str=DmdType]
      lvl1_sxan = Language.Haskell.TH.Syntax.LitE a1_sxb9 } in
    \ (@ (m_awx9 :: * -> *))
      (w1_awxa :: Language.Haskell.TH.Syntax.Quasi m_awx9) ->
      case w1_awxa
      of _ [Occ=Dead]
      { Language.Haskell.TH.Syntax.D:Quasi ww1_awxd ww2_awxe ww3_awxf
                                           ww4_awxg ww5_awxh ww6_awxi ww7_awxj ww8_awxk ww9_awxl
                                           ww10_awxm ww11_awxn ww12_awxo ww13_awxp ww14_awxq
                                           ww15_awxr ww16_awxs ww17_awxt ww18_awxu ->
      case ww1_awxd
      of _ [Occ=Dead]
      { GHC.Base.D:Monad ww20_awxy ww21_awxz ww22_awxA ww23_awxB ->
      ww20_awxy
        @ Language.Haskell.TH.Syntax.Exp
        @ (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
        (let {
           lvl2_sxap :: m_awx9 Language.Haskell.TH.Syntax.Exp
           [LclId, Str=DmdType]
           lvl2_sxap =
             let {
               lvl3_sxao :: m_awx9 Language.Haskell.TH.Syntax.Exp
               [LclId, Str=DmdType]
               lvl3_sxao =
                 ww22_awxA @ Language.Haskell.TH.Syntax.Exp lvl1_sxan } in
             ww20_awxy
               @ Language.Haskell.TH.Syntax.Exp
               @ Language.Haskell.TH.Syntax.Exp
               (ww22_awxA
                  @ Language.Haskell.TH.Syntax.Exp CLaSH.Sized.Fixed.fLit2)
               (\ (x1_Xd36 :: Language.Haskell.TH.Syntax.Exp) ->
                  ww20_awxy
                    @ Language.Haskell.TH.Syntax.Exp
                    @ Language.Haskell.TH.Syntax.Exp
                    lvl3_sxao
                    (\ (x2_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                       ww22_awxA
                         @ Language.Haskell.TH.Syntax.Exp
                         (Language.Haskell.TH.Syntax.AppE x1_Xd36 x2_acZX))) } in
         ww20_awxy
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_awxA
              @ Language.Haskell.TH.Syntax.Exp CLaSH.Sized.Fixed.$fLiftFixed2)
           (\ (x1_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_awxy
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl2_sxap
                (\ (x2_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_awxA
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x1_acZW x2_acZX))))
        (\ (x1_awxD :: Language.Haskell.TH.Syntax.Exp) ->
           ww22_awxA
             @ (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
             (x1_awxD
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:TExp[0]
                           <CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO>_N)
                      :: Language.Haskell.TH.Syntax.Exp
                           ~#
                         Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))
      }
      }

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[GblId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.fLit =
  CLaSH.Sized.Fixed.fLit1
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[GblId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_avmQ :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_B1 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    case tup_avmQ
    of _ [Occ=Dead]
    { (tpl_X1t, tpl1_B2, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
    let {
      repBV_swtT
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      repBV_swtT =
        case tpl5_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl3_B4
           (tpl7_B8
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox1_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_B1)
        `cast` ((CLaSH.Sized.Vector.Vec cobox1_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        } } in
    let {
      s_swtS :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      s_swtS =
        case tpl1_B2 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw7d ->
        CLaSH.Sized.Vector.vtail
          @ n_aviz
          @ CLaSH.Bit.Bit
          (CLaSH.Sized.Vector.vtail
             @ (n_aviz GHC.TypeLits.+ 1)
             @ CLaSH.Bit.Bit
             (repBV_swtT
              `cast` ((CLaSH.Sized.Vector.Vec
                         (Sym cobox1_dw7d) <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
        } } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl9_Ba eta_B1
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case tpl1_B2 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl8_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl2_B3
                  (case tpl4_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7b ->
                   tpl6_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case tpl4_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox3_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead
                   @ n_aviz
                   @ CLaSH.Bit.Bit
                   (CLaSH.Sized.Vector.vtail
                      @ (n_aviz GHC.TypeLits.+ 1)
                      @ CLaSH.Bit.Bit
                      (repBV_swtT
                       `cast` ((CLaSH.Sized.Vector.Vec
                                  (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                               :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                    ~#
                                  CLaSH.Sized.Vector.Vec
                                    ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit)))
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl8_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl2_B3
                  (case tpl4_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7b ->
                   tpl6_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw7b))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case tpl4_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7c ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox3_dw7c) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        };
      GHC.Types.True ->
        case tpl1_B2 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_swtT
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl2_B3
                  (case tpl4_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw79 ->
                   tpl6_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case tpl4_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox3_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   });
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl8_B9
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_X1t s_swtS
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl8_B9;
              CLaSH.Bit.L ->
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz)
                  tpl2_B3
                  (case tpl4_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw79 ->
                   tpl6_B7
                   `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw79))_R
                           :: GHC.TypeLits.KnownNat n_aviz
                                ~#
                              GHC.TypeLits.KnownNat
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                   })
                  (case tpl4_B5 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7a ->
                   s_swtS
                   `cast` ((CLaSH.Sized.Vector.Vec
                              (Sym cobox3_dw7a) <CLaSH.Bit.Bit>_R)_R
                           :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                ~#
                              CLaSH.Sized.Vector.Vec
                                (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                   })
            }
        }
        }
    }
    }

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[GblId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_avnK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_B1
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_swtI :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_swtI =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1i, tpl1_B2, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl7_B8
        } } in
    let {
      $dKnownNat1_swtH :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat1_swtH =
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1k, tpl1_B2, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl6_B7
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_swtI
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat1_swtH
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_akJ3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_akJ3
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl1_B2, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl10_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild3_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl9_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild4_XkFQ { __DEFAULT ->
        let {
          fMax_swtA :: rep_avjs size2_avju
          [LclId, Str=DmdType]
          fMax_swtA = GHC.Enum.maxBound @ (rep_avjs size2_avju) tpl_X1y } in
        let {
          mask_swtz :: rep_avjs size1_avjt
          [LclId, Str=DmdType]
          mask_swtz =
            Data.Bits.complement
              @ (rep_avjs size1_avjt)
              tpl4_B5
              ((tpl5_B6
                `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                        :: CLaSH.Class.Num.Resize rep_avjs
                             ~#
                           (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                            (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                            rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                 @ size2_avju
                 @ size1_avjt
                 $dKnownNat1_swtH
                 $dKnownNat_swtI
                 fMax_swtA) } in
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild3_akCB wild4_XkFQ)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_swty :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedR_swty =
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  tpl4_B5
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild3_akCB wild4_XkFQ)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl2_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) tpl3_B4 CLaSH.Sized.Fixed.resizeF1)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_B5)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) tpl4_B5 shiftedR_swty mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) tpl_X1y)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat1_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_B5)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) tpl4_B5 shiftedR_swty mask_swtz)
                       (GHC.Num.fromInteger
                          @ (rep_avjs size1_avjt) tpl3_B4 CLaSH.Sized.Fixed.resizeF1)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat1_swtH
                       shiftedR_swty)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_swtK :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedL_swtK =
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  tpl4_B5
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  (GHC.Types.I# (GHC.Prim.-# wild4_XkFQ wild3_akCB)) } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl2_B3
                   (eta_B1
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   (GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) tpl3_B4 CLaSH.Sized.Fixed.resizeF1)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_B5)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) tpl4_B5 shiftedL_swtK mask_swtz)
                       mask_swtz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) tpl_X1y)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat1_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                };
              GHC.Types.True ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt)
                       (Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_B5)
                       (Data.Bits..&.
                          @ (rep_avjs size1_avjt) tpl4_B5 shiftedL_swtK mask_swtz)
                       (GHC.Num.fromInteger
                          @ (rep_avjs size1_avjt) tpl3_B4 CLaSH.Sized.Fixed.resizeF1)
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_swtA
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_B6
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_swtI
                       $dKnownNat1_swtH
                       shiftedL_swtK)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_avnK
        of _ [Occ=Dead]
        { (tpl_X1y, tpl1_B2, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        case GHC.Integer.Type.integerToInt
               (tpl10_Bb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild3_akCB { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl9_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild4_XkFG { __DEFAULT ->
        case GHC.Prim.tagToEnum#
               @ GHC.Types.Bool (GHC.Prim.<=# wild3_akCB wild4_XkFG)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju)
               tpl8_B9
               ((tpl5_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat1_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild3_akCB wild4_XkFG)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
          GHC.Types.True ->
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju)
               tpl8_B9
               ((tpl5_B6
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_swtI
                  $dKnownNat1_swtH
                  (eta_B1
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)))
               (GHC.Types.I# (GHC.Prim.-# wild4_XkFG wild3_akCB)))
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0] 40 20}]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_avxa :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_avxa
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_akCB { __DEFAULT ->
    GHC.Types.I# wild_akCB
    }

CLaSH.Sized.Fixed.unUF1
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF1 =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_dvZi
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_dvZi

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unUF =
  CLaSH.Sized.Fixed.unUF1
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

CLaSH.Sized.Fixed.uf1
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf1 =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auGb
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_auGb

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.uf =
  CLaSH.Sized.Fixed.uf1
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

CLaSH.Sized.Fixed.unSF1
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF1 =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_dvZu
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_dvZu

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unSF =
  CLaSH.Sized.Fixed.unSF1
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

CLaSH.Sized.Fixed.sf1
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf1 =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_auG9
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_auG9

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.sf =
  CLaSH.Sized.Fixed.sf1
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

CLaSH.Sized.Fixed.unFixed1
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed1 =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_dvZF
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_dvZF

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.unFixed =
  CLaSH.Sized.Fixed.unFixed1
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

CLaSH.Sized.Fixed.$fShowFixed1 :: GHC.Types.Char
[GblId,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
CLaSH.Sized.Fixed.$fShowFixed1 = GHC.Types.C# '-'

CLaSH.Sized.Fixed.$fShowFixed3 :: GHC.Types.Char
[GblId,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
CLaSH.Sized.Fixed.$fShowFixed3 = GHC.Types.C# '0'

CLaSH.Sized.Fixed.$fShowFixed_dt :: GHC.Integer.Type.Integer
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 100 0}]
CLaSH.Sized.Fixed.$fShowFixed_dt = __integer 10

CLaSH.Sized.Fixed.$fShowFixed7
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40] 191 30}]
CLaSH.Sized.Fixed.$fShowFixed7 =
  \ (ds_awe3
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    (case ds_awe3 of _ [Occ=Dead] { (x_awe6, y_awe7) ->
     case x_awe6 of _ [Occ=Dead] { GHC.Types.I# x1_awdC ->
     case x1_awdC of wild2_awdE {
       __DEFAULT -> GHC.Types.I# (GHC.Prim.+# wild2_awdE 1);
       9223372036854775807 -> GHC.Enum.$fEnumInt2
     }
     }
     },
     case ds_awe3 of _ [Occ=Dead] { (x_aweb, y_awec) ->
     case y_awec of _ [Occ=Dead] { GHC.Real.:% ww1_awdJ ww2_awdK ->
     case GHC.Real.$w$sreduce
            (GHC.Integer.Type.timesInteger
               ww1_awdJ CLaSH.Sized.Fixed.$fShowFixed_dt)
            (GHC.Integer.Type.timesInteger ww2_awdK GHC.Real.$fEnumRatio1)
     of _ [Occ=Dead] { (# ww7_awdU, ww8_awdV #) ->
     GHC.Real.:% @ GHC.Integer.Type.Integer ww7_awdU ww8_awdV
     }
     }
     })

CLaSH.Sized.Fixed.$fShowFixed6 :: GHC.Types.Int
[GblId,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
CLaSH.Sized.Fixed.$fShowFixed6 = GHC.Types.I# 0

CLaSH.Sized.Fixed.$fShowFixed8
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[GblId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 91 30}]
CLaSH.Sized.Fixed.$fShowFixed8 =
  \ (x_awzz
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    (r_awzA
       :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]) ->
    case x_awzz of wild_afnB { (ds1_afnD, y_afnE) ->
    case y_afnE of _ [Occ=Dead] { GHC.Real.:% ds2_awdp y1_awdq ->
    case GHC.Integer.Type.eqInteger#
           y1_awdq CLaSH.Sized.Fixed.$fShowFixed4
    of wild2_a2f3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2_a2f3
    of _ [Occ=Dead] {
      GHC.Types.False -> r_awzA;
      GHC.Types.True ->
        GHC.Types.:
          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          wild_afnB
          r_awzA
    }
    }
    }
    }

CLaSH.Sized.Fixed.$fShowFixed2 :: GHC.Types.Char
[GblId,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
CLaSH.Sized.Fixed.$fShowFixed2 = GHC.Types.C# '.'

CLaSH.Sized.Fixed.$fShowFixed_$cshow
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[GblId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.$fShowFixed_$cshow =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_auHA :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      fRepI_swtk :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_swtk =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_avFy
          (f_auHA
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    case GHC.Integer.Type.ltInteger#
           fRepI_swtk CLaSH.Sized.Fixed.resizeF1
    of wild_a4It { __DEFAULT ->
    let {
      fRepI_abs_swtj :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_abs_swtj = GHC.Integer.Type.absInteger fRepI_swtk } in
    let {
      nF_swti :: GHC.Types.Int
      [LclId, Str=DmdType]
      nF_swti =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_avFx
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild1_akCB { __DEFAULT ->
        GHC.Types.I# wild1_akCB
        } } in
    let {
      a_swOO :: [GHC.Types.Char]
      [LclId, Str=DmdType]
      a_swOO =
        case GHC.List.iterateFB
               @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
               @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
               CLaSH.Sized.Fixed.$fShowFixed8
               CLaSH.Sized.Fixed.$fShowFixed7
               (CLaSH.Sized.Fixed.$fShowFixed6,
                case GHC.Integer.Type.ltInteger#
                       fRepI_swtk CLaSH.Sized.Fixed.resizeF1
                of wild1_X4KP { __DEFAULT ->
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1_X4KP
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_awO9 ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        let {
                          a1_swOs :: GHC.Integer.Type.Integer
                          [LclId, Str=DmdType]
                          a1_swOs =
                            case x_awO9 of wild5_awOe {
                              __DEFAULT ->
                                GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_awOe;
                              0 -> GHC.Real.$fEnumRatio1
                            } } in
                        case x_awO9 of wild5_awOe {
                          __DEFAULT ->
                            case GHC.Real.$w$sreduce
                                   (GHC.Integer.Type.timesInteger
                                      (GHC.Integer.Type.andInteger
                                         fRepI_swtk
                                         (GHC.Integer.Type.minusInteger
                                            (GHC.Real.$wf1
                                               CLaSH.Sized.Fixed.$fShowFixed5 wild5_awOe)
                                            CLaSH.Sized.Fixed.$fShowFixed4))
                                      (GHC.Integer.Type.signumInteger a1_swOs))
                                   (GHC.Integer.Type.absInteger a1_swOs)
                            of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                            GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                            };
                          0 ->
                            case GHC.Real.$w$sreduce
                                   (GHC.Integer.Type.timesInteger
                                      (GHC.Integer.Type.andInteger
                                         fRepI_swtk CLaSH.Sized.Fixed.resizeF1)
                                      (GHC.Integer.Type.signumInteger a1_swOs))
                                   (GHC.Integer.Type.absInteger a1_swOs)
                            of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                            GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                            }
                        };
                      GHC.Types.True -> case GHC.Real.^3 of wild5_00 { }
                    }
                    };
                  GHC.Types.True ->
                    case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_awO9 ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x_awO9 0)
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        let {
                          a1_swOy :: GHC.Integer.Type.Integer
                          [LclId, Str=DmdType]
                          a1_swOy =
                            case x_awO9 of wild5_awOe {
                              __DEFAULT ->
                                GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_awOe;
                              0 -> GHC.Real.$fEnumRatio1
                            } } in
                        case x_awO9 of wild5_awOe {
                          __DEFAULT ->
                            case GHC.Real.$w$sreduce
                                   (GHC.Integer.Type.timesInteger
                                      (GHC.Integer.Type.andInteger
                                         fRepI_abs_swtj
                                         (GHC.Integer.Type.minusInteger
                                            (GHC.Real.$wf1
                                               CLaSH.Sized.Fixed.$fShowFixed5 wild5_awOe)
                                            CLaSH.Sized.Fixed.$fShowFixed4))
                                      (GHC.Integer.Type.signumInteger a1_swOy))
                                   (GHC.Integer.Type.absInteger a1_swOy)
                            of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                            GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                            };
                          0 ->
                            case GHC.Real.$w$sreduce
                                   (GHC.Integer.Type.timesInteger
                                      (GHC.Integer.Type.andInteger
                                         fRepI_abs_swtj CLaSH.Sized.Fixed.resizeF1)
                                      (GHC.Integer.Type.signumInteger a1_swOy))
                                   (GHC.Integer.Type.absInteger a1_swOy)
                            of _ [Occ=Dead] { (# ww1_awf5, ww2_awf6 #) ->
                            GHC.Real.:% @ GHC.Integer.Type.Integer ww1_awf5 ww2_awf6
                            }
                        };
                      GHC.Types.True -> case GHC.Real.^3 of wild5_00 { }
                    }
                    }
                }
                })
        of _ [Occ=Dead] {
          [] -> case Data.Maybe.fromJust1 of wild2_00 { };
          : a1_awdh ds1_awdi ->
            case a1_awdh of _ [Occ=Dead] { (x_awcU, y_awcV) ->
            case x_awcU of _ [Occ=Dead] { GHC.Types.I# x1_akIV ->
            let {
              str_auHK :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              str_auHK =
                case y_awcV of _ [Occ=Dead] { GHC.Real.:% x2_awcK ds2_awcL ->
                case GHC.Show.$w$cshowsPrec
                       0 x2_awcK (GHC.Types.[] @ GHC.Types.Char)
                of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                }
                } } in
            case GHC.List.$wlenAcc @ GHC.Types.Char str_auHK 0
            of ww_awOK { __DEFAULT ->
            let {
              n#_awbi :: GHC.Prim.Int#
              [LclId, Str=DmdType]
              n#_awbi = GHC.Prim.-# x1_akIV ww_awOK } in
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# n#_awbi 0)
            of _ [Occ=Dead] {
              GHC.Types.False ->
                let {
                  lvl1_sxat :: [GHC.Types.Char]
                  [LclId, Str=DmdType]
                  lvl1_sxat =
                    GHC.Types.:
                      @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed3 str_auHK } in
                letrec {
                  xs_awyT [Occ=LoopBreaker] :: GHC.Prim.Int# -> [GHC.Types.Char]
                  [LclId, Arity=1, Str=DmdType]
                  xs_awyT =
                    \ (m_awz0 :: GHC.Prim.Int#) ->
                      case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<=# m_awz0 1)
                      of _ [Occ=Dead] {
                        GHC.Types.False ->
                          GHC.Types.:
                            @ GHC.Types.Char
                            CLaSH.Sized.Fixed.$fShowFixed3
                            (xs_awyT (GHC.Prim.-# m_awz0 1));
                        GHC.Types.True -> lvl1_sxat
                      }; } in
                xs_awyT n#_awbi;
              GHC.Types.True -> str_auHK
            }
            }
            }
            }
        } } in
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_a4It
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
        let {
          ww_al4F :: GHC.Prim.Int#
          [LclId, Str=DmdType]
          ww_al4F = GHC.Prim.negateInt# x_aiKN } in
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
        of _ [Occ=Dead] {
          GHC.Types.False ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftRInteger
                      fRepI_swtk (GHC.Prim.negateInt# ww_al4F))
                   (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.:
                 @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed2 a_swOO)
            };
          GHC.Types.True ->
            case GHC.Show.$w$cshowsPrec
                   0
                   (GHC.Integer.Type.shiftLInteger fRepI_swtk ww_al4F)
                   (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
            GHC.Base.++
              @ GHC.Types.Char
              (GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1)
              (GHC.Types.:
                 @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed2 a_swOO)
            }
        }
        };
      GHC.Types.True ->
        GHC.Base.++
          @ GHC.Types.Char
          (GHC.Types.:
             @ GHC.Types.Char
             CLaSH.Sized.Fixed.$fShowFixed1
             (case nF_swti of _ [Occ=Dead] { GHC.Types.I# x_aiKN ->
              let {
                ww_al4F :: GHC.Prim.Int#
                [LclId, Str=DmdType]
                ww_al4F = GHC.Prim.negateInt# x_aiKN } in
              case GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.>=# ww_al4F 0)
              of _ [Occ=Dead] {
                GHC.Types.False ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftRInteger
                            fRepI_abs_swtj (GHC.Prim.negateInt# ww_al4F))
                         (GHC.Types.[] @ GHC.Types.Char)
                  of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  };
                GHC.Types.True ->
                  case GHC.Show.$w$cshowsPrec
                         0
                         (GHC.Integer.Type.shiftLInteger fRepI_abs_swtj ww_al4F)
                         (GHC.Types.[] @ GHC.Types.Char)
                  of _ [Occ=Dead] { (# ww3_a2i0, ww4_a2i1 #) ->
                  GHC.Types.: @ GHC.Types.Char ww3_a2i0 ww4_a2i1
                  }
              }
              }))
          (GHC.Types.:
             @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed2 a_swOO)
    }
    }

CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[GblId,
 Arity=7,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=7, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0 0] 90 0}]
CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_a2fZ :: GHC.Base.String) ->
    GHC.Base.++
      @ GHC.Types.Char
      (CLaSH.Sized.Fixed.$fShowFixed_$cshow
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy
         x_a2fY)
      s_a2fZ

CLaSH.Sized.Fixed.$fShowFixed_$cshowList
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[GblId,
 Arity=6,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=6, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 0 0 0] 150 0}]
CLaSH.Sized.Fixed.$fShowFixed_$cshowList =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_B2 :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta1_B1 :: GHC.Base.String) ->
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (\ (x_a2fY :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
         (s_a2fZ :: GHC.Base.String) ->
         GHC.Base.++
           @ GHC.Types.Char
           (CLaSH.Sized.Fixed.$fShowFixed_$cshow
              @ frac_auHx
              @ rep_auHy
              @ size_auHz
              $dShow_avFv
              $dBits_avFw
              $dKnownNat_avFx
              $dIntegral_avFy
              x_a2fY)
           s_a2fZ)
      eta_B2
      eta1_B1

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[GblId[DFunId],
 Arity=4,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_auHx :: GHC.TypeLits.Nat))
             (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
             (@ (size_auHz :: GHC.TypeLits.Nat))
             ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
             ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
             ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
             ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
       GHC.Show.D:Show TYPE CLaSH.Sized.Fixed.Fixed
                              frac_auHx rep_auHy size_auHz
                       CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       CLaSH.Sized.Fixed.$fShowFixed_$cshow
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy
                       CLaSH.Sized.Fixed.$fShowFixed_$cshowList
                         @ frac_auHx
                         @ rep_auHy
                         @ size_auHz
                         $dShow_avFv
                         $dBits_avFw
                         $dKnownNat_avFx
                         $dIntegral_avFy]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_avFv :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_avFw :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_avFx :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_avFy :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      (CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      (CLaSH.Sized.Fixed.$fShowFixed_$cshow
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)
      (CLaSH.Sized.Fixed.$fShowFixed_$cshowList
         @ frac_auHx
         @ rep_auHy
         @ size_auHz
         $dShow_avFv
         $dBits_avFw
         $dKnownNat_avFx
         $dIntegral_avFy)

CLaSH.Sized.Fixed.$fMultFixedFixed1
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.$fMultFixedFixed1 =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_avFg
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_B2 :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta1_B1
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_avFg of _ [Occ=Dead] { (tpl_X1z, tpl1_X1B) ->
    case tpl1_X1B of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw3M ->
    ((tpl_X1z
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_B2
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta1_B1
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox1_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

CLaSH.Sized.Fixed.$fMultFixedFixed_$cmult
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[GblId,
 Arity=3,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.$fMultFixedFixed_$cmult =
  CLaSH.Sized.Fixed.$fMultFixedFixed1
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= CLaSH.Sized.Fixed.$fMultFixedFixed_$cmult
               `cast` (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                              (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                              (size1_XuJ3 :: GHC.TypeLits.Nat)
                              (frac2_XuJ5 :: GHC.TypeLits.Nat)
                              (size2_XuJ7 :: GHC.TypeLits.Nat).
                       <CLaSH.Sized.Fixed.MultFixed
                          rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7>_R
                       -> Sym
                            (CLaSH.Class.Num.NTCo:Mult[0]
                               <CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3>_N
                               <CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7>_N)
                       :: (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3
                           -> CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7
                           -> CLaSH.Class.Num.MResult
                                (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                                (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7))
                            ~#
                          (forall (frac1_XuIZ :: GHC.TypeLits.Nat)
                                  (rep_XuJ1 :: GHC.TypeLits.Nat -> *)
                                  (size1_XuJ3 :: GHC.TypeLits.Nat)
                                  (frac2_XuJ5 :: GHC.TypeLits.Nat)
                                  (size2_XuJ7 :: GHC.TypeLits.Nat).
                           (CLaSH.Sized.Fixed.MultFixed
                              rep_XuJ1 frac1_XuIZ frac2_XuJ5 size1_XuJ3 size2_XuJ7) =>
                           CLaSH.Class.Num.Mult
                             (CLaSH.Sized.Fixed.Fixed frac1_XuIZ rep_XuJ1 size1_XuJ3)
                             (CLaSH.Sized.Fixed.Fixed frac2_XuJ5 rep_XuJ1 size2_XuJ7)))}]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  CLaSH.Sized.Fixed.$fMultFixedFixed1
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[GblId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0 0] 410 0}]
CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1I :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta1_X3p
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_avDN of _ [Occ=Dead] { (tpl_X22, tpl1_X24, tpl2_B3) ->
    let {
      $dKnownNat_swt4
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swt4 =
        case tpl1_X24
        of _ [Occ=Dead]
        { (tpl3_X1X, tpl4_X1Z, tpl5_X2y, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl12_Ba
        } } in
    let {
      $dBits_swt5
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swt5 =
        case tpl1_X24
        of _ [Occ=Dead]
        { (tpl3_X1V, tpl4_X1X, tpl5_X2A, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl11_B9
        } } in
    let {
      $dKnownNat1_swt6
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat1_swt6 =
        case tpl1_X24
        of _ [Occ=Dead]
        { (tpl3_X1T, tpl4_X1V, tpl5_X2C, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl9_B7
        } } in
    let {
      $dResize_swt7 :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swt7 =
        case tpl1_X24
        of _ [Occ=Dead]
        { (tpl3_X1R, tpl4_X1T, tpl5_X2E, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl8_B6
        } } in
    let {
      $dBounded_swt9
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swt9 =
        case tpl1_X24
        of _ [Occ=Dead]
        { (tpl3_X1N, tpl4_X1P, tpl5_X2G, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl3_X1N
        } } in
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl2_B3
       (let {
          $dBits1_swt2 :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits1_swt2 =
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl3_X21, tpl4_X23, tpl5_X5p, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl7_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits1_swt2,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl3_X43, tpl4_X7q, tpl5_X5q, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl5_X5q
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl3_X7n, tpl4_X46, tpl5_X5q, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl6_B4
            },
            $dBits1_swt2,
            $dResize_swt7,
            $dKnownNat1_swt6,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl3_X7n, tpl4_X7q, tpl5_X5q, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl10_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl3_X7n, tpl4_X7q, tpl5_X5q, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl13_Bb
            },
            case tpl_X22
            of _ [Occ=Dead]
            { (tpl3_X7n, tpl4_X7q, tpl5_X5q, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl14_Bc
            })
           eta_X1I)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       (let {
          $dBits1_swt8 :: Data.Bits.Bits (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          $dBits1_swt8 =
            case tpl1_X24
            of _ [Occ=Dead]
            { (tpl3_X1P, tpl4_X1R, tpl5_X2I, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl7_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swt9,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits1_swt8,
            case tpl1_X24
            of _ [Occ=Dead]
            { (tpl3_X7k, tpl4_X7n, tpl5_X5n, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl5_X5n
            },
            case tpl1_X24
            of _ [Occ=Dead]
            { (tpl3_X7k, tpl4_X7n, tpl5_X5n, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl6_B4
            },
            $dBits1_swt8,
            $dResize_swt7,
            $dKnownNat1_swt6,
            case tpl1_X24
            of _ [Occ=Dead]
            { (tpl3_X7k, tpl4_X7n, tpl5_X5n, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl10_B8
            },
            $dBits_swt5,
            $dKnownNat_swt4,
            case tpl1_X24
            of _ [Occ=Dead]
            { (tpl3_X7k, tpl4_X7n, tpl5_X5n, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl13_Bb
            },
            case tpl1_X24
            of _ [Occ=Dead]
            { (tpl3_X7k, tpl4_X7n, tpl5_X5n, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl14_Bc
            })
           eta1_X3p)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[GblId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0 0] 410 0}]
CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_X1J :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta1_X3r
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_avDN of _ [Occ=Dead] { (tpl_X23, tpl1_X25, tpl2_B3) ->
    let {
      $dKnownNat_swsM
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_swsM =
        case tpl1_X25
        of _ [Occ=Dead]
        { (tpl3_X1Y, tpl4_X20, tpl5_X2z, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl12_Ba
        } } in
    let {
      $dBits_swsN
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_swsN =
        case tpl1_X25
        of _ [Occ=Dead]
        { (tpl3_X1W, tpl4_X1Y, tpl5_X2B, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl11_B9
        } } in
    let {
      $dKnownNat1_swsO
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat1_swsO =
        case tpl1_X25
        of _ [Occ=Dead]
        { (tpl3_X1U, tpl4_X1W, tpl5_X2D, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl9_B7
        } } in
    let {
      $dResize_swsP :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_swsP =
        case tpl1_X25
        of _ [Occ=Dead]
        { (tpl3_X1S, tpl4_X1U, tpl5_X2F, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl8_B6
        } } in
    let {
      $dBounded_swsR
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_swsR =
        case tpl1_X25
        of _ [Occ=Dead]
        { (tpl3_X1O, tpl4_X1Q, tpl5_X2H, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
        tpl3_X1O
        } } in
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl2_B3
       (let {
          $dBits1_swsK :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits1_swsK =
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl3_X22, tpl4_X24, tpl5_X5q, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl7_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits1_swsK,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl3_X45, tpl4_X7s, tpl5_X5r, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl5_X5r
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl3_X7p, tpl4_X48, tpl5_X5r, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl6_B4
            },
            $dBits1_swsK,
            $dResize_swsP,
            $dKnownNat1_swsO,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl3_X7p, tpl4_X7s, tpl5_X5r, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl10_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl3_X7p, tpl4_X7s, tpl5_X5r, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl13_Bb
            },
            case tpl_X23
            of _ [Occ=Dead]
            { (tpl3_X7p, tpl4_X7s, tpl5_X5r, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl14_Bc
            })
           eta_X1J)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)))
       (let {
          $dBits1_swsQ :: Data.Bits.Bits (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          $dBits1_swsQ =
            case tpl1_X25
            of _ [Occ=Dead]
            { (tpl3_X1Q, tpl4_X1S, tpl5_X2J, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl7_B5
            } } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           ($dBounded_swsR,
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits1_swsQ,
            case tpl1_X25
            of _ [Occ=Dead]
            { (tpl3_X7m, tpl4_X7p, tpl5_X5o, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl5_X5o
            },
            case tpl1_X25
            of _ [Occ=Dead]
            { (tpl3_X7m, tpl4_X7p, tpl5_X5o, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl6_B4
            },
            $dBits1_swsQ,
            $dResize_swsP,
            $dKnownNat1_swsO,
            case tpl1_X25
            of _ [Occ=Dead]
            { (tpl3_X7m, tpl4_X7p, tpl5_X5o, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl10_B8
            },
            $dBits_swsN,
            $dKnownNat_swsM,
            case tpl1_X25
            of _ [Occ=Dead]
            { (tpl3_X7m, tpl4_X7p, tpl5_X5o, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl13_Bb
            },
            case tpl1_X25
            of _ [Occ=Dead]
            { (tpl3_X7m, tpl4_X7p, tpl5_X5o, tpl6_B4, tpl7_B5, tpl8_B6, tpl9_B7, tpl10_B8, tpl11_B9, tpl12_Ba, tpl13_Bb, tpl14_Bc) ->
            tpl14_Bc
            })
           eta1_X3r)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1))))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[GblId[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
             (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
             (@ (size1_auHf :: GHC.TypeLits.Nat))
             (@ (frac2_auHg :: GHC.TypeLits.Nat))
             (@ (size2_auHh :: GHC.TypeLits.Nat))
             (tup_avDN
                :: CLaSH.Sized.Fixed.AddFixed
                     rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
       CLaSH.Class.Num.D:Add TYPE CLaSH.Sized.Fixed.Fixed
                                    frac1_auHd rep_auHe size1_auHf
                             TYPE CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
                             CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN
                             CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus
                               @ frac1_auHd
                               @ rep_auHe
                               @ size1_auHf
                               @ frac2_auHg
                               @ size2_auHh
                               tup_avDN]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_avDN
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      (CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)
      (CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus
         @ frac1_auHd
         @ rep_auHe
         @ size1_auHf
         @ frac2_auHg
         @ size2_auHh
         tup_avDN)

CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 130 0}]
CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1I :: GHC.Integer.Type.Integer) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl1_X1N, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
    case tpl1_X1N
    of _ [Occ=Dead]
    { (tpl6_X1M, tpl7_X1O, tpl8_X3i, tpl9_X3k, tpl10_X3m, tpl11_X3o, tpl12_B7, tpl13_B8, tpl14_B9, tpl15_Ba, tpl16_Bb, tpl17_Bc) ->
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0)
       tpl14_B9
       (GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl2_B3 eta_X1I)
       (case GHC.Integer.Type.integerToInt
               (tpl15_Ba
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild2_akCB { __DEFAULT ->
        GHC.Types.I# wild2_akCB
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

CLaSH.Sized.Fixed.$fNumFixed1
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [20 0] 40 0}]
CLaSH.Sized.Fixed.$fNumFixed1 =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_avBm
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_X1J
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_avBm
    of _ [Occ=Dead]
    { (tpl_X1L, tpl1_X1N, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl2_B3
      (eta_X1J
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

CLaSH.Sized.Fixed.$fNumFixed_$cabs
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
CLaSH.Sized.Fixed.$fNumFixed_$cabs =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_XvDa
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_X1Q
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup1_swsw :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId, Str=DmdType]
      tup1_swsw =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1X, tpl1_X1Z, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        tpl_X1X
        } } in
    let {
      $dKnownNat_swsv
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsv =
        case tup1_swsw
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl1_X21, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl7_B8
        } } in
    let {
      tup2_swsy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId, Str=DmdType]
      tup2_swsy =
        case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X1T, tpl1_X1V, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        tpl1_X1V
        } } in
    let {
      $dKnownNat1_swsx :: GHC.TypeLits.KnownNat size_XuIN
      [LclId, Str=DmdType]
      $dKnownNat1_swsx =
        case tup2_swsy
        of _ [Occ=Dead]
        { (tpl_X1V, tpl1_X1X, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl6_B7
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIL
       @ size_XuIN
       (case tup1_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl_X20
        },
        case tup1_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl1_X22
        },
        case tup1_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl2_B3
        },
        case tup1_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl3_B4
        },
        case tup1_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl4_B5
        },
        case tup1_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl5_B6
        },
        $dKnownNat1_swsx,
        $dKnownNat_swsv,
        case tup2_swsy
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl_X20
        },
        case tup1_swsw
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl9_Ba
        })
       (case tup_XvDa
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
          tpl3_B4
          (case tup2_swsy
           of _ [Occ=Dead]
           { (tpl6_X7i, tpl7_X7l, tpl8_X5n, tpl9_X5p, tpl10_X5r, tpl11_X5t, tpl12_B7, tpl13_B8, tpl14_B9, tpl15_Ba, tpl16_Bb, tpl17_Bc) ->
           (tpl11_X5t
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                    :: CLaSH.Class.Num.Resize rep_XuIL
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
             @ size_XuIN
             @ (size_XuIN GHC.TypeLits.+ 2)
             $dKnownNat1_swsx
             $dKnownNat_swsv
             (eta_X1Q
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                           ~#
                         rep_XuIL size_XuIN))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

CLaSH.Sized.Fixed.$fNumFixed_$cnegate
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0] 253 0}]
CLaSH.Sized.Fixed.$fNumFixed_$cnegate =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_XvDb
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_X1R
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup1_swso :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId, Str=DmdType]
      tup1_swso =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl1_X20, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        tpl_X1Y
        } } in
    let {
      $dKnownNat_swsn
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swsn =
        case tup1_swso
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl7_B8
        } } in
    let {
      tup2_swsq
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId, Str=DmdType]
      tup2_swsq =
        case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X1U, tpl1_X1W, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        tpl1_X1W
        } } in
    let {
      $dKnownNat1_swsp :: GHC.TypeLits.KnownNat size_XuIO
      [LclId, Str=DmdType]
      $dKnownNat1_swsp =
        case tup2_swsq
        of _ [Occ=Dead]
        { (tpl_X1W, tpl1_X1Y, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl6_B7
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIM
       @ size_XuIO
       (case tup1_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl1_X23, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl_X21
        },
        case tup1_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl1_X23, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl1_X23
        },
        case tup1_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl1_X23, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl2_B3
        },
        case tup1_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl1_X23, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl3_B4
        },
        case tup1_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl1_X23, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl4_B5
        },
        case tup1_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl1_X23, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl5_B6
        },
        $dKnownNat1_swsp,
        $dKnownNat_swsn,
        case tup2_swsq
        of _ [Occ=Dead]
        { (tpl_X21, tpl1_X23, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl_X21
        },
        case tup1_swso
        of _ [Occ=Dead]
        { (tpl_X21, tpl1_X23, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl9_Ba
        })
       (case tup_XvDb
        of _ [Occ=Dead]
        { (tpl_X21, tpl1_X23, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
          tpl3_B4
          (case tup2_swsq
           of _ [Occ=Dead]
           { (tpl6_X7k, tpl7_X7n, tpl8_X5o, tpl9_X5q, tpl10_X5s, tpl11_X5u, tpl12_B7, tpl13_B8, tpl14_B9, tpl15_Ba, tpl16_Bb, tpl17_Bc) ->
           (tpl11_X5u
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                    :: CLaSH.Class.Num.Resize rep_XuIM
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
             @ size_XuIO
             @ (size_XuIO GHC.TypeLits.+ 2)
             $dKnownNat1_swsp
             $dKnownNat_swsn
             (eta_X1R
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                           ~#
                         rep_XuIM size_XuIO))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

CLaSH.Sized.Fixed.$fNumFixed_$c-
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
CLaSH.Sized.Fixed.$fNumFixed_$c- =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_XvDc
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_X1T :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta1_X3L
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup1_swsf :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId, Str=DmdType]
      tup1_swsf =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X22, tpl1_X24, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        tpl_X22
        } } in
    let {
      $dKnownNat_swse
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_swse =
        case tup1_swsf
        of _ [Occ=Dead]
        { (tpl_X24, tpl1_X26, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl7_B8
        } } in
    let {
      tup2_swsi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId, Str=DmdType]
      tup2_swsi =
        case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X1W, tpl1_X1Y, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        tpl1_X1Y
        } } in
    let {
      $dKnownNat1_swsg :: GHC.TypeLits.KnownNat size_XuIP
      [LclId, Str=DmdType]
      $dKnownNat1_swsg =
        case tup2_swsi
        of _ [Occ=Dead]
        { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl6_B7
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIN
       @ size_XuIP
       (case tup1_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl1_X27, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl_X25
        },
        case tup1_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl1_X27, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl1_X27
        },
        case tup1_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl1_X27, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl2_B3
        },
        case tup1_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl1_X27, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl3_B4
        },
        case tup1_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl1_X27, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl4_B5
        },
        case tup1_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl1_X27, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl5_B6
        },
        $dKnownNat1_swsg,
        $dKnownNat_swse,
        case tup2_swsi
        of _ [Occ=Dead]
        { (tpl_X25, tpl1_X27, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl_X25
        },
        case tup1_swsf
        of _ [Occ=Dead]
        { (tpl_X25, tpl1_X27, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl9_Ba
        })
       (case tup_XvDc
        of _ [Occ=Dead]
        { (tpl_X49, tpl1_X27, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl3_B4
          (case tup2_swsi
           of _ [Occ=Dead]
           { (tpl6_X1Y, tpl7_X20, tpl8_X5s, tpl9_X5u, tpl10_X5w, tpl11_X5y, tpl12_B7, tpl13_B8, tpl14_B9, tpl15_Ba, tpl16_Bb, tpl17_Bc) ->
           (tpl11_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat1_swsg
             $dKnownNat_swse
             (eta_X1T
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
          (case tup2_swsi
           of _ [Occ=Dead]
           { (tpl6_X1Y, tpl7_X20, tpl8_X5s, tpl9_X5u, tpl10_X5w, tpl11_X5y, tpl12_B7, tpl13_B8, tpl14_B9, tpl15_Ba, tpl16_Bb, tpl17_Bc) ->
           (tpl11_X5y
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                    :: CLaSH.Class.Num.Resize rep_XuIN
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
             @ size_XuIP
             @ (size_XuIP GHC.TypeLits.+ 2)
             $dKnownNat1_swsg
             $dKnownNat_swse
             (eta1_X3L
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                           ~#
                         rep_XuIN size_XuIP))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

CLaSH.Sized.Fixed.$fNumFixed_$c*
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [40 0 0] 222 0}]
CLaSH.Sized.Fixed.$fNumFixed_$c* =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_XvDd
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_X1U :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta1_X3N
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup1_sws8
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId, Str=DmdType]
      tup1_sws8 =
        case tup_XvDd
        of _ [Occ=Dead]
        { (tpl_X1X, tpl1_X1Z, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        tpl1_X1Z
        } } in
    let {
      $dBits_sws7
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      $dBits_sws7 =
        case tup1_sws8
        of _ [Occ=Dead]
        { (tpl_X1Z, tpl1_X21, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl4_B5
        } } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      (case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl_X20
       },
       Data.Bits.$p1Bits
         @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sws7,
       case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl2_B3
       },
       case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl3_B4
       },
       $dBits_sws7,
       case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl5_B6
       },
       case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl6_B7
       },
       case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl7_B8
       },
       case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl8_B9
       },
       case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X3Z, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl9_Ba
       },
       case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl1_X42, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl10_Bb
       },
       case tup1_sws8
       of _ [Occ=Dead]
       { (tpl_X20, tpl1_X22, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
       tpl11_Bc
       })
      (case tup_XvDd
       of _ [Occ=Dead]
       { (tpl_Xk, tpl1_Xm, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
       case tpl5_B6 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw1a ->
       ((tpl4_B5
         `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                   <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                 :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                      ~#
                    (rep_XuIO size_XuIQ
                     -> rep_XuIO size_XuIQ
                     -> CLaSH.Class.Num.MResult
                          (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
          (eta_X1U
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ))
          (eta1_X3N
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                        ~#
                      rep_XuIO size_XuIQ)))
       `cast` (Sub cobox1_dw1a
               ; Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                            GHC.TypeLits.+ size_XuIQ>_N
               :: CLaSH.Class.Num.MResult
                    (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                    ~#
                  CLaSH.Sized.Fixed.Fixed
                    (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                    rep_XuIO
                    (size_XuIQ GHC.TypeLits.+ size_XuIQ))
       }
       })

CLaSH.Sized.Fixed.$fNumFixed_$c+
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId,
 Arity=3,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=3, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [60 0 0] 276 0}]
CLaSH.Sized.Fixed.$fNumFixed_$c+ =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_XvDe
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_X1V :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta1_X3P
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup1_sws1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      tup1_sws1 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X24, tpl1_X26, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        tpl_X24
        } } in
    let {
      $dKnownNat_sws0
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_sws0 =
        case tup1_sws1
        of _ [Occ=Dead]
        { (tpl_X26, tpl1_X28, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl7_B8
        } } in
    let {
      tup2_sws4
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId, Str=DmdType]
      tup2_sws4 =
        case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X1Y, tpl1_X20, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        tpl1_X20
        } } in
    let {
      $dKnownNat1_sws2 :: GHC.TypeLits.KnownNat size_XuIR
      [LclId, Str=DmdType]
      $dKnownNat1_sws2 =
        case tup2_sws4
        of _ [Occ=Dead]
        { (tpl_X22, tpl1_X24, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl6_B7
        } } in
    (CLaSH.Sized.Fixed.satN2
       @ rep_XuIP
       @ size_XuIR
       (case tup1_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl1_X29, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl_X27
        },
        case tup1_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl1_X29, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl1_X29
        },
        case tup1_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl1_X29, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl2_B3
        },
        case tup1_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl1_X29, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl3_B4
        },
        case tup1_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl1_X29, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl4_B5
        },
        case tup1_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl1_X29, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl5_B6
        },
        $dKnownNat1_sws2,
        $dKnownNat_sws0,
        case tup2_sws4
        of _ [Occ=Dead]
        { (tpl_X27, tpl1_X29, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba, tpl10_Bb, tpl11_Bc) ->
        tpl_X27
        },
        case tup1_sws1
        of _ [Occ=Dead]
        { (tpl_X27, tpl1_X29, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6, tpl6_B7, tpl7_B8, tpl8_B9, tpl9_Ba) ->
        tpl9_Ba
        })
       (case tup_XvDe
        of _ [Occ=Dead]
        { (tpl_X4d, tpl1_X29, tpl2_B3, tpl3_B4, tpl4_B5, tpl5_B6) ->
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl3_B4
          (case tup2_sws4
           of _ [Occ=Dead]
           { (tpl6_X20, tpl7_X22, tpl8_X5u, tpl9_X5w, tpl10_X5y, tpl11_X5A, tpl12_B7, tpl13_B8, tpl14_B9, tpl15_Ba, tpl16_Bb, tpl17_Bc) ->
           (tpl11_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat1_sws2
             $dKnownNat_sws0
             (eta_X1V
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
          (case tup2_sws4
           of _ [Occ=Dead]
           { (tpl6_X20, tpl7_X22, tpl8_X5u, tpl9_X5w, tpl10_X5y, tpl11_X5A, tpl12_B7, tpl13_B8, tpl14_B9, tpl15_Ba, tpl16_Bb, tpl17_Bc) ->
           (tpl11_X5A
            `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                    :: CLaSH.Class.Num.Resize rep_XuIP
                         ~#
                       (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                        (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                        rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
             @ size_XuIR
             @ (size_XuIR GHC.TypeLits.+ 2)
             $dKnownNat1_sws2
             $dKnownNat_sws0
             (eta1_X3P
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR))
           })
        }))
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[GblId[DFunId],
 Arity=1,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
             (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIS :: GHC.TypeLits.Nat))
             (tup_XvDf
                :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
       GHC.Num.D:Num TYPE CLaSH.Sized.Fixed.Fixed
                            frac_XuIO rep_XuIQ size_XuIS
                     CLaSH.Sized.Fixed.$fNumFixed_$c+
                       @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     CLaSH.Sized.Fixed.$fNumFixed_$c*
                       @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     CLaSH.Sized.Fixed.$fNumFixed_$c-
                       @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     CLaSH.Sized.Fixed.$fNumFixed_$cnegate
                       @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     CLaSH.Sized.Fixed.$fNumFixed_$cabs
                       @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf
                     (CLaSH.Sized.Fixed.$fNumFixed1
                        @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
                     `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                             -> Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                             :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> rep_XuIQ size_XuIS)
                                  ~#
                                (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                                 -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS))
                     CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger
                       @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_XvDf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      (CLaSH.Sized.Fixed.$fNumFixed_$c+
         @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      (CLaSH.Sized.Fixed.$fNumFixed_$c*
         @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      (CLaSH.Sized.Fixed.$fNumFixed_$c-
         @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      (CLaSH.Sized.Fixed.$fNumFixed_$cnegate
         @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      (CLaSH.Sized.Fixed.$fNumFixed_$cabs
         @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
      ((CLaSH.Sized.Fixed.$fNumFixed1
          @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)
       `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
               :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> rep_XuIQ size_XuIS)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)))
      (CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger
         @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_XvDf)

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
             (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIR :: GHC.TypeLits.Nat))
             ($dBitVector_XvCT
                :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
       CLaSH.Class.BitVector.D:BitVector TYPE CLaSH.Sized.Fixed.Fixed
                                                frac_XuIN rep_XuIP size_XuIR
                                         (\ ($dKnownNat_avB0
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (ds_dw0H
                                               :: CLaSH.Sized.Fixed.Fixed
                                                    frac_XuIN rep_XuIP size_XuIR) ->
                                            CLaSH.Class.BitVector.toBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avB0
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (ds_dw0H
                                               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                                                       :: CLaSH.Sized.Fixed.Fixed
                                                            frac_XuIN rep_XuIP size_XuIR
                                                            ~#
                                                          rep_XuIP size_XuIR)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR>_R
                                                 -> (CLaSH.Sized.Vector.Vec
                                                       (Sym
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))
                                                       <CLaSH.Bit.Bit>_R)_R
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Fixed.Fixed
                                                       frac_XuIN rep_XuIP size_XuIR
                                                     -> CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Class.BitVector.BitSize
                                                             (CLaSH.Sized.Fixed.Fixed
                                                                frac_XuIN rep_XuIP size_XuIR))
                                                          CLaSH.Bit.Bit))
                                         (\ ($dKnownNat_avBa
                                               :: GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR)))
                                            (bv_auGX
                                               :: CLaSH.Sized.Vector.Vec
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))
                                                    CLaSH.Bit.Bit) ->
                                            CLaSH.Class.BitVector.fromBV
                                              @ (rep_XuIP size_XuIR)
                                              $dBitVector_XvCT
                                              ($dKnownNat_avBa
                                               `cast` ((GHC.TypeLits.KnownNat
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N))_R
                                                       :: GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            ~#
                                                          GHC.TypeLits.KnownNat
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))))
                                              (bv_auGX
                                               `cast` ((CLaSH.Sized.Vector.Vec
                                                          (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                                                             <frac_XuIN>_N
                                                             <rep_XuIP>_N
                                                             <size_XuIR>_N)
                                                          <CLaSH.Bit.Bit>_R)_R
                                                       :: CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (CLaSH.Sized.Fixed.Fixed
                                                                  frac_XuIN rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit
                                                            ~#
                                                          CLaSH.Sized.Vector.Vec
                                                            (CLaSH.Class.BitVector.BitSize
                                                               (rep_XuIP size_XuIR))
                                                            CLaSH.Bit.Bit)))
                                         `cast` (<GHC.TypeLits.KnownNat
                                                    (CLaSH.Class.BitVector.BitSize
                                                       (CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))>_R
                                                 -> <CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit>_R
                                                 -> Sym
                                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                                         <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                                                 :: (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> rep_XuIP size_XuIR)
                                                      ~#
                                                    (GHC.TypeLits.KnownNat
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR)) =>
                                                     CLaSH.Sized.Vector.Vec
                                                       (CLaSH.Class.BitVector.BitSize
                                                          (CLaSH.Sized.Fixed.Fixed
                                                             frac_XuIN rep_XuIP size_XuIR))
                                                       CLaSH.Bit.Bit
                                                     -> CLaSH.Sized.Fixed.Fixed
                                                          frac_XuIN rep_XuIP size_XuIR))]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_XvCT
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    let {
      lvl1_sxay
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
           -> rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      lvl1_sxay =
        CLaSH.Class.BitVector.fromBV
          @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
    let {
      lvl2_sxax
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           rep_XuIP size_XuIR
           -> CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      lvl2_sxax =
        CLaSH.Class.BitVector.toBV
          @ (rep_XuIP size_XuIR) $dBitVector_XvCT } in
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      ((\ ($dKnownNat_avB0
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (ds_dw0H
             :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
          lvl2_sxax
            ($dKnownNat_avB0
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (ds_dw0H
             `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                     :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                          ~#
                        rep_XuIP size_XuIR)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
               -> (CLaSH.Sized.Vector.Vec
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                     <CLaSH.Bit.Bit>_R)_R
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                   -> CLaSH.Sized.Vector.Vec
                        (CLaSH.Class.BitVector.BitSize
                           (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                        CLaSH.Bit.Bit)))
      ((\ ($dKnownNat_avBa
             :: GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
          (bv_auGX
             :: CLaSH.Sized.Vector.Vec
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                  CLaSH.Bit.Bit) ->
          lvl1_sxay
            ($dKnownNat_avBa
             `cast` ((GHC.TypeLits.KnownNat
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                     :: GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          ~#
                        GHC.TypeLits.KnownNat
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
            (bv_auGX
             `cast` ((CLaSH.Sized.Vector.Vec
                        (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                           <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                        <CLaSH.Bit.Bit>_R)_R
                     :: CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize
                             (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit
                          ~#
                        CLaSH.Sized.Vector.Vec
                          (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                          CLaSH.Bit.Bit)))
       `cast` (<GHC.TypeLits.KnownNat
                  (CLaSH.Class.BitVector.BitSize
                     (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
               -> <CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit>_R
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
               :: (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> rep_XuIP size_XuIR)
                    ~#
                  (GHC.TypeLits.KnownNat
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                   CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                     CLaSH.Bit.Bit
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))

CLaSH.Sized.Fixed.$fDefaultFixed1
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.$fDefaultFixed1 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_avAe
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_avAe

CLaSH.Sized.Fixed.$fDefaultFixed_$cdef
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[GblId,
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.$fDefaultFixed_$cdef =
  CLaSH.Sized.Fixed.$fDefaultFixed1
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[GblId[DFunId(nt)],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= CLaSH.Sized.Fixed.$fDefaultFixed_$cdef
               `cast` (forall (frac_XuIM :: GHC.TypeLits.Nat)
                              (rep_XuIO :: GHC.TypeLits.Nat -> *)
                              (size_XuIQ :: GHC.TypeLits.Nat).
                       <Data.Default.Class.Default (rep_XuIO size_XuIQ)>_R
                       -> Sym
                            (Data.Default.Class.NTCo:Default[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ>_N)
                       :: (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
                            ~#
                          (forall (frac_XuIM :: GHC.TypeLits.Nat)
                                  (rep_XuIO :: GHC.TypeLits.Nat -> *)
                                  (size_XuIQ :: GHC.TypeLits.Nat).
                           Data.Default.Class.Default (rep_XuIO size_XuIQ) =>
                           Data.Default.Class.Default
                             (CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)))}]
CLaSH.Sized.Fixed.$fDefaultFixed =
  CLaSH.Sized.Fixed.$fDefaultFixed1
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
             (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
             (@ (size_XuJ0 :: GHC.TypeLits.Nat))
             ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
       GHC.Enum.D:Bounded TYPE CLaSH.Sized.Fixed.Fixed
                                 frac_XuIW rep_XuIY size_XuJ0
                          (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
                          (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
                          `cast` (Sym
                                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                       <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                                  :: rep_XuIY size_XuJ0
                                       ~#
                                     CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_XvCa :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      ((GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))
      ((GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_XvCa)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
               :: rep_XuIY size_XuJ0
                    ~#
                  CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0))

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[GblId[DFunId[1]],
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
             (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIz :: GHC.TypeLits.Nat))
             ($dEq_XvB3
                :: GHC.Classes.Eq
                     (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
             ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
       GHC.Classes.D:Ord TYPE CLaSH.Sized.Fixed.Fixed
                                frac_XuIv rep_XuIx size_XuIz
                         $dEq_XvB3
                         (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Ordering>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Ordering))
                         (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> <GHC.Types.Bool>_R
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> GHC.Types.Bool))
                         (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
                         (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
                         `cast` (Sym
                                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                      <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 -> Sym
                                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                         <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                                 :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                                      ~#
                                    (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                                     -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_XvB3
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_XvB5 :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_XvB3
      ((GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Ordering>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Ordering)))
      ((GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> GHC.Types.Bool)))
      ((GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))
      ((GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_XvB5)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
               :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                   -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)))

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=DFun: \ (@ (frac_XuII :: GHC.TypeLits.Nat))
             (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
             (@ (size_XuIM :: GHC.TypeLits.Nat))
             ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
       GHC.Classes.D:Eq TYPE CLaSH.Sized.Fixed.Fixed
                               frac_XuII rep_XuIK size_XuIM
                        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))
                        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
                        `cast` (Sym
                                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> Sym
                                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                                -> <GHC.Types.Bool>_R
                                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                                     ~#
                                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                                    -> GHC.Types.Bool))]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_XvAL :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      ((GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))
      ((GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_XvAL)
       `cast` (Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
               -> <GHC.Types.Bool>_R
               :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                    ~#
                  (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                   -> GHC.Types.Bool)))

CLaSH.Sized.Fixed.$fLiftFixed12
  :: Language.Haskell.TH.Syntax.NameFlavour
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 40}]
CLaSH.Sized.Fixed.$fLiftFixed12 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (CLaSH.Sized.Fixed.$fLiftFixed6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (CLaSH.Sized.Fixed.$fLiftFixed5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

CLaSH.Sized.Fixed.$fLiftFixed11 :: Language.Haskell.TH.Syntax.Name
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
CLaSH.Sized.Fixed.$fLiftFixed11 =
  Language.Haskell.TH.Syntax.Name
    (CLaSH.Sized.Fixed.$fLiftFixed7
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    CLaSH.Sized.Fixed.$fLiftFixed12

CLaSH.Sized.Fixed.$fLiftFixed10 :: Language.Haskell.TH.Syntax.Type
[GblId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 20}]
CLaSH.Sized.Fixed.$fLiftFixed10 =
  Language.Haskell.TH.Syntax.ConT CLaSH.Sized.Fixed.$fLiftFixed11

CLaSH.Sized.Fixed.$fLiftFixed9
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[GblId,
 Arity=1,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=1, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [30] 50 0}]
CLaSH.Sized.Fixed.$fLiftFixed9 =
  \ (@ (m_a4Ni :: * -> *))
    (eta_a4Nj :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    GHC.Base.return
      @ m_a4Ni
      (Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_a4Nj)
      @ Language.Haskell.TH.Syntax.Type
      CLaSH.Sized.Fixed.$fLiftFixed10

Rec {
CLaSH.Sized.Fixed.$fLiftFixed_lgo [Occ=LoopBreaker]
  :: Language.Haskell.TH.Lib.TypeQ
     -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <L,U><S,1*U>,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=2, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 30] 80 0}]
CLaSH.Sized.Fixed.$fLiftFixed_lgo =
  \ (z_awhM :: Language.Haskell.TH.Lib.TypeQ)
    (ds_awhN :: [Language.Haskell.TH.Lib.TypeQ]) ->
    case ds_awhN of _ [Occ=Dead] {
      [] -> z_awhM;
      : x_awhS xs_awhT ->
        CLaSH.Sized.Fixed.$fLiftFixed_lgo
          ((Language.Haskell.TH.Lib.appT1 z_awhM x_awhS)
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          xs_awhT
    }
end Rec }

CLaSH.Sized.Fixed.$fLiftFixed8 :: Language.Haskell.TH.Syntax.Name
[GblId,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [] 10 30}]
CLaSH.Sized.Fixed.$fLiftFixed8 =
  Language.Haskell.TH.Syntax.Name
    ((GHC.Types.[] @ GHC.Types.Char)
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    Language.Haskell.TH.Syntax.NameS

CLaSH.Sized.Fixed.$fLiftFixed1
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[GblId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=5, Value=True,
         ConLike=True, WorkFree=True, Expandable=True, Guidance=NEVER}]
CLaSH.Sized.Fixed.$fLiftFixed1 =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_avAq
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_avAr :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat1_avAs :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_avAt :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_auGR :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    let {
      w1_akV2 :: Language.Haskell.TH.Lib.TypeQ
      [LclId, Str=DmdType]
      w1_akV2 =
        CLaSH.Sized.Fixed.$fLiftFixed_lgo
          (CLaSH.Sized.Fixed.$fLiftFixed9
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          (GHC.Types.:
             @ Language.Haskell.TH.Lib.TypeQ
             (let {
                l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                [LclId, Str=DmdType]
                l_a5DZ =
                  Language.Haskell.TH.Lib.numTyLit
                    ($dKnownNat_avAr
                     `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                             ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                             :: GHC.TypeLits.KnownNat frac_auGO
                                  ~#
                                GHC.Integer.Type.Integer)) } in
              (\ (@ (m_a5E0 :: * -> *))
                 (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                 GHC.Base.fmap
                   @ m_a5E0
                   (Control.Applicative.$p1Applicative
                      @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                   @ Language.Haskell.TH.Syntax.TyLit
                   @ Language.Haskell.TH.Syntax.Type
                   Language.Haskell.TH.Syntax.LitT
                   ((l_a5DZ
                     `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <Language.Haskell.TH.Syntax.TyLit>_N
                             :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                  ~#
                                (forall (m_a4LE :: * -> *).
                                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                 m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                      @ m_a5E0 eta_a5E1))
              `cast` (Sym
                        (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <Language.Haskell.TH.Syntax.Type>_N)
                      :: (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Type)
                           ~#
                         Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
             (GHC.Types.:
                @ Language.Haskell.TH.Lib.TypeQ
                (let {
                   x_X4Ts :: Language.Haskell.TH.Syntax.Name
                   [LclId, Str=DmdType]
                   x_X4Ts =
                     case ($dTypeable_avAt
                           `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                                     <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                                   :: Data.Typeable.Internal.Typeable rep_auGP
                                        ~#
                                      (GHC.Prim.Proxy# rep_auGP -> Data.Typeable.Internal.TypeRep)))
                            (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP)
                     of _ [Occ=Dead]
                     { Data.Typeable.Internal.TypeRep ww1_awCq ww2_awCr ww3_awCs
                                                      ww4_awCt ->
                     case GHC.List.reverse1
                            @ GHC.Types.Char
                            (Data.Typeable.Internal.$w$cshowsPrec
                               GHC.Show.shows27 ww3_awCs ww4_awCt (GHC.Types.[] @ GHC.Types.Char))
                            (GHC.Types.[] @ GHC.Types.Char)
                     of _ [Occ=Dead] {
                       [] -> CLaSH.Sized.Fixed.$fLiftFixed8;
                       : ds_a5Fa rev_a5Fb ->
                         case ds_a5Fa of wild22_a5Fd { GHC.Types.C# ds1_a5Ff ->
                         case ds1_a5Ff of _ [Occ=Dead] {
                           __DEFAULT ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    wild22_a5Fd (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of _ [Occ=Dead] { (# ww6_a5Aw, ww7_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww6_a5Aw ww7_a5Ax
                             };
                           '.' ->
                             case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                    wild22_a5Fd (GHC.Types.[] @ GHC.Types.Char) rev_a5Fb
                             of _ [Occ=Dead] { (# ww6_a5Aw, ww7_a5Ax #) ->
                             Language.Haskell.TH.Syntax.Name ww6_a5Aw ww7_a5Ax
                             }
                         }
                         }
                     }
                     } } in
                 let {
                   lvl1_sxaD :: Language.Haskell.TH.Syntax.Type
                   [LclId, Str=DmdType]
                   lvl1_sxaD = Language.Haskell.TH.Syntax.ConT x_X4Ts } in
                 (\ (@ (m_X4Tv :: * -> *))
                    (eta_X4Tx :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
                    GHC.Base.return
                      @ m_X4Tv
                      (Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_X4Tx)
                      @ Language.Haskell.TH.Syntax.Type
                      lvl1_sxaD)
                 `cast` (Sym
                           (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.Type>_N)
                         :: (forall (m_a4LE :: * -> *).
                             Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                             m_a4LE Language.Haskell.TH.Syntax.Type)
                              ~#
                            Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                (GHC.Types.:
                   @ Language.Haskell.TH.Lib.TypeQ
                   (let {
                      l_a5DZ :: Language.Haskell.TH.Lib.TyLitQ
                      [LclId, Str=DmdType]
                      l_a5DZ =
                        Language.Haskell.TH.Lib.numTyLit
                          ($dKnownNat1_avAs
                           `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                                   ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                                   :: GHC.TypeLits.KnownNat size_auGQ
                                        ~#
                                      GHC.Integer.Type.Integer)) } in
                    (\ (@ (m_a5E0 :: * -> *))
                       (eta_a5E1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
                       GHC.Base.fmap
                         @ m_a5E0
                         (Control.Applicative.$p1Applicative
                            @ m_a5E0 (Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_a5E1))
                         @ Language.Haskell.TH.Syntax.TyLit
                         @ Language.Haskell.TH.Syntax.Type
                         Language.Haskell.TH.Syntax.LitT
                         ((l_a5DZ
                           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <Language.Haskell.TH.Syntax.TyLit>_N
                                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                        ~#
                                      (forall (m_a4LE :: * -> *).
                                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                       m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                            @ m_a5E0 eta_a5E1))
                    `cast` (Sym
                              (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                 <Language.Haskell.TH.Syntax.Type>_N)
                            :: (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.Type)
                                 ~#
                               Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)))) } in
    let {
      w2_acZp :: Language.Haskell.TH.Lib.ExpQ
      [LclId, Str=DmdType]
      w2_acZp =
        ($dLift_avAq
         `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                   <rep_auGP size_auGQ>_N
                 :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                      ~#
                    (rep_auGP size_auGQ
                     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
          (f_auGR
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                        ~#
                      rep_auGP size_auGQ)) } in
    \ (@ (m_akV3 :: * -> *))
      (w3_akV4 :: Language.Haskell.TH.Syntax.Quasi m_akV3) ->
      case w3_akV4
      of ww_akV5
      { Language.Haskell.TH.Syntax.D:Quasi ww1_akV7 ww2_akV8 ww3_akV9
                                           ww4_akVa ww5_akVb ww6_akVc ww7_akVd ww8_akVe ww9_akVf
                                           ww10_akVg ww11_akVh ww12_akVi ww13_akVj ww14_akVk
                                           ww15_akVl ww16_akVm ww17_akVn ww18_akVo ->
      case ww1_akV7
      of _ [Occ=Dead]
      { GHC.Base.D:Monad ww20_akVt ww21_akVu ww22_akVv ww23_akVw ->
      let {
        lvl1_sxaG :: m_akV3 Language.Haskell.TH.Syntax.Type
        [LclId, Str=DmdType]
        lvl1_sxaG =
          (w1_akV2
           `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                     <Language.Haskell.TH.Syntax.Type>_N
                   :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
                        ~#
                      (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)))
            @ m_akV3 ww_akV5 } in
      ww20_akVt
        @ Language.Haskell.TH.Syntax.Exp
        @ Language.Haskell.TH.Syntax.Exp
        (let {
           lvl2_sxaF :: m_akV3 Language.Haskell.TH.Syntax.Exp
           [LclId, Str=DmdType]
           lvl2_sxaF =
             (w2_acZp
              `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Exp>_N
                      :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
                           ~#
                         (forall (m_a4LE :: * -> *).
                          Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                          m_a4LE Language.Haskell.TH.Syntax.Exp)))
               @ m_akV3 ww_akV5 } in
         ww20_akVt
           @ Language.Haskell.TH.Syntax.Exp
           @ Language.Haskell.TH.Syntax.Exp
           (ww22_akVv
              @ Language.Haskell.TH.Syntax.Exp CLaSH.Sized.Fixed.$fLiftFixed2)
           (\ (x_acZW :: Language.Haskell.TH.Syntax.Exp) ->
              ww20_akVt
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                lvl2_sxaF
                (\ (x1_acZX :: Language.Haskell.TH.Syntax.Exp) ->
                   ww22_akVv
                     @ Language.Haskell.TH.Syntax.Exp
                     (Language.Haskell.TH.Syntax.AppE x_acZW x1_acZX))))
        (\ (x_akVz :: Language.Haskell.TH.Syntax.Exp) ->
           ww20_akVt
             @ Language.Haskell.TH.Syntax.Type
             @ Language.Haskell.TH.Syntax.Exp
             lvl1_sxaG
             (\ (x1_akVA :: Language.Haskell.TH.Syntax.Type) ->
                ww22_akVv
                  @ Language.Haskell.TH.Syntax.Exp
                  (Language.Haskell.TH.Syntax.SigE x_akVz x1_akVA)))
      }
      }

CLaSH.Sized.Fixed.$fLiftFixed_$clift
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[GblId,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Arity=0, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=True,boring_ok=True)}]
CLaSH.Sized.Fixed.$fLiftFixed_$clift =
  CLaSH.Sized.Fixed.$fLiftFixed1
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[GblId[DFunId(nt)],
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=InlineStable, TopLvl=True, Arity=4, Value=True,
         ConLike=True, WorkFree=True, Expandable=True,
         Guidance=ALWAYS_IF(unsat_ok=False,boring_ok=True)
         Tmpl= CLaSH.Sized.Fixed.$fLiftFixed_$clift
               `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                              (rep_XuMX :: GHC.TypeLits.Nat -> *)
                              (size_XuMZ :: GHC.TypeLits.Nat).
                       <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
                       -> <GHC.TypeLits.KnownNat frac_XuMV>_R
                       -> <GHC.TypeLits.KnownNat size_XuMZ>_R
                       -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
                       -> Sym
                            (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                               <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
                       :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
                           -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)
                            ~#
                          (forall (frac_XuMV :: GHC.TypeLits.Nat)
                                  (rep_XuMX :: GHC.TypeLits.Nat -> *)
                                  (size_XuMZ :: GHC.TypeLits.Nat).
                           (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
                            GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
                            Data.Typeable.Internal.Typeable rep_XuMX) =>
                           Language.Haskell.TH.Syntax.Lift
                             (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))}]
CLaSH.Sized.Fixed.$fLiftFixed =
  CLaSH.Sized.Fixed.$fLiftFixed1
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))


------ Local rules for imported ids --------
"SPEC GHC.Real.^ [GHC.Types.Double, GHC.Integer.Type.Integer]" [1]
    forall ($dNum_swu4 :: GHC.Num.Num GHC.Types.Double)
           ($dIntegral_swu5 :: GHC.Real.Integral GHC.Integer.Type.Integer).
      GHC.Real.^ @ GHC.Types.Double
                 @ GHC.Integer.Type.Integer
                 $dNum_swu4
                 $dIntegral_swu5
      = CLaSH.Sized.Fixed.$s^


*** CorePrep:

==================== CorePrep ====================
Result size of CorePrep
  = {terms: 2,838, types: 10,385, coercions: 947}

lvl_rxjb :: [GHC.Types.Char]
[GblId, Str=DmdType]
lvl_rxjb = GHC.CString.unpackCString# "Negative exponent"#

CLaSH.Sized.Fixed.$s^1 :: GHC.Types.Double
[GblId, Str=DmdType b]
CLaSH.Sized.Fixed.$s^1 = GHC.Err.error @ GHC.Types.Double lvl_rxjb

CLaSH.Sized.Fixed.$s^2 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$s^2 = GHC.Types.D# 1.0

CLaSH.Sized.Fixed.$fShowFixed4 :: GHC.Integer.Type.Integer
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed4 = GHC.Integer.Type.S# 1

CLaSH.Sized.Fixed.$fShowFixed5 :: GHC.Integer.Type.Integer
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed5 = GHC.Integer.Type.S# 2

Rec {
CLaSH.Sized.Fixed.$s^_g1 [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$s^_g1 =
  \ (x1_sxjc :: GHC.Types.Double)
    (y1_sxjd :: GHC.Integer.Type.Integer)
    (z_sxje [Occ=Once*] :: GHC.Types.Double) ->
    case GHC.Integer.Type.remInteger y1_sxjd GHC.Real.even2
    of sat_sxjf { __DEFAULT ->
    case GHC.Integer.Type.eqInteger# sat_sxjf GHC.Real.even1
    of wild_sxjg { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_sxjg
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger#
               y1_sxjd CLaSH.Sized.Fixed.$fShowFixed4
        of wild1_sxji { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1_sxji
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              sat_sxjn [Occ=Once] :: GHC.Types.Double
              [LclId, Str=DmdType]
              sat_sxjn = GHC.Float.timesDouble x1_sxjc z_sxje } in
            let {
              sat_sxjm [Occ=Once] :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              sat_sxjm =
                case GHC.Integer.Type.minusInteger
                       y1_sxjd CLaSH.Sized.Fixed.$fShowFixed4
                of sat_sxjl { __DEFAULT ->
                GHC.Integer.Type.quotInteger
                  sat_sxjl CLaSH.Sized.Fixed.$fShowFixed5
                } } in
            let {
              sat_sxjk [Occ=Once] :: GHC.Types.Double
              [LclId, Str=DmdType]
              sat_sxjk = GHC.Float.timesDouble x1_sxjc x1_sxjc } in
            CLaSH.Sized.Fixed.$s^_g1 sat_sxjk sat_sxjm sat_sxjn;
          GHC.Types.True -> GHC.Float.timesDouble x1_sxjc z_sxje
        }
        };
      GHC.Types.True ->
        let {
          sat_sxjp [Occ=Once] :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          sat_sxjp =
            GHC.Integer.Type.quotInteger
              y1_sxjd CLaSH.Sized.Fixed.$fShowFixed5 } in
        let {
          sat_sxjo [Occ=Once] :: GHC.Types.Double
          [LclId, Str=DmdType]
          sat_sxjo = GHC.Float.timesDouble x1_sxjc x1_sxjc } in
        CLaSH.Sized.Fixed.$s^_g1 sat_sxjo sat_sxjp z_sxje
    }
    }
    }
end Rec }

Rec {
CLaSH.Sized.Fixed.$s^_f [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$s^_f =
  \ (x_sxjq :: GHC.Types.Double)
    (y_sxjr :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.remInteger y_sxjr GHC.Real.even2
    of sat_sxjs { __DEFAULT ->
    case GHC.Integer.Type.eqInteger# sat_sxjs GHC.Real.even1
    of wild_sxjt { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_sxjt
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger#
               y_sxjr CLaSH.Sized.Fixed.$fShowFixed4
        of wild1_sxjv { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1_sxjv
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              sat_sxjz [Occ=Once] :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              sat_sxjz =
                case GHC.Integer.Type.minusInteger
                       y_sxjr CLaSH.Sized.Fixed.$fShowFixed4
                of sat_sxjy { __DEFAULT ->
                GHC.Integer.Type.quotInteger
                  sat_sxjy CLaSH.Sized.Fixed.$fShowFixed5
                } } in
            let {
              sat_sxjx [Occ=Once] :: GHC.Types.Double
              [LclId, Str=DmdType]
              sat_sxjx = GHC.Float.timesDouble x_sxjq x_sxjq } in
            CLaSH.Sized.Fixed.$s^_g1 sat_sxjx sat_sxjz x_sxjq;
          GHC.Types.True -> x_sxjq
        }
        };
      GHC.Types.True ->
        let {
          sat_sxjB [Occ=Once] :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          sat_sxjB =
            GHC.Integer.Type.quotInteger
              y_sxjr CLaSH.Sized.Fixed.$fShowFixed5 } in
        let {
          sat_sxjA [Occ=Once] :: GHC.Types.Double
          [LclId, Str=DmdType]
          sat_sxjA = GHC.Float.timesDouble x_sxjq x_sxjq } in
        CLaSH.Sized.Fixed.$s^_f sat_sxjA sat_sxjB
    }
    }
    }
end Rec }

CLaSH.Sized.Fixed.resizeF1 :: GHC.Integer.Type.Integer
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.resizeF1 = GHC.Integer.Type.S# 0

CLaSH.Sized.Fixed.$s^ [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$s^ =
  \ (eta_sxjC [Occ=Once] :: GHC.Types.Double)
    (eta1_sxjD :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger#
           eta1_sxjD CLaSH.Sized.Fixed.resizeF1
    of wild_sxjE { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_sxjE
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger#
               eta1_sxjD CLaSH.Sized.Fixed.resizeF1
        of wild2_sxjG { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2_sxjG
        of _ [Occ=Dead] {
          GHC.Types.False -> CLaSH.Sized.Fixed.$s^_f eta_sxjC eta1_sxjD;
          GHC.Types.True -> CLaSH.Sized.Fixed.$s^2
        }
        };
      GHC.Types.True -> CLaSH.Sized.Fixed.$s^1
    }
    }

CLaSH.Sized.Fixed.fLit8 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit8 = GHC.Types.D# 2.0

CLaSH.Sized.Fixed.$fLiftFixed7 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.$fLiftFixed7 =
  GHC.CString.unpackCString# "Fixed"#

CLaSH.Sized.Fixed.$fLiftFixed6 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.$fLiftFixed6 =
  GHC.CString.unpackCString# "clash-prelude-0.5"#

CLaSH.Sized.Fixed.$fLiftFixed5 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.$fLiftFixed5 =
  GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

CLaSH.Sized.Fixed.$fLiftFixed4
  :: Language.Haskell.TH.Syntax.NameFlavour
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed4 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (CLaSH.Sized.Fixed.$fLiftFixed6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (CLaSH.Sized.Fixed.$fLiftFixed5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

CLaSH.Sized.Fixed.$fLiftFixed3 :: Language.Haskell.TH.Syntax.Name
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed3 =
  Language.Haskell.TH.Syntax.Name
    (CLaSH.Sized.Fixed.$fLiftFixed7
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    CLaSH.Sized.Fixed.$fLiftFixed4

CLaSH.Sized.Fixed.fLit7 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.fLit7 = GHC.CString.unpackCString# "fromInteger"#

CLaSH.Sized.Fixed.fLit6 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.fLit6 = GHC.CString.unpackCString# "base"#

CLaSH.Sized.Fixed.fLit5 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.fLit5 = GHC.CString.unpackCString# "GHC.Num"#

CLaSH.Sized.Fixed.fLit4 :: Language.Haskell.TH.Syntax.NameFlavour
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit4 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (CLaSH.Sized.Fixed.fLit6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (CLaSH.Sized.Fixed.fLit5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

CLaSH.Sized.Fixed.fLit3 :: Language.Haskell.TH.Syntax.Name
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit3 =
  Language.Haskell.TH.Syntax.Name
    (CLaSH.Sized.Fixed.fLit7
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    CLaSH.Sized.Fixed.fLit4

CLaSH.Sized.Fixed.$fLiftFixed2 :: Language.Haskell.TH.Syntax.Exp
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed2 =
  Language.Haskell.TH.Syntax.ConE CLaSH.Sized.Fixed.$fLiftFixed3

CLaSH.Sized.Fixed.fLit2 :: Language.Haskell.TH.Syntax.Exp
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit2 =
  Language.Haskell.TH.Syntax.VarE CLaSH.Sized.Fixed.fLit3

CLaSH.Sized.Fixed.fLit1
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit1 =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_sxjI [Occ=Once] :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_sxjK :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_sxjL :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_sxjM [Occ=Once!] :: GHC.Types.Double) ->
    let {
      x_sxjN :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      x_sxjN =
        let {
          truncated_sxjO :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          truncated_sxjO =
            case a_sxjM of _ [Occ=Dead] { GHC.Types.D# x1_sxjQ [Occ=Once] ->
            case CLaSH.Sized.Fixed.$s^
                   CLaSH.Sized.Fixed.fLit8
                   ($dKnownNat_sxjI
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                            :: GHC.TypeLits.KnownNat frac_avhM ~# GHC.Integer.Type.Integer))
            of _ [Occ=Dead] { GHC.Types.D# y_sxjS [Occ=Once] ->
            case GHC.Prim.*## x1_sxjQ y_sxjS of sat_sxjT { __DEFAULT ->
            case GHC.Integer.Type.decodeDoubleInteger sat_sxjT
            of _ [Occ=Dead] { (# ipv_sxjV, ipv1_sxjW #) ->
            case GHC.Prim.<# ipv1_sxjW 0 of sat_sxjX { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxjX
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Integer.Type.shiftLInteger ipv_sxjV ipv1_sxjW;
              GHC.Types.True ->
                case GHC.Prim.negateInt# ipv1_sxjW of s_sxjZ { __DEFAULT ->
                case GHC.Prim.># s_sxjZ 52 of sat_sxk0 { __DEFAULT ->
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxk0
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger#
                           ipv_sxjV CLaSH.Sized.Fixed.resizeF1
                    of wild4_sxk2 { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4_sxk2
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        case GHC.Integer.Type.integerToInt ipv_sxjV
                        of n_sxk4 { __DEFAULT ->
                        case GHC.Prim.uncheckedIShiftRA# n_sxk4 s_sxjZ
                        of sat_sxk5 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger sat_sxk5
                        }
                        };
                      GHC.Types.True ->
                        case GHC.Integer.Type.negateInteger ipv_sxjV
                        of sat_sxk6 { __DEFAULT ->
                        case GHC.Integer.Type.integerToInt sat_sxk6
                        of n_sxk7 { __DEFAULT ->
                        case GHC.Prim.uncheckedIShiftRA# n_sxk7 s_sxjZ
                        of sat_sxk8 { __DEFAULT ->
                        case GHC.Prim.negateInt# sat_sxk8 of sat_sxk9 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger sat_sxk9
                        }
                        }
                        }
                        }
                    }
                    };
                  GHC.Types.True -> CLaSH.Sized.Fixed.resizeF1
                }
                }
                }
            }
            }
            }
            }
            }
            } } in
        let {
          rMax_sxka :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          rMax_sxka =
            let {
              sat_sxkb [Occ=Once] :: rep_avhN size_avhO
              [LclId, Str=DmdType]
              sat_sxkb =
                GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_sxjK } in
            GHC.Real.toInteger
              @ (rep_avhN size_avhO) $dIntegral_sxjL sat_sxkb } in
        case GHC.Integer.Type.gtInteger# truncated_sxjO rMax_sxka
        of wild_sxkc { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_sxkc
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              rMin_sxke :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              rMin_sxke =
                let {
                  sat_sxkf [Occ=Once] :: rep_avhN size_avhO
                  [LclId, Str=DmdType]
                  sat_sxkf =
                    GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_sxjK } in
                GHC.Real.toInteger
                  @ (rep_avhN size_avhO) $dIntegral_sxjL sat_sxkf } in
            case GHC.Integer.Type.ltInteger# truncated_sxjO rMin_sxke
            of wild2_sxkg { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2_sxkg
            of _ [Occ=Dead] {
              GHC.Types.False -> truncated_sxjO;
              GHC.Types.True -> rMin_sxke
            }
            };
          GHC.Types.True -> rMax_sxka
        }
        } } in
    let {
      a1_sxki :: Language.Haskell.TH.Syntax.Lit
      [LclId, Str=DmdType, Unf=OtherCon []]
      a1_sxki = Language.Haskell.TH.Syntax.IntegerL x_sxjN } in
    let {
      lvl1_sxkj [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp
      [LclId, Str=DmdType, Unf=OtherCon []]
      lvl1_sxkj = Language.Haskell.TH.Syntax.LitE a1_sxki } in
    let {
      sat_sxl0 [Occ=Once]
        :: forall (m_awx9 :: * -> *).
           Language.Haskell.TH.Syntax.Quasi m_awx9 =>
           m_awx9 (Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
      [LclId, Str=DmdType]
      sat_sxl0 =
        \ (@ (m_awx9 :: * -> *))
          (w1_sxkk [Occ=Once!] :: Language.Haskell.TH.Syntax.Quasi m_awx9) ->
          case w1_sxkk
          of _ [Occ=Dead]
          { Language.Haskell.TH.Syntax.D:Quasi ww1_sxkm [Occ=Once!]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] ->
          case ww1_sxkm
          of _ [Occ=Dead]
          { GHC.Base.D:Monad ww20_sxkF _ [Occ=Dead] ww22_sxkH _ [Occ=Dead] ->
          let {
            sat_sxkZ [Occ=Once]
              :: Language.Haskell.TH.Syntax.Exp
                 -> m_awx9 (Language.Haskell.TH.Syntax.TExp
                              (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
            [LclId, Str=DmdType]
            sat_sxkZ =
              \ (x1_sxkY [Occ=Once] :: Language.Haskell.TH.Syntax.Exp) ->
                ww22_sxkH
                  @ (Language.Haskell.TH.Syntax.TExp
                       (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
                  (x1_sxkY
                   `cast` (Sym
                             (Language.Haskell.TH.Syntax.NTCo:TExp[0]
                                <CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO>_N)
                           :: Language.Haskell.TH.Syntax.Exp
                                ~#
                              Language.Haskell.TH.Syntax.TExp
                                (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))) } in
          let {
            sat_sxkX [Occ=Once] :: m_awx9 Language.Haskell.TH.Syntax.Exp
            [LclId, Str=DmdType]
            sat_sxkX =
              let {
                lvl2_sxkJ [Occ=OnceL] :: m_awx9 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                lvl2_sxkJ =
                  let {
                    lvl3_sxkK [Occ=OnceL] :: m_awx9 Language.Haskell.TH.Syntax.Exp
                    [LclId, Str=DmdType]
                    lvl3_sxkK =
                      ww22_sxkH @ Language.Haskell.TH.Syntax.Exp lvl1_sxkj } in
                  let {
                    sat_sxkQ [Occ=Once]
                      :: Language.Haskell.TH.Syntax.Exp
                         -> m_awx9 Language.Haskell.TH.Syntax.Exp
                    [LclId, Str=DmdType]
                    sat_sxkQ =
                      \ (x1_sxkM [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp) ->
                        let {
                          sat_sxkP [Occ=Once]
                            :: Language.Haskell.TH.Syntax.Exp
                               -> m_awx9 Language.Haskell.TH.Syntax.Exp
                          [LclId, Str=DmdType]
                          sat_sxkP =
                            \ (x2_sxkN [Occ=Once] :: Language.Haskell.TH.Syntax.Exp) ->
                              let {
                                sat_sxkO [Occ=Once] :: Language.Haskell.TH.Syntax.Exp
                                [LclId, Str=DmdType]
                                sat_sxkO = Language.Haskell.TH.Syntax.AppE x1_sxkM x2_sxkN } in
                              ww22_sxkH @ Language.Haskell.TH.Syntax.Exp sat_sxkO } in
                        ww20_sxkF
                          @ Language.Haskell.TH.Syntax.Exp
                          @ Language.Haskell.TH.Syntax.Exp
                          lvl3_sxkK
                          sat_sxkP } in
                  let {
                    sat_sxkL [Occ=Once] :: m_awx9 Language.Haskell.TH.Syntax.Exp
                    [LclId, Str=DmdType]
                    sat_sxkL =
                      ww22_sxkH
                        @ Language.Haskell.TH.Syntax.Exp CLaSH.Sized.Fixed.fLit2 } in
                  ww20_sxkF
                    @ Language.Haskell.TH.Syntax.Exp
                    @ Language.Haskell.TH.Syntax.Exp
                    sat_sxkL
                    sat_sxkQ } in
              let {
                sat_sxkW [Occ=Once]
                  :: Language.Haskell.TH.Syntax.Exp
                     -> m_awx9 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                sat_sxkW =
                  \ (x1_sxkS [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp) ->
                    let {
                      sat_sxkV [Occ=Once]
                        :: Language.Haskell.TH.Syntax.Exp
                           -> m_awx9 Language.Haskell.TH.Syntax.Exp
                      [LclId, Str=DmdType]
                      sat_sxkV =
                        \ (x2_sxkT [Occ=Once] :: Language.Haskell.TH.Syntax.Exp) ->
                          let {
                            sat_sxkU [Occ=Once] :: Language.Haskell.TH.Syntax.Exp
                            [LclId, Str=DmdType]
                            sat_sxkU = Language.Haskell.TH.Syntax.AppE x1_sxkS x2_sxkT } in
                          ww22_sxkH @ Language.Haskell.TH.Syntax.Exp sat_sxkU } in
                    ww20_sxkF
                      @ Language.Haskell.TH.Syntax.Exp
                      @ Language.Haskell.TH.Syntax.Exp
                      lvl2_sxkJ
                      sat_sxkV } in
              let {
                sat_sxkR [Occ=Once] :: m_awx9 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                sat_sxkR =
                  ww22_sxkH
                    @ Language.Haskell.TH.Syntax.Exp
                    CLaSH.Sized.Fixed.$fLiftFixed2 } in
              ww20_sxkF
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                sat_sxkR
                sat_sxkW } in
          ww20_sxkF
            @ Language.Haskell.TH.Syntax.Exp
            @ (Language.Haskell.TH.Syntax.TExp
                 (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
            sat_sxkX
            sat_sxkZ
          }
          } } in
    sat_sxl0

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit =
  (\ (@ (frac_avhM :: GHC.TypeLits.Nat))
     (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
     (@ (size_avhO :: GHC.TypeLits.Nat))
     (eta_B5 [Occ=Once] :: GHC.TypeLits.KnownNat frac_avhM)
     (eta_B4 [Occ=Once] :: GHC.Num.Num (rep_avhN size_avhO))
     (eta_B3 [Occ=Once] :: GHC.Enum.Bounded (rep_avhN size_avhO))
     (eta_B2 [Occ=Once] :: GHC.Real.Integral (rep_avhN size_avhO))
     (eta_B1 [Occ=Once] :: GHC.Types.Double) ->
     CLaSH.Sized.Fixed.fLit1
       @ frac_avhM
       @ rep_avhN
       @ size_avhO
       eta_B5
       eta_B4
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_sxl1 [Occ=Once!] :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_sxl2 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    case tup_sxl1
    of _ [Occ=Dead]
    { (tpl_sxl4 [Occ=Once*], tpl1_sxl5, tpl2_sxl6 [Occ=Once*], tpl3_sxl7 [Occ=Once], tpl4_sxl8, tpl5_sxl9 [Occ=Once!], tpl6_sxla [Occ=Once*], tpl7_sxlb [Occ=Once], tpl8_sxlc [Occ=Once*], tpl9_sxld [Occ=Once]) ->
    let {
      repBV_sxle
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      repBV_sxle =
        case tpl5_sxl9 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl3_sxl7
           (tpl7_sxlb
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox1_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_sxl2)
        `cast` ((CLaSH.Sized.Vector.Vec cobox1_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        } } in
    let {
      s_sxlg :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      s_sxlg =
        case tpl1_sxl5 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw7d ->
        case CLaSH.Sized.Vector.vtail
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_sxle
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox1_dw7d) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of sat_sxli { __DEFAULT ->
        CLaSH.Sized.Vector.vtail @ n_aviz @ CLaSH.Bit.Bit sat_sxli
        }
        } } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl9_sxld eta_sxl2
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case tpl1_sxl5 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_sxle
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vtail
                   @ (n_aviz GHC.TypeLits.+ 1)
                   @ CLaSH.Bit.Bit
                   (repBV_sxle
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
            of sat_sxlm { __DEFAULT ->
            case CLaSH.Sized.Vector.vhead @ n_aviz @ CLaSH.Bit.Bit sat_sxlm
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl8_sxlc;
              CLaSH.Bit.L ->
                let {
                  sat_sxlr [Occ=Once]
                    :: CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit
                  [LclId, Str=DmdType]
                  sat_sxlr =
                    case tpl4_sxl8 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7c ->
                    s_sxlg
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox3_dw7c) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                    } } in
                let {
                  sat_sxlp [Occ=Once]
                    :: GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                  [LclId, Str=DmdType]
                  sat_sxlp =
                    case tpl4_sxl8 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7b ->
                    tpl6_sxla
                    `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw7b))_R
                            :: GHC.TypeLits.KnownNat n_aviz
                                 ~#
                               GHC.TypeLits.KnownNat
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                    } } in
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz) tpl2_sxl6 sat_sxlp sat_sxlr
            }
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vtail
                   @ (n_aviz GHC.TypeLits.+ 1)
                   @ CLaSH.Bit.Bit
                   (repBV_sxle
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
            of sat_sxls { __DEFAULT ->
            case CLaSH.Sized.Vector.vhead @ n_aviz @ CLaSH.Bit.Bit sat_sxls
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl8_sxlc;
              CLaSH.Bit.L ->
                let {
                  sat_sxlx [Occ=Once]
                    :: CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit
                  [LclId, Str=DmdType]
                  sat_sxlx =
                    case tpl4_sxl8 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7c ->
                    s_sxlg
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox3_dw7c) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                    } } in
                let {
                  sat_sxlv [Occ=Once]
                    :: GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                  [LclId, Str=DmdType]
                  sat_sxlv =
                    case tpl4_sxl8 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7b ->
                    tpl6_sxla
                    `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw7b))_R
                            :: GHC.TypeLits.KnownNat n_aviz
                                 ~#
                               GHC.TypeLits.KnownNat
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                    } } in
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz) tpl2_sxl6 sat_sxlv sat_sxlx
            }
            }
        }
        };
      GHC.Types.True ->
        case tpl1_sxl5 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_sxle
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_sxl4 s_sxlg
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                let {
                  sat_sxlE [Occ=Once]
                    :: CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit
                  [LclId, Str=DmdType]
                  sat_sxlE =
                    case tpl4_sxl8 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7a ->
                    s_sxlg
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox3_dw7a) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                    } } in
                let {
                  sat_sxlC [Occ=Once]
                    :: GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                  [LclId, Str=DmdType]
                  sat_sxlC =
                    case tpl4_sxl8 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw79 ->
                    tpl6_sxla
                    `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw79))_R
                            :: GHC.TypeLits.KnownNat n_aviz
                                 ~#
                               GHC.TypeLits.KnownNat
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                    } } in
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz) tpl2_sxl6 sat_sxlC sat_sxlE;
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl8_sxlc
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_sxl4 s_sxlg
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl8_sxlc;
              CLaSH.Bit.L ->
                let {
                  sat_sxlJ [Occ=Once]
                    :: CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit
                  [LclId, Str=DmdType]
                  sat_sxlJ =
                    case tpl4_sxl8 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7a ->
                    s_sxlg
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox3_dw7a) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                    } } in
                let {
                  sat_sxlH [Occ=Once]
                    :: GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                  [LclId, Str=DmdType]
                  sat_sxlH =
                    case tpl4_sxl8 of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw79 ->
                    tpl6_sxla
                    `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw79))_R
                            :: GHC.TypeLits.KnownNat n_aviz
                                 ~#
                               GHC.TypeLits.KnownNat
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                    } } in
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz) tpl2_sxl6 sat_sxlH sat_sxlJ
            }
        }
        }
    }
    }

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_sxlK
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_sxlL
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_sxlM :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_sxlM =
        case tup_sxlK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxlV [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_sxlV
        } } in
    let {
      $dKnownNat1_sxm0 :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat1_sxm0 =
        case tup_sxlK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxm8 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_sxm8
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_sxlM
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat1_sxm0
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_sxme { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_sxme
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case tup_sxlK
        of _ [Occ=Dead]
        { (tpl_sxmh, _ [Occ=Dead], tpl2_sxmj [Occ=Once*], tpl3_sxmk, tpl4_sxml, tpl5_sxmm, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_sxmq [Occ=Once], tpl10_sxmr [Occ=Once], _ [Occ=Dead]) ->
        case GHC.Integer.Type.integerToInt
               (tpl10_sxmr
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild3_sxmt { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl9_sxmq
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild4_sxmu { __DEFAULT ->
        let {
          fMax_sxmv :: rep_avjs size2_avju
          [LclId, Str=DmdType]
          fMax_sxmv = GHC.Enum.maxBound @ (rep_avjs size2_avju) tpl_sxmh } in
        let {
          mask_sxmw :: rep_avjs size1_avjt
          [LclId, Str=DmdType]
          mask_sxmw =
            let {
              sat_sxmx [Occ=Once] :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              sat_sxmx =
                (tpl5_sxmm
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size2_avju
                  @ size1_avjt
                  $dKnownNat1_sxm0
                  $dKnownNat_sxlM
                  fMax_sxmv } in
            Data.Bits.complement
              @ (rep_avjs size1_avjt) tpl4_sxml sat_sxmx } in
        case GHC.Prim.<=# wild3_sxmt wild4_sxmu of sat_sxmy { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxmy
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_sxmA :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedR_sxmA =
                case GHC.Prim.-# wild3_sxmt wild4_sxmu of sat_sxmB { __DEFAULT ->
                let {
                  sat_sxmC [Occ=Once] :: GHC.Types.Int
                  [LclId, Str=DmdType]
                  sat_sxmC = GHC.Types.I# sat_sxmB } in
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  tpl4_sxml
                  (eta_sxlL
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  sat_sxmC
                } } in
            let {
              sat_sxmD [Occ=Once] :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              sat_sxmD =
                GHC.Num.fromInteger
                  @ (rep_avjs size1_avjt) tpl3_sxmk CLaSH.Sized.Fixed.resizeF1 } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl2_sxmj
                   (eta_sxlL
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   sat_sxmD
            of _ [Occ=Dead] {
              GHC.Types.False ->
                let {
                  sat_sxmG [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_sxmG =
                    Data.Bits..&.
                      @ (rep_avjs size1_avjt) tpl4_sxml shiftedR_sxmA mask_sxmw } in
                case Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_sxml
                of sat_sxmF { __DEFAULT ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt) sat_sxmF sat_sxmG mask_sxmw
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) tpl_sxmh)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_sxmm
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_sxlM
                       $dKnownNat1_sxm0
                       shiftedR_sxmA)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
                };
              GHC.Types.True ->
                let {
                  sat_sxmK [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_sxmK =
                    GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) tpl3_sxmk CLaSH.Sized.Fixed.resizeF1 } in
                let {
                  sat_sxmJ [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_sxmJ =
                    Data.Bits..&.
                      @ (rep_avjs size1_avjt) tpl4_sxml shiftedR_sxmA mask_sxmw } in
                case Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_sxml
                of sat_sxmI { __DEFAULT ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt) sat_sxmI sat_sxmJ sat_sxmK
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_sxmv
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_sxmm
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_sxlM
                       $dKnownNat1_sxm0
                       shiftedR_sxmA)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_sxmM :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedL_sxmM =
                case GHC.Prim.-# wild4_sxmu wild3_sxmt of sat_sxmN { __DEFAULT ->
                let {
                  sat_sxmO [Occ=Once] :: GHC.Types.Int
                  [LclId, Str=DmdType]
                  sat_sxmO = GHC.Types.I# sat_sxmN } in
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  tpl4_sxml
                  (eta_sxlL
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  sat_sxmO
                } } in
            let {
              sat_sxmP [Occ=Once] :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              sat_sxmP =
                GHC.Num.fromInteger
                  @ (rep_avjs size1_avjt) tpl3_sxmk CLaSH.Sized.Fixed.resizeF1 } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl2_sxmj
                   (eta_sxlL
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   sat_sxmP
            of _ [Occ=Dead] {
              GHC.Types.False ->
                let {
                  sat_sxmS [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_sxmS =
                    Data.Bits..&.
                      @ (rep_avjs size1_avjt) tpl4_sxml shiftedL_sxmM mask_sxmw } in
                case Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_sxml
                of sat_sxmR { __DEFAULT ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt) sat_sxmR sat_sxmS mask_sxmw
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) tpl_sxmh)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_sxmm
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_sxlM
                       $dKnownNat1_sxm0
                       shiftedL_sxmM)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
                };
              GHC.Types.True ->
                let {
                  sat_sxmW [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_sxmW =
                    GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) tpl3_sxmk CLaSH.Sized.Fixed.resizeF1 } in
                let {
                  sat_sxmV [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_sxmV =
                    Data.Bits..&.
                      @ (rep_avjs size1_avjt) tpl4_sxml shiftedL_sxmM mask_sxmw } in
                case Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_sxml
                of sat_sxmU { __DEFAULT ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt) sat_sxmU sat_sxmV sat_sxmW
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_sxmv
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_sxmm
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_sxlM
                       $dKnownNat1_sxm0
                       shiftedL_sxmM)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
                }
            }
        }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_sxlK
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_sxn4 [Occ=Once*], _ [Occ=Dead], _ [Occ=Dead], tpl8_sxn7 [Occ=Once*], tpl9_sxn8 [Occ=Once], tpl10_sxn9 [Occ=Once], _ [Occ=Dead]) ->
        case GHC.Integer.Type.integerToInt
               (tpl10_sxn9
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild3_sxnb { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl9_sxn8
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild4_sxnc { __DEFAULT ->
        case GHC.Prim.<=# wild3_sxnb wild4_sxnc of sat_sxnd { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxnd
        of _ [Occ=Dead] {
          GHC.Types.False ->
            case GHC.Prim.-# wild3_sxnb wild4_sxnc of sat_sxng { __DEFAULT ->
            let {
              sat_sxnh [Occ=Once] :: GHC.Types.Int
              [LclId, Str=DmdType]
              sat_sxnh = GHC.Types.I# sat_sxng } in
            let {
              sat_sxnf [Occ=Once] :: rep_avjs size2_avju
              [LclId, Str=DmdType]
              sat_sxnf =
                (tpl5_sxn4
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_sxlM
                  $dKnownNat1_sxm0
                  (eta_sxlL
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)) } in
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju) tpl8_sxn7 sat_sxnf sat_sxnh)
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
            };
          GHC.Types.True ->
            case GHC.Prim.-# wild4_sxnc wild3_sxnb of sat_sxnj { __DEFAULT ->
            let {
              sat_sxnk [Occ=Once] :: GHC.Types.Int
              [LclId, Str=DmdType]
              sat_sxnk = GHC.Types.I# sat_sxnj } in
            let {
              sat_sxni [Occ=Once] :: rep_avjs size2_avju
              [LclId, Str=DmdType]
              sat_sxni =
                (tpl5_sxn4
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_sxlM
                  $dKnownNat1_sxm0
                  (eta_sxlL
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)) } in
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju) tpl8_sxn7 sat_sxni sat_sxnk)
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
            }
        }
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_sxnn [Occ=Once] :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_sxnn
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_sxnp { __DEFAULT ->
    GHC.Types.I# wild_sxnp
    }

CLaSH.Sized.Fixed.unUF1
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unUF1 =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_sxnq [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_sxnq

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unUF =
  (\ (@ (int_avkK :: GHC.TypeLits.Nat))
     (@ (frac_avkL :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)) ->
     CLaSH.Sized.Fixed.unUF1 @ int_avkK @ frac_avkL eta_B1)
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

CLaSH.Sized.Fixed.uf1
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.uf1 =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_sxns [Occ=Once]
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_sxns

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.uf =
  (\ (@ (frac_avl5 :: GHC.TypeLits.Nat))
     (@ (int_avl6 :: GHC.TypeLits.Nat))
     (eta_B2 [Occ=Once] :: CLaSH.Promoted.Nat.SNat frac_avl5)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Unsigned.Unsigned
             (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
     CLaSH.Sized.Fixed.uf1 @ frac_avl5 @ int_avl6 eta_B2 eta_B1)
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

CLaSH.Sized.Fixed.unSF1
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unSF1 =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_sxnt [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_sxnt

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unSF =
  (\ (@ (int_avlp :: GHC.TypeLits.Nat))
     (@ (frac_avlq :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)) ->
     CLaSH.Sized.Fixed.unSF1 @ int_avlp @ frac_avlq eta_B1)
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

CLaSH.Sized.Fixed.sf1
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.sf1 =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_sxnv [Occ=Once]
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_sxnv

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.sf =
  (\ (@ (frac_avlK :: GHC.TypeLits.Nat))
     (@ (int_avlL :: GHC.TypeLits.Nat))
     (eta_B2 [Occ=Once] :: CLaSH.Promoted.Nat.SNat frac_avlK)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Signed.Signed
             (int_avlL GHC.TypeLits.+ frac_avlK)) ->
     CLaSH.Sized.Fixed.sf1 @ frac_avlK @ int_avlL eta_B2 eta_B1)
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

CLaSH.Sized.Fixed.unFixed1
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unFixed1 =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_sxnw [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_sxnw

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.unFixed =
  (\ (@ (frac_auI2 :: GHC.TypeLits.Nat))
     (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
     (@ (size_auI4 :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
     CLaSH.Sized.Fixed.unFixed1
       @ frac_auI2 @ rep_auI3 @ size_auI4 eta_B1)
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

CLaSH.Sized.Fixed.$fShowFixed1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed1 = GHC.Types.C# '-'

CLaSH.Sized.Fixed.$fShowFixed3 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed3 = GHC.Types.C# '0'

CLaSH.Sized.Fixed.$fShowFixed_dt :: GHC.Integer.Type.Integer
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed_dt = GHC.Integer.Type.S# 10

CLaSH.Sized.Fixed.$fShowFixed7
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Arity=1, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed7 =
  \ (ds_sxnx
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    let {
      sat_sxnR [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      sat_sxnR =
        case ds_sxnx
        of _ [Occ=Dead] { (_ [Occ=Dead], y_sxnI [Occ=Once!]) ->
        case y_sxnI
        of _ [Occ=Dead]
        { GHC.Real.:% ww1_sxnK [Occ=Once] ww2_sxnL [Occ=Once] ->
        case GHC.Integer.Type.timesInteger ww2_sxnL GHC.Real.$fEnumRatio1
        of sat_sxnN { __DEFAULT ->
        case GHC.Integer.Type.timesInteger
               ww1_sxnK CLaSH.Sized.Fixed.$fShowFixed_dt
        of sat_sxnM { __DEFAULT ->
        case GHC.Real.$w$sreduce sat_sxnM sat_sxnN
        of _ [Occ=Dead] { (# ww7_sxnP [Occ=Once], ww8_sxnQ [Occ=Once] #) ->
        GHC.Real.:% @ GHC.Integer.Type.Integer ww7_sxnP ww8_sxnQ
        }
        }
        }
        }
        } } in
    let {
      sat_sxnF [Occ=Once] :: GHC.Types.Int
      [LclId, Str=DmdType]
      sat_sxnF =
        case ds_sxnx
        of _ [Occ=Dead] { (x_sxnz [Occ=Once!], _ [Occ=Dead]) ->
        case x_sxnz of _ [Occ=Dead] { GHC.Types.I# x1_sxnC [Occ=Once!] ->
        case x1_sxnC of wild2_sxnD {
          __DEFAULT ->
            case GHC.Prim.+# wild2_sxnD 1 of sat_sxnE { __DEFAULT ->
            GHC.Types.I# sat_sxnE
            };
          9223372036854775807 -> GHC.Enum.$fEnumInt2
        }
        }
        } } in
    (sat_sxnF, sat_sxnR)

CLaSH.Sized.Fixed.$fShowFixed6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed6 = GHC.Types.I# 0

CLaSH.Sized.Fixed.$fShowFixed8
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed8 =
  \ (x_sxnS [Occ=Once!]
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    (r_sxnT [Occ=Once*]
       :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]) ->
    case x_sxnS of wild_sxnU { (_ [Occ=Dead], y_sxnW [Occ=Once!]) ->
    case y_sxnW
    of _ [Occ=Dead] { GHC.Real.:% _ [Occ=Dead] y1_sxnZ [Occ=Once] ->
    case GHC.Integer.Type.eqInteger#
           y1_sxnZ CLaSH.Sized.Fixed.$fShowFixed4
    of wild2_sxo0 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2_sxo0
    of _ [Occ=Dead] {
      GHC.Types.False -> r_sxnT;
      GHC.Types.True ->
        GHC.Types.:
          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          wild_sxnU
          r_sxnT
    }
    }
    }
    }

CLaSH.Sized.Fixed.$fShowFixed2 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed2 = GHC.Types.C# '.'

CLaSH.Sized.Fixed.$fShowFixed_$cshow
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed_$cshow =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_sxo4 [Occ=Once] :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_sxo5 [Occ=Once]
       :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_sxo6 [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      fRepI_sxo7 :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_sxo7 =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_sxo5
          (f_sxo6
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    case GHC.Integer.Type.ltInteger#
           fRepI_sxo7 CLaSH.Sized.Fixed.resizeF1
    of wild_sxo8 { __DEFAULT ->
    let {
      fRepI_abs_sxo9 :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_abs_sxo9 = GHC.Integer.Type.absInteger fRepI_sxo7 } in
    let {
      nF_sxoa :: GHC.Types.Int
      [LclId, Str=DmdType]
      nF_sxoa =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_sxo4
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild1_sxob { __DEFAULT ->
        GHC.Types.I# wild1_sxob
        } } in
    let {
      a_sxoc [Occ=Once*] :: [GHC.Types.Char]
      [LclId, Str=DmdType]
      a_sxoc =
        let {
          sat_sxp1 :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          sat_sxp1 =
            case GHC.Integer.Type.ltInteger#
                   fRepI_sxo7 CLaSH.Sized.Fixed.resizeF1
            of wild1_sxod { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1_sxod
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case nF_sxoa of _ [Occ=Dead] { GHC.Types.I# x_sxog ->
                case GHC.Prim.<# x_sxog 0 of sat_sxoh { __DEFAULT ->
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxoh
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    let {
                      a1_sxoj :: GHC.Integer.Type.Integer
                      [LclId, Str=DmdType]
                      a1_sxoj =
                        case x_sxog of wild5_sxok {
                          __DEFAULT ->
                            GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_sxok;
                          0 -> GHC.Real.$fEnumRatio1
                        } } in
                    case x_sxog of wild5_sxol {
                      __DEFAULT ->
                        case GHC.Integer.Type.absInteger a1_sxoj of sat_sxor { __DEFAULT ->
                        case GHC.Integer.Type.signumInteger a1_sxoj
                        of sat_sxop { __DEFAULT ->
                        case GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_sxol
                        of sat_sxom { __DEFAULT ->
                        case GHC.Integer.Type.minusInteger
                               sat_sxom CLaSH.Sized.Fixed.$fShowFixed4
                        of sat_sxon { __DEFAULT ->
                        case GHC.Integer.Type.andInteger fRepI_sxo7 sat_sxon
                        of sat_sxoo { __DEFAULT ->
                        case GHC.Integer.Type.timesInteger sat_sxoo sat_sxop
                        of sat_sxoq { __DEFAULT ->
                        case GHC.Real.$w$sreduce sat_sxoq sat_sxor
                        of _ [Occ=Dead] { (# ww1_sxot [Occ=Once], ww2_sxou [Occ=Once] #) ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1_sxot ww2_sxou
                        }
                        }
                        }
                        }
                        }
                        }
                        };
                      0 ->
                        case GHC.Integer.Type.absInteger a1_sxoj of sat_sxoy { __DEFAULT ->
                        case GHC.Integer.Type.signumInteger a1_sxoj
                        of sat_sxow { __DEFAULT ->
                        case GHC.Integer.Type.andInteger
                               fRepI_sxo7 CLaSH.Sized.Fixed.resizeF1
                        of sat_sxov { __DEFAULT ->
                        case GHC.Integer.Type.timesInteger sat_sxov sat_sxow
                        of sat_sxox { __DEFAULT ->
                        case GHC.Real.$w$sreduce sat_sxox sat_sxoy
                        of _ [Occ=Dead] { (# ww1_sxoA [Occ=Once], ww2_sxoB [Occ=Once] #) ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1_sxoA ww2_sxoB
                        }
                        }
                        }
                        }
                        }
                    };
                  GHC.Types.True -> case GHC.Real.^3 of _ [Occ=Dead] { }
                }
                }
                };
              GHC.Types.True ->
                case nF_sxoa of _ [Occ=Dead] { GHC.Types.I# x_sxoE ->
                case GHC.Prim.<# x_sxoE 0 of sat_sxoF { __DEFAULT ->
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxoF
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    let {
                      a1_sxoH :: GHC.Integer.Type.Integer
                      [LclId, Str=DmdType]
                      a1_sxoH =
                        case x_sxoE of wild5_sxoI {
                          __DEFAULT ->
                            GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_sxoI;
                          0 -> GHC.Real.$fEnumRatio1
                        } } in
                    case x_sxoE of wild5_sxoJ {
                      __DEFAULT ->
                        case GHC.Integer.Type.absInteger a1_sxoH of sat_sxoP { __DEFAULT ->
                        case GHC.Integer.Type.signumInteger a1_sxoH
                        of sat_sxoN { __DEFAULT ->
                        case GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_sxoJ
                        of sat_sxoK { __DEFAULT ->
                        case GHC.Integer.Type.minusInteger
                               sat_sxoK CLaSH.Sized.Fixed.$fShowFixed4
                        of sat_sxoL { __DEFAULT ->
                        case GHC.Integer.Type.andInteger fRepI_abs_sxo9 sat_sxoL
                        of sat_sxoM { __DEFAULT ->
                        case GHC.Integer.Type.timesInteger sat_sxoM sat_sxoN
                        of sat_sxoO { __DEFAULT ->
                        case GHC.Real.$w$sreduce sat_sxoO sat_sxoP
                        of _ [Occ=Dead] { (# ww1_sxoR [Occ=Once], ww2_sxoS [Occ=Once] #) ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1_sxoR ww2_sxoS
                        }
                        }
                        }
                        }
                        }
                        }
                        };
                      0 ->
                        case GHC.Integer.Type.absInteger a1_sxoH of sat_sxoW { __DEFAULT ->
                        case GHC.Integer.Type.signumInteger a1_sxoH
                        of sat_sxoU { __DEFAULT ->
                        case GHC.Integer.Type.andInteger
                               fRepI_abs_sxo9 CLaSH.Sized.Fixed.resizeF1
                        of sat_sxoT { __DEFAULT ->
                        case GHC.Integer.Type.timesInteger sat_sxoT sat_sxoU
                        of sat_sxoV { __DEFAULT ->
                        case GHC.Real.$w$sreduce sat_sxoV sat_sxoW
                        of _ [Occ=Dead] { (# ww1_sxoY [Occ=Once], ww2_sxoZ [Occ=Once] #) ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1_sxoY ww2_sxoZ
                        }
                        }
                        }
                        }
                        }
                    };
                  GHC.Types.True -> case GHC.Real.^3 of _ [Occ=Dead] { }
                }
                }
                }
            }
            } } in
        let {
          sat_sxp2 [Occ=Once]
            :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          [LclId, Str=DmdType]
          sat_sxp2 = (CLaSH.Sized.Fixed.$fShowFixed6, sat_sxp1) } in
        case GHC.List.iterateFB
               @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
               @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
               CLaSH.Sized.Fixed.$fShowFixed8
               CLaSH.Sized.Fixed.$fShowFixed7
               sat_sxp2
        of _ [Occ=Dead] {
          [] -> case Data.Maybe.fromJust1 of _ [Occ=Dead] { };
          : a1_sxp5 [Occ=Once!] _ [Occ=Dead] ->
            case a1_sxp5
            of _ [Occ=Dead] { (x_sxp8 [Occ=Once!], y_sxp9 [Occ=Once!]) ->
            case x_sxp8 of _ [Occ=Dead] { GHC.Types.I# x1_sxpb [Occ=Once] ->
            let {
              str_sxpc :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              str_sxpc =
                case y_sxp9
                of _ [Occ=Dead] { GHC.Real.:% x2_sxpe [Occ=Once] _ [Occ=Dead] ->
                case GHC.Show.$w$cshowsPrec
                       0 x2_sxpe (GHC.Types.[] @ GHC.Types.Char)
                of _ [Occ=Dead] { (# ww3_sxph [Occ=Once], ww4_sxpi [Occ=Once] #) ->
                GHC.Types.: @ GHC.Types.Char ww3_sxph ww4_sxpi
                }
                } } in
            case GHC.List.$wlenAcc @ GHC.Types.Char str_sxpc 0
            of ww_sxpj { __DEFAULT ->
            case GHC.Prim.-# x1_sxpb ww_sxpj of n#_sxpk { __DEFAULT ->
            case GHC.Prim.<=# n#_sxpk 0 of sat_sxpl { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxpl
            of _ [Occ=Dead] {
              GHC.Types.False ->
                let {
                  lvl1_sxpn [Occ=OnceL] :: [GHC.Types.Char]
                  [LclId, Str=DmdType, Unf=OtherCon []]
                  lvl1_sxpn =
                    GHC.Types.:
                      @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed3 str_sxpc } in
                letrec {
                  xs_sxpo [Occ=LoopBreaker] :: GHC.Prim.Int# -> [GHC.Types.Char]
                  [LclId, Arity=1, Str=DmdType, Unf=OtherCon []]
                  xs_sxpo =
                    \ (m_sxpp :: GHC.Prim.Int#) ->
                      case GHC.Prim.<=# m_sxpp 1 of sat_sxpq { __DEFAULT ->
                      case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxpq
                      of _ [Occ=Dead] {
                        GHC.Types.False ->
                          let {
                            sat_sxpt [Occ=Once] :: [GHC.Types.Char]
                            [LclId, Str=DmdType]
                            sat_sxpt =
                              case GHC.Prim.-# m_sxpp 1 of sat_sxps { __DEFAULT ->
                              xs_sxpo sat_sxps
                              } } in
                          GHC.Types.:
                            @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed3 sat_sxpt;
                        GHC.Types.True -> lvl1_sxpn
                      }
                      }; } in
                xs_sxpo n#_sxpk;
              GHC.Types.True -> str_sxpc
            }
            }
            }
            }
            }
            }
        } } in
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_sxo8
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case nF_sxoa of _ [Occ=Dead] { GHC.Types.I# x_sxpw [Occ=Once] ->
        case GHC.Prim.negateInt# x_sxpw of ww_sxpx { __DEFAULT ->
        case GHC.Prim.>=# ww_sxpx 0 of sat_sxpy { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxpy
        of _ [Occ=Dead] {
          GHC.Types.False ->
            case GHC.Prim.negateInt# ww_sxpx of sat_sxpA { __DEFAULT ->
            case GHC.Integer.Type.shiftRInteger fRepI_sxo7 sat_sxpA
            of sat_sxpB { __DEFAULT ->
            case GHC.Show.$w$cshowsPrec
                   0 sat_sxpB (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_sxpD [Occ=Once], ww4_sxpE [Occ=Once] #) ->
            let {
              sat_sxpG [Occ=Once] :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              sat_sxpG =
                GHC.Types.:
                  @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed2 a_sxoc } in
            let {
              sat_sxpF [Occ=Once] :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              sat_sxpF = GHC.Types.: @ GHC.Types.Char ww3_sxpD ww4_sxpE } in
            GHC.Base.++ @ GHC.Types.Char sat_sxpF sat_sxpG
            }
            }
            };
          GHC.Types.True ->
            case GHC.Integer.Type.shiftLInteger fRepI_sxo7 ww_sxpx
            of sat_sxpH { __DEFAULT ->
            case GHC.Show.$w$cshowsPrec
                   0 sat_sxpH (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_sxpJ [Occ=Once], ww4_sxpK [Occ=Once] #) ->
            let {
              sat_sxpM [Occ=Once] :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              sat_sxpM =
                GHC.Types.:
                  @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed2 a_sxoc } in
            let {
              sat_sxpL [Occ=Once] :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              sat_sxpL = GHC.Types.: @ GHC.Types.Char ww3_sxpJ ww4_sxpK } in
            GHC.Base.++ @ GHC.Types.Char sat_sxpL sat_sxpM
            }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        let {
          sat_sxq3 [Occ=Once] :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          sat_sxq3 =
            GHC.Types.:
              @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed2 a_sxoc } in
        let {
          sat_sxq1 [Occ=Once] :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          sat_sxq1 =
            case nF_sxoa of _ [Occ=Dead] { GHC.Types.I# x_sxpO [Occ=Once] ->
            case GHC.Prim.negateInt# x_sxpO of ww_sxpP { __DEFAULT ->
            case GHC.Prim.>=# ww_sxpP 0 of sat_sxpQ { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sxpQ
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Prim.negateInt# ww_sxpP of sat_sxpS { __DEFAULT ->
                case GHC.Integer.Type.shiftRInteger fRepI_abs_sxo9 sat_sxpS
                of sat_sxpT { __DEFAULT ->
                case GHC.Show.$w$cshowsPrec
                       0 sat_sxpT (GHC.Types.[] @ GHC.Types.Char)
                of _ [Occ=Dead] { (# ww3_sxpV [Occ=Once], ww4_sxpW [Occ=Once] #) ->
                GHC.Types.: @ GHC.Types.Char ww3_sxpV ww4_sxpW
                }
                }
                };
              GHC.Types.True ->
                case GHC.Integer.Type.shiftLInteger fRepI_abs_sxo9 ww_sxpP
                of sat_sxpX { __DEFAULT ->
                case GHC.Show.$w$cshowsPrec
                       0 sat_sxpX (GHC.Types.[] @ GHC.Types.Char)
                of _ [Occ=Dead] { (# ww3_sxpZ [Occ=Once], ww4_sxq0 [Occ=Once] #) ->
                GHC.Types.: @ GHC.Types.Char ww3_sxpZ ww4_sxq0
                }
                }
            }
            }
            }
            } } in
        let {
          sat_sxq2 [Occ=Once] :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          sat_sxq2 =
            GHC.Types.:
              @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed1 sat_sxq1 } in
        GHC.Base.++ @ GHC.Types.Char sat_sxq2 sat_sxq3
    }
    }

CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[GblId, Arity=7, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_sxq4 [Occ=Once] :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_sxq5 [Occ=Once] :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_sxq6 [Occ=Once] :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_sxq7 [Occ=Once]
       :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_sxq9 [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_sxqa [Occ=Once] :: GHC.Base.String) ->
    case CLaSH.Sized.Fixed.$fShowFixed_$cshow
           @ frac_auHx
           @ rep_auHy
           @ size_auHz
           $dShow_sxq4
           $dBits_sxq5
           $dKnownNat_sxq6
           $dIntegral_sxq7
           x_sxq9
    of sat_sxqb { __DEFAULT ->
    GHC.Base.++ @ GHC.Types.Char sat_sxqb s_sxqa
    }

CLaSH.Sized.Fixed.$fShowFixed_$cshowList
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[GblId, Arity=6, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed_$cshowList =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_sxqc [Occ=OnceL] :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_sxqd [Occ=OnceL] :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_sxqe [Occ=OnceL] :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_sxqf [Occ=OnceL]
       :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_sxqg [Occ=Once]
       :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta1_sxqh [Occ=Once] :: GHC.Base.String) ->
    let {
      sat_sxql [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
           -> GHC.Show.ShowS
      [LclId, Str=DmdType]
      sat_sxql =
        \ (x_sxqi [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
          (s_sxqj [Occ=Once] :: GHC.Base.String) ->
          case CLaSH.Sized.Fixed.$fShowFixed_$cshow
                 @ frac_auHx
                 @ rep_auHy
                 @ size_auHz
                 $dShow_sxqc
                 $dBits_sxqd
                 $dKnownNat_sxqe
                 $dIntegral_sxqf
                 x_sxqi
          of sat_sxqk { __DEFAULT ->
          GHC.Base.++ @ GHC.Types.Char sat_sxqk s_sxqj
          } } in
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      sat_sxql
      eta_sxqg
      eta1_sxqh

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[GblId[DFunId], Arity=4, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_sxqm :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_sxqn :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_sxqo :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_sxqp :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    let {
      sat_sxqs [Occ=Once]
        :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
           -> GHC.Show.ShowS
      [LclId, Str=DmdType]
      sat_sxqs =
        \ (eta_B2 [Occ=Once]
             :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
          (eta_B1 [Occ=Once] :: GHC.Base.String) ->
          CLaSH.Sized.Fixed.$fShowFixed_$cshowList
            @ frac_auHx
            @ rep_auHy
            @ size_auHz
            $dShow_sxqm
            $dBits_sxqn
            $dKnownNat_sxqo
            $dIntegral_sxqp
            eta_B2
            eta_B1 } in
    let {
      sat_sxqr [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
           -> GHC.Base.String
      [LclId, Str=DmdType]
      sat_sxqr =
        \ (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
          CLaSH.Sized.Fixed.$fShowFixed_$cshow
            @ frac_auHx
            @ rep_auHy
            @ size_auHz
            $dShow_sxqm
            $dBits_sxqn
            $dKnownNat_sxqo
            $dIntegral_sxqp
            eta_B1 } in
    let {
      sat_sxqq [Occ=Once]
        :: GHC.Types.Int
           -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
           -> GHC.Show.ShowS
      [LclId, Str=DmdType]
      sat_sxqq =
        \ (eta_B3 [Occ=Once] :: GHC.Types.Int)
          (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
          (eta_B1 [Occ=Once] :: GHC.Base.String) ->
          CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec
            @ frac_auHx
            @ rep_auHy
            @ size_auHz
            $dShow_sxqm
            $dBits_sxqn
            $dKnownNat_sxqo
            $dIntegral_sxqp
            eta_B3
            eta_B2
            eta_B1 } in
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      sat_sxqq
      sat_sxqr
      sat_sxqs

CLaSH.Sized.Fixed.$fMultFixedFixed1
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[GblId, Arity=3, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fMultFixedFixed1 =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_sxqt [Occ=Once!]
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_sxqu [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta1_sxqv [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_sxqt
    of _ [Occ=Dead] { (tpl_sxqx [Occ=Once], tpl1_sxqy [Occ=Once!]) ->
    case tpl1_sxqy of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw3M ->
    ((tpl_sxqx
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_sxqu
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta1_sxqv
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox1_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

CLaSH.Sized.Fixed.$fMultFixedFixed_$cmult
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[GblId, Arity=3, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fMultFixedFixed_$cmult =
  (\ (@ (frac1_auHq :: GHC.TypeLits.Nat))
     (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
     (@ (size1_auHs :: GHC.TypeLits.Nat))
     (@ (frac2_auHt :: GHC.TypeLits.Nat))
     (@ (size2_auHu :: GHC.TypeLits.Nat))
     (eta_B3 [Occ=Once]
        :: CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
     (eta_B2 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
     CLaSH.Sized.Fixed.$fMultFixedFixed1
       @ frac1_auHq
       @ rep_auHr
       @ size1_auHs
       @ frac2_auHt
       @ size2_auHu
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  (\ (@ (frac1_auHq :: GHC.TypeLits.Nat))
     (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
     (@ (size1_auHs :: GHC.TypeLits.Nat))
     (@ (frac2_auHt :: GHC.TypeLits.Nat))
     (@ (size2_auHu :: GHC.TypeLits.Nat))
     (eta_B3 [Occ=Once]
        :: CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
     (eta_B2 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
     CLaSH.Sized.Fixed.$fMultFixedFixed1
       @ frac1_auHq
       @ rep_auHr
       @ size1_auHs
       @ frac2_auHt
       @ size2_auHu
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_sxqA [Occ=Once!]
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_sxqB [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta1_sxqC [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_sxqA
    of _ [Occ=Dead] { (tpl_sxqE, tpl1_sxqF, tpl2_sxqG [Occ=Once]) ->
    let {
      $dKnownNat_sxqH
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_sxqH =
        case tpl1_sxqF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl12_sxqS [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl12_sxqS
        } } in
    let {
      $dBits_sxqV
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_sxqV =
        case tpl1_sxqF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_sxr5 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl11_sxr5
        } } in
    let {
      $dKnownNat1_sxr9
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat1_sxr9 =
        case tpl1_sxqF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_sxrh [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl9_sxrh
        } } in
    let {
      $dResize_sxrn :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_sxrn =
        case tpl1_sxqF
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl8_sxru [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl8_sxru
        } } in
    let {
      $dBounded_sxrB
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_sxrB =
        case tpl1_sxqF
        of _ [Occ=Dead]
        { (tpl3_sxrD [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_sxrD
        } } in
    let {
      sat_sxuC [Occ=Once]
        :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                     GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      sat_sxuC =
        let {
          $dBits1_sxte :: Data.Bits.Bits (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          $dBits1_sxte =
            case tpl1_sxqF
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxtk [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl7_sxtk
            } } in
        let {
          sat_sxuA [Occ=Once] :: GHC.Enum.Bounded (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_sxuA =
            case tpl1_sxqF
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_sxuz [Occ=Once]) ->
            tpl14_sxuz
            } } in
        let {
          sat_sxum [Occ=Once] :: GHC.TypeLits.KnownNat frac2_auHg
          [LclId, Str=DmdType]
          sat_sxum =
            case tpl1_sxqF
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl13_sxuk [Occ=Once], _ [Occ=Dead]) ->
            tpl13_sxuk
            } } in
        let {
          sat_sxu8 [Occ=Once] :: GHC.TypeLits.KnownNat size2_auHh
          [LclId, Str=DmdType]
          sat_sxu8 =
            case tpl1_sxqF
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_sxu3 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl10_sxu3
            } } in
        let {
          sat_sxtU [Occ=Once] :: GHC.Num.Num (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_sxtU =
            case tpl1_sxqF
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxtL [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl6_sxtL
            } } in
        let {
          sat_sxtG [Occ=Once] :: GHC.Classes.Ord (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_sxtG =
            case tpl1_sxqF
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], tpl5_sxtw [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl5_sxtw
            } } in
        let {
          sat_sxts [Occ=Once] :: GHC.Classes.Eq (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_sxts =
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits1_sxte } in
        let {
          sat_sxuB [Occ=Once]
            :: CLaSH.Sized.Fixed.ResizeFC
                 rep_auHe
                 frac2_auHg
                 (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                 size2_auHh
                 (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
          [LclId, Str=DmdType]
          sat_sxuB =
            ($dBounded_sxrB,
             sat_sxts,
             sat_sxtG,
             sat_sxtU,
             $dBits1_sxte,
             $dResize_sxrn,
             $dKnownNat1_sxr9,
             sat_sxu8,
             $dBits_sxqV,
             $dKnownNat_sxqH,
             sat_sxum,
             sat_sxuA) } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           sat_sxuB
           eta1_sxqC)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)) } in
    let {
      sat_sxtd [Occ=Once]
        :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                     GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      sat_sxtd =
        let {
          $dBits1_sxrP :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits1_sxrP =
            case tpl_sxqE
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxrV [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl7_sxrV
            } } in
        let {
          sat_sxtb [Occ=Once] :: GHC.Enum.Bounded (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_sxtb =
            case tpl_sxqE
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_sxta [Occ=Once]) ->
            tpl14_sxta
            } } in
        let {
          sat_sxsX [Occ=Once] :: GHC.TypeLits.KnownNat frac1_auHd
          [LclId, Str=DmdType]
          sat_sxsX =
            case tpl_sxqE
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl13_sxsV [Occ=Once], _ [Occ=Dead]) ->
            tpl13_sxsV
            } } in
        let {
          sat_sxsJ [Occ=Once] :: GHC.TypeLits.KnownNat size1_auHf
          [LclId, Str=DmdType]
          sat_sxsJ =
            case tpl_sxqE
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_sxsE [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl10_sxsE
            } } in
        let {
          sat_sxsv [Occ=Once] :: GHC.Num.Num (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_sxsv =
            case tpl_sxqE
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxsm [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl6_sxsm
            } } in
        let {
          sat_sxsh [Occ=Once] :: GHC.Classes.Ord (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_sxsh =
            case tpl_sxqE
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], tpl5_sxs7 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl5_sxs7
            } } in
        let {
          sat_sxs3 [Occ=Once] :: GHC.Classes.Eq (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_sxs3 =
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits1_sxrP } in
        let {
          sat_sxtc [Occ=Once]
            :: CLaSH.Sized.Fixed.ResizeFC
                 rep_auHe
                 frac1_auHd
                 (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                 size1_auHf
                 (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
          [LclId, Str=DmdType]
          sat_sxtc =
            ($dBounded_sxrB,
             sat_sxs3,
             sat_sxsh,
             sat_sxsv,
             $dBits1_sxrP,
             $dResize_sxrn,
             $dKnownNat1_sxr9,
             sat_sxsJ,
             $dBits_sxqV,
             $dKnownNat_sxqH,
             sat_sxsX,
             sat_sxtb) } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           sat_sxtc
           eta_sxqB)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)) } in
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl2_sxqG
       sat_sxtd
       sat_sxuC)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_sxuD [Occ=Once!]
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_sxuE [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta1_sxuF [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_sxuD
    of _ [Occ=Dead] { (tpl_sxuH, tpl1_sxuI, tpl2_sxuJ [Occ=Once]) ->
    let {
      $dKnownNat_sxuK
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_sxuK =
        case tpl1_sxuI
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl12_sxuV [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl12_sxuV
        } } in
    let {
      $dBits_sxuY
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_sxuY =
        case tpl1_sxuI
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_sxv8 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl11_sxv8
        } } in
    let {
      $dKnownNat1_sxvc
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat1_sxvc =
        case tpl1_sxuI
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_sxvk [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl9_sxvk
        } } in
    let {
      $dResize_sxvq :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_sxvq =
        case tpl1_sxuI
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl8_sxvx [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl8_sxvx
        } } in
    let {
      $dBounded_sxvE
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_sxvE =
        case tpl1_sxuI
        of _ [Occ=Dead]
        { (tpl3_sxvG [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_sxvG
        } } in
    let {
      sat_sxyF [Occ=Once]
        :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                     GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      sat_sxyF =
        let {
          $dBits1_sxxh :: Data.Bits.Bits (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          $dBits1_sxxh =
            case tpl1_sxuI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxxn [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl7_sxxn
            } } in
        let {
          sat_sxyD [Occ=Once] :: GHC.Enum.Bounded (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_sxyD =
            case tpl1_sxuI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_sxyC [Occ=Once]) ->
            tpl14_sxyC
            } } in
        let {
          sat_sxyp [Occ=Once] :: GHC.TypeLits.KnownNat frac2_auHg
          [LclId, Str=DmdType]
          sat_sxyp =
            case tpl1_sxuI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl13_sxyn [Occ=Once], _ [Occ=Dead]) ->
            tpl13_sxyn
            } } in
        let {
          sat_sxyb [Occ=Once] :: GHC.TypeLits.KnownNat size2_auHh
          [LclId, Str=DmdType]
          sat_sxyb =
            case tpl1_sxuI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_sxy6 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl10_sxy6
            } } in
        let {
          sat_sxxX [Occ=Once] :: GHC.Num.Num (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_sxxX =
            case tpl1_sxuI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxxO [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl6_sxxO
            } } in
        let {
          sat_sxxJ [Occ=Once] :: GHC.Classes.Ord (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_sxxJ =
            case tpl1_sxuI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], tpl5_sxxz [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl5_sxxz
            } } in
        let {
          sat_sxxv [Occ=Once] :: GHC.Classes.Eq (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_sxxv =
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits1_sxxh } in
        let {
          sat_sxyE [Occ=Once]
            :: CLaSH.Sized.Fixed.ResizeFC
                 rep_auHe
                 frac2_auHg
                 (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                 size2_auHh
                 (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
          [LclId, Str=DmdType]
          sat_sxyE =
            ($dBounded_sxvE,
             sat_sxxv,
             sat_sxxJ,
             sat_sxxX,
             $dBits1_sxxh,
             $dResize_sxvq,
             $dKnownNat1_sxvc,
             sat_sxyb,
             $dBits_sxuY,
             $dKnownNat_sxuK,
             sat_sxyp,
             sat_sxyD) } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           sat_sxyE
           eta1_sxuF)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)) } in
    let {
      sat_sxxg [Occ=Once]
        :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                     GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      sat_sxxg =
        let {
          $dBits1_sxvS :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits1_sxvS =
            case tpl_sxuH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxvY [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl7_sxvY
            } } in
        let {
          sat_sxxe [Occ=Once] :: GHC.Enum.Bounded (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_sxxe =
            case tpl_sxuH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_sxxd [Occ=Once]) ->
            tpl14_sxxd
            } } in
        let {
          sat_sxx0 [Occ=Once] :: GHC.TypeLits.KnownNat frac1_auHd
          [LclId, Str=DmdType]
          sat_sxx0 =
            case tpl_sxuH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl13_sxwY [Occ=Once], _ [Occ=Dead]) ->
            tpl13_sxwY
            } } in
        let {
          sat_sxwM [Occ=Once] :: GHC.TypeLits.KnownNat size1_auHf
          [LclId, Str=DmdType]
          sat_sxwM =
            case tpl_sxuH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_sxwH [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl10_sxwH
            } } in
        let {
          sat_sxwy [Occ=Once] :: GHC.Num.Num (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_sxwy =
            case tpl_sxuH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxwp [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl6_sxwp
            } } in
        let {
          sat_sxwk [Occ=Once] :: GHC.Classes.Ord (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_sxwk =
            case tpl_sxuH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], tpl5_sxwa [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl5_sxwa
            } } in
        let {
          sat_sxw6 [Occ=Once] :: GHC.Classes.Eq (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_sxw6 =
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits1_sxvS } in
        let {
          sat_sxxf [Occ=Once]
            :: CLaSH.Sized.Fixed.ResizeFC
                 rep_auHe
                 frac1_auHd
                 (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                 size1_auHf
                 (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
          [LclId, Str=DmdType]
          sat_sxxf =
            ($dBounded_sxvE,
             sat_sxw6,
             sat_sxwk,
             sat_sxwy,
             $dBits1_sxvS,
             $dResize_sxvq,
             $dKnownNat1_sxvc,
             sat_sxwM,
             $dBits_sxuY,
             $dKnownNat_sxuK,
             sat_sxx0,
             sat_sxxe) } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           sat_sxxf
           eta_sxuE)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)) } in
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl2_sxuJ
       sat_sxxg
       sat_sxyF)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[GblId[DFunId], Arity=1, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_sxyG
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    let {
      sat_sxyI [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
           -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
           -> CLaSH.Class.Num.AResult
                (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      sat_sxyI =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
          CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus
            @ frac1_auHd
            @ rep_auHe
            @ size1_auHf
            @ frac2_auHg
            @ size2_auHh
            tup_sxyG
            eta_B2
            eta_B1 } in
    let {
      sat_sxyH [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
           -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
           -> CLaSH.Class.Num.AResult
                (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      sat_sxyH =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
          CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus
            @ frac1_auHd
            @ rep_auHe
            @ size1_auHf
            @ frac2_auHg
            @ size2_auHh
            tup_sxyG
            eta_B2
            eta_B1 } in
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      sat_sxyH
      sat_sxyI

CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_sxyJ [Occ=Once!]
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_sxyK [Occ=Once] :: GHC.Integer.Type.Integer) ->
    case tup_sxyJ
    of _ [Occ=Dead]
    { (_ [Occ=Dead], tpl1_sxyN [Occ=Once!], tpl2_sxyO [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
    case tpl1_sxyN
    of _ [Occ=Dead]
    { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_sxz1 [Occ=Once], tpl15_sxz2 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
    let {
      sat_sxz7 [Occ=Once] :: GHC.Types.Int
      [LclId, Str=DmdType]
      sat_sxz7 =
        case GHC.Integer.Type.integerToInt
               (tpl15_sxz2
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild2_sxz6 { __DEFAULT ->
        GHC.Types.I# wild2_sxz6
        } } in
    let {
      sat_sxz5 [Occ=Once] :: rep_auGZ size_auH0
      [LclId, Str=DmdType]
      sat_sxz5 =
        GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl2_sxyO eta_sxyK } in
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0) tpl14_sxz1 sat_sxz5 sat_sxz7)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

CLaSH.Sized.Fixed.$fNumFixed1
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed1 =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_sxz8 [Occ=Once!]
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_sxz9 [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_sxz8
    of _ [Occ=Dead]
    { (_ [Occ=Dead], _ [Occ=Dead], tpl2_sxzd [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl2_sxzd
      (eta_sxz9
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

CLaSH.Sized.Fixed.$fNumFixed_$cabs
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$cabs =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_sxzh
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_sxzi [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup1_sxzj :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId, Str=DmdType]
      tup1_sxzj =
        case tup_sxzh
        of _ [Occ=Dead]
        { (tpl_sxzl [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxzl
        } } in
    let {
      $dKnownNat_sxzr
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_sxzr =
        case tup1_sxzj
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxzA [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_sxzA
        } } in
    let {
      tup2_sxzD
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId, Str=DmdType]
      tup2_sxzD =
        case tup_sxzh
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_sxzG [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_sxzG
        } } in
    let {
      $dKnownNat1_sxzL :: GHC.TypeLits.KnownNat size_XuIN
      [LclId, Str=DmdType]
      $dKnownNat1_sxzL =
        case tup2_sxzD
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxzT [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_sxzT
        } } in
    let {
      sat_sxBV [Occ=Once] :: rep_XuIL (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxBV =
        case tup_sxzh
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_sxBE [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        let {
          sat_sxBU [Occ=Once] :: rep_XuIL (size_XuIN GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_sxBU =
            case tup2_sxzD
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_sxBN [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_sxBN
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                     :: CLaSH.Class.Num.Resize rep_XuIL
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
              @ size_XuIN
              @ (size_XuIN GHC.TypeLits.+ 2)
              $dKnownNat1_sxzL
              $dKnownNat_sxzr
              (eta_sxzi
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                            ~#
                          rep_XuIL size_XuIN))
            } } in
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2)) tpl3_sxBE sat_sxBU
        } } in
    let {
      sat_sxBy [Occ=Once]
        :: Data.Bits.Bits (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_sxBy =
        case tup1_sxzj
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_sxBx [Occ=Once]) ->
        tpl9_sxBx
        } } in
    let {
      sat_sxBm [Occ=Once] :: GHC.Enum.Bounded (rep_XuIL size_XuIN)
      [LclId, Str=DmdType]
      sat_sxBm =
        case tup2_sxzD
        of _ [Occ=Dead]
        { (tpl_sxBa [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxBa
        } } in
    let {
      sat_sxB8 [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize
             (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
           ~ (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxB8 =
        case tup1_sxzj
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_sxB3 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_sxB3
        } } in
    let {
      sat_sxAW [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize (rep_XuIL size_XuIN) ~ size_XuIN
      [LclId, Str=DmdType]
      sat_sxAW =
        case tup1_sxzj
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_sxAQ [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_sxAQ
        } } in
    let {
      sat_sxAK [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector
             (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_sxAK =
        case tup1_sxzj
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_sxAD [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_sxAD
        } } in
    let {
      sat_sxAy [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector (rep_XuIL size_XuIN)
      [LclId, Str=DmdType]
      sat_sxAy =
        case tup1_sxzj
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_sxAq [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_sxAq
        } } in
    let {
      sat_sxAm [Occ=Once]
        :: ((size_XuIN GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxAm =
        case tup1_sxzj
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_sxAd [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_sxAd
        } } in
    let {
      sat_sxAa [Occ=Once] :: 1 GHC.TypeLits.<= size_XuIN
      [LclId, Str=DmdType]
      sat_sxAa =
        case tup1_sxzj
        of _ [Occ=Dead]
        { (tpl_sxA0 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxA0
        } } in
    let {
      sat_sxBz [Occ=Once] :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId, Str=DmdType]
      sat_sxBz =
        (sat_sxAa,
         sat_sxAm,
         sat_sxAy,
         sat_sxAK,
         sat_sxAW,
         sat_sxB8,
         $dKnownNat1_sxzL,
         $dKnownNat_sxzr,
         sat_sxBm,
         sat_sxBy) } in
    (CLaSH.Sized.Fixed.satN2 @ rep_XuIL @ size_XuIN sat_sxBz sat_sxBV)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

CLaSH.Sized.Fixed.$fNumFixed_$cnegate
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$cnegate =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_sxBW
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_sxBX [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup1_sxBY :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId, Str=DmdType]
      tup1_sxBY =
        case tup_sxBW
        of _ [Occ=Dead]
        { (tpl_sxC0 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxC0
        } } in
    let {
      $dKnownNat_sxC6
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_sxC6 =
        case tup1_sxBY
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxCf [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_sxCf
        } } in
    let {
      tup2_sxCi
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId, Str=DmdType]
      tup2_sxCi =
        case tup_sxBW
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_sxCl [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_sxCl
        } } in
    let {
      $dKnownNat1_sxCq :: GHC.TypeLits.KnownNat size_XuIO
      [LclId, Str=DmdType]
      $dKnownNat1_sxCq =
        case tup2_sxCi
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxCy [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_sxCy
        } } in
    let {
      sat_sxEA [Occ=Once] :: rep_XuIM (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxEA =
        case tup_sxBW
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_sxEj [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        let {
          sat_sxEz [Occ=Once] :: rep_XuIM (size_XuIO GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_sxEz =
            case tup2_sxCi
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_sxEs [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_sxEs
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                     :: CLaSH.Class.Num.Resize rep_XuIM
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
              @ size_XuIO
              @ (size_XuIO GHC.TypeLits.+ 2)
              $dKnownNat1_sxCq
              $dKnownNat_sxC6
              (eta_sxBX
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                            ~#
                          rep_XuIM size_XuIO))
            } } in
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2)) tpl3_sxEj sat_sxEz
        } } in
    let {
      sat_sxEd [Occ=Once]
        :: Data.Bits.Bits (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_sxEd =
        case tup1_sxBY
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_sxEc [Occ=Once]) ->
        tpl9_sxEc
        } } in
    let {
      sat_sxE1 [Occ=Once] :: GHC.Enum.Bounded (rep_XuIM size_XuIO)
      [LclId, Str=DmdType]
      sat_sxE1 =
        case tup2_sxCi
        of _ [Occ=Dead]
        { (tpl_sxDP [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxDP
        } } in
    let {
      sat_sxDN [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize
             (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
           ~ (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxDN =
        case tup1_sxBY
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_sxDI [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_sxDI
        } } in
    let {
      sat_sxDB [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize (rep_XuIM size_XuIO) ~ size_XuIO
      [LclId, Str=DmdType]
      sat_sxDB =
        case tup1_sxBY
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_sxDv [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_sxDv
        } } in
    let {
      sat_sxDp [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector
             (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_sxDp =
        case tup1_sxBY
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_sxDi [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_sxDi
        } } in
    let {
      sat_sxDd [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector (rep_XuIM size_XuIO)
      [LclId, Str=DmdType]
      sat_sxDd =
        case tup1_sxBY
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_sxD5 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_sxD5
        } } in
    let {
      sat_sxD1 [Occ=Once]
        :: ((size_XuIO GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxD1 =
        case tup1_sxBY
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_sxCS [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_sxCS
        } } in
    let {
      sat_sxCP [Occ=Once] :: 1 GHC.TypeLits.<= size_XuIO
      [LclId, Str=DmdType]
      sat_sxCP =
        case tup1_sxBY
        of _ [Occ=Dead]
        { (tpl_sxCF [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxCF
        } } in
    let {
      sat_sxEe [Occ=Once] :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId, Str=DmdType]
      sat_sxEe =
        (sat_sxCP,
         sat_sxD1,
         sat_sxDd,
         sat_sxDp,
         sat_sxDB,
         sat_sxDN,
         $dKnownNat1_sxCq,
         $dKnownNat_sxC6,
         sat_sxE1,
         sat_sxEd) } in
    (CLaSH.Sized.Fixed.satN2 @ rep_XuIM @ size_XuIO sat_sxEe sat_sxEA)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

CLaSH.Sized.Fixed.$fNumFixed_$c-
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$c- =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_sxEB
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_sxEC [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta1_sxED [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup1_sxEE :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId, Str=DmdType]
      tup1_sxEE =
        case tup_sxEB
        of _ [Occ=Dead]
        { (tpl_sxEG [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxEG
        } } in
    let {
      $dKnownNat_sxEM
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_sxEM =
        case tup1_sxEE
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxEV [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_sxEV
        } } in
    let {
      tup2_sxEY
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId, Str=DmdType]
      tup2_sxEY =
        case tup_sxEB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_sxF1 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_sxF1
        } } in
    let {
      $dKnownNat1_sxF6 :: GHC.TypeLits.KnownNat size_XuIP
      [LclId, Str=DmdType]
      $dKnownNat1_sxF6 =
        case tup2_sxEY
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxFe [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_sxFe
        } } in
    let {
      sat_sxHu [Occ=Once] :: rep_XuIN (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxHu =
        case tup_sxEB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_sxGZ [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        let {
          sat_sxHt [Occ=Once] :: rep_XuIN (size_XuIP GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_sxHt =
            case tup2_sxEY
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_sxHm [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_sxHm
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                     :: CLaSH.Class.Num.Resize rep_XuIN
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
              @ size_XuIP
              @ (size_XuIP GHC.TypeLits.+ 2)
              $dKnownNat1_sxF6
              $dKnownNat_sxEM
              (eta1_sxED
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                            ~#
                          rep_XuIN size_XuIP))
            } } in
        let {
          sat_sxHf [Occ=Once] :: rep_XuIN (size_XuIP GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_sxHf =
            case tup2_sxEY
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_sxH8 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_sxH8
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                     :: CLaSH.Class.Num.Resize rep_XuIN
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
              @ size_XuIP
              @ (size_XuIP GHC.TypeLits.+ 2)
              $dKnownNat1_sxF6
              $dKnownNat_sxEM
              (eta_sxEC
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                            ~#
                          rep_XuIN size_XuIP))
            } } in
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl3_sxGZ
          sat_sxHf
          sat_sxHt
        } } in
    let {
      sat_sxGT [Occ=Once]
        :: Data.Bits.Bits (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_sxGT =
        case tup1_sxEE
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_sxGS [Occ=Once]) ->
        tpl9_sxGS
        } } in
    let {
      sat_sxGH [Occ=Once] :: GHC.Enum.Bounded (rep_XuIN size_XuIP)
      [LclId, Str=DmdType]
      sat_sxGH =
        case tup2_sxEY
        of _ [Occ=Dead]
        { (tpl_sxGv [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxGv
        } } in
    let {
      sat_sxGt [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize
             (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
           ~ (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxGt =
        case tup1_sxEE
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_sxGo [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_sxGo
        } } in
    let {
      sat_sxGh [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize (rep_XuIN size_XuIP) ~ size_XuIP
      [LclId, Str=DmdType]
      sat_sxGh =
        case tup1_sxEE
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_sxGb [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_sxGb
        } } in
    let {
      sat_sxG5 [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector
             (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_sxG5 =
        case tup1_sxEE
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_sxFY [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_sxFY
        } } in
    let {
      sat_sxFT [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector (rep_XuIN size_XuIP)
      [LclId, Str=DmdType]
      sat_sxFT =
        case tup1_sxEE
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_sxFL [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_sxFL
        } } in
    let {
      sat_sxFH [Occ=Once]
        :: ((size_XuIP GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxFH =
        case tup1_sxEE
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_sxFy [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_sxFy
        } } in
    let {
      sat_sxFv [Occ=Once] :: 1 GHC.TypeLits.<= size_XuIP
      [LclId, Str=DmdType]
      sat_sxFv =
        case tup1_sxEE
        of _ [Occ=Dead]
        { (tpl_sxFl [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxFl
        } } in
    let {
      sat_sxGU [Occ=Once] :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId, Str=DmdType]
      sat_sxGU =
        (sat_sxFv,
         sat_sxFH,
         sat_sxFT,
         sat_sxG5,
         sat_sxGh,
         sat_sxGt,
         $dKnownNat1_sxF6,
         $dKnownNat_sxEM,
         sat_sxGH,
         sat_sxGT) } in
    (CLaSH.Sized.Fixed.satN2 @ rep_XuIN @ size_XuIP sat_sxGU sat_sxHu)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

CLaSH.Sized.Fixed.$fNumFixed_$c*
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$c* =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_sxHv
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_sxHw [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta1_sxHx [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup1_sxHy
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId, Str=DmdType]
      tup1_sxHy =
        case tup_sxHv
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_sxHB [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_sxHB
        } } in
    let {
      $dBits_sxHG
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      $dBits_sxHG =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_sxHM [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_sxHM
        } } in
    let {
      sat_sxKk [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             rep_XuIO
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      [LclId, Str=DmdType]
      sat_sxKk =
        case tup_sxHv
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_sxKh [Occ=Once], tpl5_sxKi [Occ=Once!]) ->
        case tpl5_sxKi of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw1a ->
        ((tpl4_sxKh
          `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                    <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                  :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                       ~#
                     (rep_XuIO size_XuIQ
                      -> rep_XuIO size_XuIQ
                      -> CLaSH.Class.Num.MResult
                           (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
           (eta_sxHw
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ))
           (eta1_sxHx
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ)))
        `cast` (Sub cobox1_dw1a
                ; Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                             GHC.TypeLits.+ size_XuIQ>_N
                :: CLaSH.Class.Num.MResult
                     (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                     ~#
                   CLaSH.Sized.Fixed.Fixed
                     (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                     rep_XuIO
                     (size_XuIQ GHC.TypeLits.+ size_XuIQ))
        }
        } } in
    let {
      sat_sxKa [Occ=Once]
        :: GHC.Enum.Bounded (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      sat_sxKa =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_sxK9 [Occ=Once]) ->
        tpl11_sxK9
        } } in
    let {
      sat_sxJW [Occ=Once]
        :: GHC.TypeLits.KnownNat (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      [LclId, Str=DmdType]
      sat_sxJW =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_sxJU [Occ=Once], _ [Occ=Dead]) ->
        tpl10_sxJU
        } } in
    let {
      sat_sxJI [Occ=Once] :: GHC.TypeLits.KnownNat frac_XuIM
      [LclId, Str=DmdType]
      sat_sxJI =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_sxJF [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl9_sxJF
        } } in
    let {
      sat_sxJu [Occ=Once] :: Data.Bits.Bits (rep_XuIO size_XuIQ)
      [LclId, Str=DmdType]
      sat_sxJu =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl8_sxJq [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl8_sxJq
        } } in
    let {
      sat_sxJg [Occ=Once]
        :: GHC.TypeLits.KnownNat (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      [LclId, Str=DmdType]
      sat_sxJg =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxJb [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_sxJb
        } } in
    let {
      sat_sxJ2 [Occ=Once] :: GHC.TypeLits.KnownNat size_XuIQ
      [LclId, Str=DmdType]
      sat_sxJ2 =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxIW [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_sxIW
        } } in
    let {
      sat_sxIO [Occ=Once] :: CLaSH.Class.Num.Resize rep_XuIO
      [LclId, Str=DmdType]
      sat_sxIO =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_sxIH [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_sxIH
        } } in
    let {
      sat_sxIA [Occ=Once]
        :: GHC.Num.Num (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      sat_sxIA =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_sxIr [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_sxIr
        } } in
    let {
      sat_sxIm [Occ=Once]
        :: GHC.Classes.Ord (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      sat_sxIm =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_sxIc [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_sxIc
        } } in
    let {
      sat_sxI8 [Occ=Once]
        :: GHC.Classes.Eq (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      sat_sxI8 =
        Data.Bits.$p1Bits
          @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_sxHG } in
    let {
      sat_sxI7 [Occ=Once] :: GHC.Enum.Bounded (rep_XuIO size_XuIQ)
      [LclId, Str=DmdType]
      sat_sxI7 =
        case tup1_sxHy
        of _ [Occ=Dead]
        { (tpl_sxHV [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxHV
        } } in
    let {
      sat_sxKb [Occ=Once]
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId, Str=DmdType]
      sat_sxKb =
        (sat_sxI7,
         sat_sxI8,
         sat_sxIm,
         sat_sxIA,
         $dBits_sxHG,
         sat_sxIO,
         sat_sxJ2,
         sat_sxJg,
         sat_sxJu,
         sat_sxJI,
         sat_sxJW,
         sat_sxKa) } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      sat_sxKb
      sat_sxKk

CLaSH.Sized.Fixed.$fNumFixed_$c+
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$c+ =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_sxKl
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_sxKm [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta1_sxKn [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup1_sxKo :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      tup1_sxKo =
        case tup_sxKl
        of _ [Occ=Dead]
        { (tpl_sxKq [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxKq
        } } in
    let {
      $dKnownNat_sxKw
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_sxKw =
        case tup1_sxKo
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_sxKF [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_sxKF
        } } in
    let {
      tup2_sxKI
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId, Str=DmdType]
      tup2_sxKI =
        case tup_sxKl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_sxKL [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_sxKL
        } } in
    let {
      $dKnownNat1_sxKQ :: GHC.TypeLits.KnownNat size_XuIR
      [LclId, Str=DmdType]
      $dKnownNat1_sxKQ =
        case tup2_sxKI
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_sxKY [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_sxKY
        } } in
    let {
      sat_sxNe [Occ=Once] :: rep_XuIP (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxNe =
        case tup_sxKl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_sxMJ [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        let {
          sat_sxNd [Occ=Once] :: rep_XuIP (size_XuIR GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_sxNd =
            case tup2_sxKI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_sxN6 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_sxN6
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                     :: CLaSH.Class.Num.Resize rep_XuIP
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
              @ size_XuIR
              @ (size_XuIR GHC.TypeLits.+ 2)
              $dKnownNat1_sxKQ
              $dKnownNat_sxKw
              (eta1_sxKn
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                            ~#
                          rep_XuIP size_XuIR))
            } } in
        let {
          sat_sxMZ [Occ=Once] :: rep_XuIP (size_XuIR GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_sxMZ =
            case tup2_sxKI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_sxMS [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_sxMS
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                     :: CLaSH.Class.Num.Resize rep_XuIP
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
              @ size_XuIR
              @ (size_XuIR GHC.TypeLits.+ 2)
              $dKnownNat1_sxKQ
              $dKnownNat_sxKw
              (eta_sxKm
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                            ~#
                          rep_XuIP size_XuIR))
            } } in
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl3_sxMJ
          sat_sxMZ
          sat_sxNd
        } } in
    let {
      sat_sxMD [Occ=Once]
        :: Data.Bits.Bits (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_sxMD =
        case tup1_sxKo
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_sxMC [Occ=Once]) ->
        tpl9_sxMC
        } } in
    let {
      sat_sxMr [Occ=Once] :: GHC.Enum.Bounded (rep_XuIP size_XuIR)
      [LclId, Str=DmdType]
      sat_sxMr =
        case tup2_sxKI
        of _ [Occ=Dead]
        { (tpl_sxMf [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxMf
        } } in
    let {
      sat_sxMd [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize
             (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
           ~ (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxMd =
        case tup1_sxKo
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_sxM8 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_sxM8
        } } in
    let {
      sat_sxM1 [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR) ~ size_XuIR
      [LclId, Str=DmdType]
      sat_sxM1 =
        case tup1_sxKo
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_sxLV [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_sxLV
        } } in
    let {
      sat_sxLP [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector
             (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_sxLP =
        case tup1_sxKo
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_sxLI [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_sxLI
        } } in
    let {
      sat_sxLD [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)
      [LclId, Str=DmdType]
      sat_sxLD =
        case tup1_sxKo
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_sxLv [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_sxLv
        } } in
    let {
      sat_sxLr [Occ=Once]
        :: ((size_XuIR GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_sxLr =
        case tup1_sxKo
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_sxLi [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_sxLi
        } } in
    let {
      sat_sxLf [Occ=Once] :: 1 GHC.TypeLits.<= size_XuIR
      [LclId, Str=DmdType]
      sat_sxLf =
        case tup1_sxKo
        of _ [Occ=Dead]
        { (tpl_sxL5 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_sxL5
        } } in
    let {
      sat_sxME [Occ=Once] :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      sat_sxME =
        (sat_sxLf,
         sat_sxLr,
         sat_sxLD,
         sat_sxLP,
         sat_sxM1,
         sat_sxMd,
         $dKnownNat1_sxKQ,
         $dKnownNat_sxKw,
         sat_sxMr,
         sat_sxMD) } in
    (CLaSH.Sized.Fixed.satN2 @ rep_XuIP @ size_XuIR sat_sxME sat_sxNe)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[GblId[DFunId], Arity=1, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_sxNf
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    let {
      sat_sxNm [Occ=Once]
        :: GHC.Integer.Type.Integer
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_sxNm =
        \ (eta_B1 [Occ=Once] :: GHC.Integer.Type.Integer) ->
          CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_sxNf eta_B1 } in
    let {
      sat_sxNl [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_sxNl =
        (\ (eta_B1 [Occ=Once]
              :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
           CLaSH.Sized.Fixed.$fNumFixed1
             @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_sxNf eta_B1)
        `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                    -> rep_XuIQ size_XuIS)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)) } in
    let {
      sat_sxNk [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_sxNk =
        \ (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$cabs
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_sxNf eta_B1 } in
    let {
      sat_sxNj [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_sxNj =
        \ (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$cnegate
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_sxNf eta_B1 } in
    let {
      sat_sxNi [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_sxNi =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$c-
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_sxNf eta_B2 eta_B1 } in
    let {
      sat_sxNh [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_sxNh =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$c*
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_sxNf eta_B2 eta_B1 } in
    let {
      sat_sxNg [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_sxNg =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$c+
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_sxNf eta_B2 eta_B1 } in
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      sat_sxNg
      sat_sxNh
      sat_sxNi
      sat_sxNj
      sat_sxNk
      sat_sxNl
      sat_sxNm

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_sxNn
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    let {
      lvl1_sxNo [Occ=OnceL!]
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
           -> rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      lvl1_sxNo =
        CLaSH.Class.BitVector.fromBV
          @ (rep_XuIP size_XuIR) $dBitVector_sxNn } in
    let {
      lvl2_sxNp [Occ=OnceL!]
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           rep_XuIP size_XuIR
           -> CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      lvl2_sxNp =
        CLaSH.Class.BitVector.toBV
          @ (rep_XuIP size_XuIR) $dBitVector_sxNn } in
    let {
      sat_sxNv [Occ=Once]
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize
                (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize
                (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
             CLaSH.Bit.Bit
           -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      sat_sxNv =
        (\ ($dKnownNat_sxNt [Occ=Once]
              :: GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
           (bv_sxNu [Occ=Once]
              :: CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                   CLaSH.Bit.Bit) ->
           lvl1_sxNo
             ($dKnownNat_sxNt
              `cast` ((GHC.TypeLits.KnownNat
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                      :: GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize
                              (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                           ~#
                         GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
             (bv_sxNu
              `cast` ((CLaSH.Sized.Vector.Vec
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                         <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec
                           (CLaSH.Class.BitVector.BitSize
                              (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                           CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                           CLaSH.Bit.Bit)))
        `cast` (<GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
                -> <CLaSH.Sized.Vector.Vec
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                      CLaSH.Bit.Bit>_R
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                :: (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Vector.Vec
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                      CLaSH.Bit.Bit
                    -> rep_XuIP size_XuIR)
                     ~#
                   (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Vector.Vec
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                      CLaSH.Bit.Bit
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) } in
    let {
      sat_sxNs [Occ=Once]
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize
                (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
           -> CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      sat_sxNs =
        (\ ($dKnownNat_sxNq [Occ=Once]
              :: GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
           (ds_sxNr [Occ=Once]
              :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
           lvl2_sxNp
             ($dKnownNat_sxNq
              `cast` ((GHC.TypeLits.KnownNat
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                      :: GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize
                              (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                           ~#
                         GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
             (ds_sxNr
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))
        `cast` (<GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
                -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
                -> (CLaSH.Sized.Vector.Vec
                      (Sym
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                      <CLaSH.Bit.Bit>_R)_R
                :: (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                    -> CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                     ~#
                   (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                    -> CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize
                            (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                         CLaSH.Bit.Bit)) } in
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      sat_sxNs
      sat_sxNv

CLaSH.Sized.Fixed.$fDefaultFixed1
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fDefaultFixed1 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_sxNw [Occ=Once]
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_sxNw

CLaSH.Sized.Fixed.$fDefaultFixed_$cdef
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fDefaultFixed_$cdef =
  (\ (@ (frac_auGL :: GHC.TypeLits.Nat))
     (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
     (@ (size_auGN :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
     CLaSH.Sized.Fixed.$fDefaultFixed1
       @ frac_auGL @ rep_auGM @ size_auGN eta_B1)
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[GblId[DFunId(nt)],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fDefaultFixed =
  (\ (@ (frac_auGL :: GHC.TypeLits.Nat))
     (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
     (@ (size_auGN :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
     CLaSH.Sized.Fixed.$fDefaultFixed1
       @ frac_auGL @ rep_auGM @ size_auGN eta_B1)
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_sxNx :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    let {
      sat_sxNz [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0
      [LclId, Str=DmdType]
      sat_sxNz =
        (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_sxNx)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                :: rep_XuIY size_XuJ0
                     ~#
                   CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0) } in
    let {
      sat_sxNy [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0
      [LclId, Str=DmdType]
      sat_sxNy =
        (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_sxNx)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                :: rep_XuIY size_XuJ0
                     ~#
                   CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0) } in
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      sat_sxNy
      sat_sxNz

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[GblId[DFunId[1]],
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_sxNA [Occ=Once]
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_sxNB :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    let {
      sat_sxNI [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
      [LclId, Str=DmdType]
      sat_sxNI =
        (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_sxNB)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)) } in
    let {
      sat_sxNH [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
      [LclId, Str=DmdType]
      sat_sxNH =
        (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_sxNB)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)) } in
    let {
      sat_sxNG [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_sxNG =
        (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_sxNB)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Bool)) } in
    let {
      sat_sxNF [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_sxNF =
        (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_sxNB)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Bool)) } in
    let {
      sat_sxNE [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_sxNE =
        (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_sxNB)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Bool)) } in
    let {
      sat_sxND [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_sxND =
        (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_sxNB)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Bool)) } in
    let {
      sat_sxNC [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Ordering
      [LclId, Str=DmdType]
      sat_sxNC =
        (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_sxNB)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Ordering>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Ordering)) } in
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_sxNA
      sat_sxNC
      sat_sxND
      sat_sxNE
      sat_sxNF
      sat_sxNG
      sat_sxNH
      sat_sxNI

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_sxNJ :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    let {
      sat_sxNL [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
           -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_sxNL =
        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_sxNJ)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                    -> GHC.Types.Bool)) } in
    let {
      sat_sxNK [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
           -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_sxNK =
        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_sxNJ)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                    -> GHC.Types.Bool)) } in
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      sat_sxNK
      sat_sxNL

CLaSH.Sized.Fixed.$fLiftFixed12
  :: Language.Haskell.TH.Syntax.NameFlavour
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed12 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (CLaSH.Sized.Fixed.$fLiftFixed6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (CLaSH.Sized.Fixed.$fLiftFixed5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

CLaSH.Sized.Fixed.$fLiftFixed11 :: Language.Haskell.TH.Syntax.Name
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed11 =
  Language.Haskell.TH.Syntax.Name
    (CLaSH.Sized.Fixed.$fLiftFixed7
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    CLaSH.Sized.Fixed.$fLiftFixed12

CLaSH.Sized.Fixed.$fLiftFixed10 :: Language.Haskell.TH.Syntax.Type
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed10 =
  Language.Haskell.TH.Syntax.ConT CLaSH.Sized.Fixed.$fLiftFixed11

CLaSH.Sized.Fixed.$fLiftFixed9
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[GblId, Arity=1, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed9 =
  \ (@ (m_a4Ni :: * -> *))
    (eta_sxNM [Occ=Once] :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    case Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_sxNM
    of sat_sxNN { __DEFAULT ->
    GHC.Base.return
      @ m_a4Ni
      sat_sxNN
      @ Language.Haskell.TH.Syntax.Type
      CLaSH.Sized.Fixed.$fLiftFixed10
    }

Rec {
CLaSH.Sized.Fixed.$fLiftFixed_lgo [Occ=LoopBreaker]
  :: Language.Haskell.TH.Lib.TypeQ
     -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <L,U><S,1*U>,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed_lgo =
  \ (z_sxNO [Occ=OnceL*] :: Language.Haskell.TH.Lib.TypeQ)
    (ds_sxNP [Occ=Once!] :: [Language.Haskell.TH.Lib.TypeQ]) ->
    case ds_sxNP of _ [Occ=Dead] {
      [] -> z_sxNO;
      : x_sxNR [Occ=OnceL] xs_sxNS [Occ=Once] ->
        let {
          sat_sxNT [Occ=Once] :: Language.Haskell.TH.Lib.TypeQ
          [LclId, Str=DmdType]
          sat_sxNT =
            (\ (@ (m_a4Jw :: * -> *))
               (eta_B1 [Occ=Once] :: Language.Haskell.TH.Syntax.Quasi m_a4Jw) ->
               Language.Haskell.TH.Lib.appT1 z_sxNO x_sxNR @ m_a4Jw eta_B1)
            `cast` (Sym
                      (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N)
                    :: (forall (m_a4LE :: * -> *).
                        Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                        m_a4LE Language.Haskell.TH.Syntax.Type)
                         ~#
                       Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type) } in
        CLaSH.Sized.Fixed.$fLiftFixed_lgo sat_sxNT xs_sxNS
    }
end Rec }

CLaSH.Sized.Fixed.$fLiftFixed8 :: Language.Haskell.TH.Syntax.Name
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed8 =
  Language.Haskell.TH.Syntax.Name
    ((GHC.Types.[] @ GHC.Types.Char)
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    Language.Haskell.TH.Syntax.NameS

CLaSH.Sized.Fixed.$fLiftFixed1
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed1 =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_sxNU
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_sxNV [Occ=Once] :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat1_sxNW [Occ=Once] :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_sxNX [Occ=Once]
       :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_sxNY [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    let {
      w1_sxNZ :: Language.Haskell.TH.Lib.TypeQ
      [LclId, Str=DmdType]
      w1_sxNZ =
        let {
          l_sxOt :: Language.Haskell.TH.Lib.TyLitQ
          [LclId, Str=DmdType]
          l_sxOt =
            Language.Haskell.TH.Lib.numTyLit
              ($dKnownNat1_sxNW
               `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                       ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                       :: GHC.TypeLits.KnownNat size_auGQ
                            ~#
                          GHC.Integer.Type.Integer)) } in
        let {
          sat_sxOy :: Language.Haskell.TH.Lib.TypeQ
          [LclId, Str=DmdType]
          sat_sxOy =
            (\ (@ (m_a5E0 :: * -> *))
               (eta_sxOu :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
               let {
                 sat_sxOx [Occ=Once] :: m_a5E0 Language.Haskell.TH.Syntax.TyLit
                 [LclId, Str=DmdType]
                 sat_sxOx =
                   (l_sxOt
                    `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.TyLit>_N
                            :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                 ~#
                               (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                     @ m_a5E0 eta_sxOu } in
               case Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_sxOu
               of sat_sxOv { __DEFAULT ->
               case Control.Applicative.$p1Applicative @ m_a5E0 sat_sxOv
               of sat_sxOw { __DEFAULT ->
               GHC.Base.fmap
                 @ m_a5E0
                 sat_sxOw
                 @ Language.Haskell.TH.Syntax.TyLit
                 @ Language.Haskell.TH.Syntax.Type
                 Language.Haskell.TH.Syntax.LitT
                 sat_sxOx
               }
               })
            `cast` (Sym
                      (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N)
                    :: (forall (m_a4LE :: * -> *).
                        Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                        m_a4LE Language.Haskell.TH.Syntax.Type)
                         ~#
                       Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type) } in
        let {
          sat_sxOz :: [Language.Haskell.TH.Lib.TypeQ]
          [LclId, Str=DmdType]
          sat_sxOz =
            GHC.Types.:
              @ Language.Haskell.TH.Lib.TypeQ
              sat_sxOy
              (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ) } in
        let {
          x_sxO6 :: Language.Haskell.TH.Syntax.Name
          [LclId, Str=DmdType]
          x_sxO6 =
            case ($dTypeable_sxNX
                  `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                            <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                          :: Data.Typeable.Internal.Typeable rep_auGP
                               ~#
                             (GHC.Prim.Proxy# rep_auGP -> Data.Typeable.Internal.TypeRep)))
                   (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP)
            of _ [Occ=Dead]
            { Data.Typeable.Internal.TypeRep _ [Occ=Dead] _ [Occ=Dead]
                                             ww3_sxOa [Occ=Once] ww4_sxOb [Occ=Once] ->
            case Data.Typeable.Internal.$w$cshowsPrec
                   GHC.Show.shows27 ww3_sxOa ww4_sxOb (GHC.Types.[] @ GHC.Types.Char)
            of sat_sxOc { __DEFAULT ->
            case GHC.List.reverse1
                   @ GHC.Types.Char sat_sxOc (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] {
              [] -> CLaSH.Sized.Fixed.$fLiftFixed8;
              : ds_sxOe [Occ=Once!] rev_sxOf [Occ=Once*] ->
                case ds_sxOe of wild22_sxOg { GHC.Types.C# ds1_sxOh [Occ=Once!] ->
                case ds1_sxOh of _ [Occ=Dead] {
                  __DEFAULT ->
                    case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                           wild22_sxOg (GHC.Types.[] @ GHC.Types.Char) rev_sxOf
                    of _ [Occ=Dead] { (# ww6_sxOk [Occ=Once], ww7_sxOl [Occ=Once] #) ->
                    Language.Haskell.TH.Syntax.Name ww6_sxOk ww7_sxOl
                    };
                  '.' ->
                    case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                           wild22_sxOg (GHC.Types.[] @ GHC.Types.Char) rev_sxOf
                    of _ [Occ=Dead] { (# ww6_sxOn [Occ=Once], ww7_sxOo [Occ=Once] #) ->
                    Language.Haskell.TH.Syntax.Name ww6_sxOn ww7_sxOo
                    }
                }
                }
            }
            }
            } } in
        let {
          lvl1_sxOp :: Language.Haskell.TH.Syntax.Type
          [LclId, Str=DmdType, Unf=OtherCon []]
          lvl1_sxOp = Language.Haskell.TH.Syntax.ConT x_sxO6 } in
        let {
          sat_sxOs :: Language.Haskell.TH.Lib.TypeQ
          [LclId, Str=DmdType]
          sat_sxOs =
            (\ (@ (m_X4Tv :: * -> *))
               (eta_sxOq [Occ=Once] :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
               case Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_sxOq
               of sat_sxOr { __DEFAULT ->
               GHC.Base.return
                 @ m_X4Tv sat_sxOr @ Language.Haskell.TH.Syntax.Type lvl1_sxOp
               })
            `cast` (Sym
                      (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N)
                    :: (forall (m_a4LE :: * -> *).
                        Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                        m_a4LE Language.Haskell.TH.Syntax.Type)
                         ~#
                       Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type) } in
        let {
          sat_sxOA :: [Language.Haskell.TH.Lib.TypeQ]
          [LclId, Str=DmdType]
          sat_sxOA =
            GHC.Types.: @ Language.Haskell.TH.Lib.TypeQ sat_sxOs sat_sxOz } in
        let {
          l_sxO0 :: Language.Haskell.TH.Lib.TyLitQ
          [LclId, Str=DmdType]
          l_sxO0 =
            Language.Haskell.TH.Lib.numTyLit
              ($dKnownNat_sxNV
               `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                       ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                       :: GHC.TypeLits.KnownNat frac_auGO
                            ~#
                          GHC.Integer.Type.Integer)) } in
        let {
          sat_sxO5 :: Language.Haskell.TH.Lib.TypeQ
          [LclId, Str=DmdType]
          sat_sxO5 =
            (\ (@ (m_a5E0 :: * -> *))
               (eta_sxO1 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
               let {
                 sat_sxO4 [Occ=Once] :: m_a5E0 Language.Haskell.TH.Syntax.TyLit
                 [LclId, Str=DmdType]
                 sat_sxO4 =
                   (l_sxO0
                    `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.TyLit>_N
                            :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                 ~#
                               (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                     @ m_a5E0 eta_sxO1 } in
               case Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_sxO1
               of sat_sxO2 { __DEFAULT ->
               case Control.Applicative.$p1Applicative @ m_a5E0 sat_sxO2
               of sat_sxO3 { __DEFAULT ->
               GHC.Base.fmap
                 @ m_a5E0
                 sat_sxO3
                 @ Language.Haskell.TH.Syntax.TyLit
                 @ Language.Haskell.TH.Syntax.Type
                 Language.Haskell.TH.Syntax.LitT
                 sat_sxO4
               }
               })
            `cast` (Sym
                      (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N)
                    :: (forall (m_a4LE :: * -> *).
                        Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                        m_a4LE Language.Haskell.TH.Syntax.Type)
                         ~#
                       Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type) } in
        let {
          sat_sxOB [Occ=Once] :: [Language.Haskell.TH.Lib.TypeQ]
          [LclId, Str=DmdType]
          sat_sxOB =
            GHC.Types.: @ Language.Haskell.TH.Lib.TypeQ sat_sxO5 sat_sxOA } in
        CLaSH.Sized.Fixed.$fLiftFixed_lgo
          (CLaSH.Sized.Fixed.$fLiftFixed9
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          sat_sxOB } in
    let {
      w2_sxOC :: Language.Haskell.TH.Lib.ExpQ
      [LclId, Str=DmdType]
      w2_sxOC =
        ($dLift_sxNU
         `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                   <rep_auGP size_auGQ>_N
                 :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                      ~#
                    (rep_auGP size_auGQ
                     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
          (f_sxNY
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                        ~#
                      rep_auGP size_auGQ)) } in
    let {
      sat_sxPg [Occ=Once]
        :: forall (m_akV3 :: * -> *).
           Language.Haskell.TH.Syntax.Quasi m_akV3 =>
           m_akV3 Language.Haskell.TH.Syntax.Exp
      [LclId, Str=DmdType]
      sat_sxPg =
        \ (@ (m_akV3 :: * -> *))
          (w3_sxOD [Occ=Once!] :: Language.Haskell.TH.Syntax.Quasi m_akV3) ->
          case w3_sxOD
          of ww_sxOE
          { Language.Haskell.TH.Syntax.D:Quasi ww1_sxOF [Occ=Once!]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] ->
          case ww1_sxOF
          of _ [Occ=Dead]
          { GHC.Base.D:Monad ww20_sxOY _ [Occ=Dead] ww22_sxP0 _ [Occ=Dead] ->
          let {
            lvl1_sxP2 [Occ=OnceL] :: m_akV3 Language.Haskell.TH.Syntax.Type
            [LclId, Str=DmdType]
            lvl1_sxP2 =
              (w1_sxNZ
               `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N
                       :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
                            ~#
                          (forall (m_a4LE :: * -> *).
                           Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                           m_a4LE Language.Haskell.TH.Syntax.Type)))
                @ m_akV3 ww_sxOE } in
          let {
            sat_sxPf [Occ=Once]
              :: Language.Haskell.TH.Syntax.Exp
                 -> m_akV3 Language.Haskell.TH.Syntax.Exp
            [LclId, Str=DmdType]
            sat_sxPf =
              \ (x_sxPb [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp) ->
                let {
                  sat_sxPe [Occ=Once]
                    :: Language.Haskell.TH.Syntax.Type
                       -> m_akV3 Language.Haskell.TH.Syntax.Exp
                  [LclId, Str=DmdType]
                  sat_sxPe =
                    \ (x1_sxPc [Occ=Once] :: Language.Haskell.TH.Syntax.Type) ->
                      let {
                        sat_sxPd [Occ=Once] :: Language.Haskell.TH.Syntax.Exp
                        [LclId, Str=DmdType]
                        sat_sxPd = Language.Haskell.TH.Syntax.SigE x_sxPb x1_sxPc } in
                      ww22_sxP0 @ Language.Haskell.TH.Syntax.Exp sat_sxPd } in
                ww20_sxOY
                  @ Language.Haskell.TH.Syntax.Type
                  @ Language.Haskell.TH.Syntax.Exp
                  lvl1_sxP2
                  sat_sxPe } in
          let {
            sat_sxPa [Occ=Once] :: m_akV3 Language.Haskell.TH.Syntax.Exp
            [LclId, Str=DmdType]
            sat_sxPa =
              let {
                lvl2_sxP3 [Occ=OnceL] :: m_akV3 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                lvl2_sxP3 =
                  (w2_sxOC
                   `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Exp>_N
                           :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
                                ~#
                              (forall (m_a4LE :: * -> *).
                               Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                               m_a4LE Language.Haskell.TH.Syntax.Exp)))
                    @ m_akV3 ww_sxOE } in
              let {
                sat_sxP9 [Occ=Once]
                  :: Language.Haskell.TH.Syntax.Exp
                     -> m_akV3 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                sat_sxP9 =
                  \ (x_sxP5 [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp) ->
                    let {
                      sat_sxP8 [Occ=Once]
                        :: Language.Haskell.TH.Syntax.Exp
                           -> m_akV3 Language.Haskell.TH.Syntax.Exp
                      [LclId, Str=DmdType]
                      sat_sxP8 =
                        \ (x1_sxP6 [Occ=Once] :: Language.Haskell.TH.Syntax.Exp) ->
                          let {
                            sat_sxP7 [Occ=Once] :: Language.Haskell.TH.Syntax.Exp
                            [LclId, Str=DmdType]
                            sat_sxP7 = Language.Haskell.TH.Syntax.AppE x_sxP5 x1_sxP6 } in
                          ww22_sxP0 @ Language.Haskell.TH.Syntax.Exp sat_sxP7 } in
                    ww20_sxOY
                      @ Language.Haskell.TH.Syntax.Exp
                      @ Language.Haskell.TH.Syntax.Exp
                      lvl2_sxP3
                      sat_sxP8 } in
              let {
                sat_sxP4 [Occ=Once] :: m_akV3 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                sat_sxP4 =
                  ww22_sxP0
                    @ Language.Haskell.TH.Syntax.Exp
                    CLaSH.Sized.Fixed.$fLiftFixed2 } in
              ww20_sxOY
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                sat_sxP4
                sat_sxP9 } in
          ww20_sxOY
            @ Language.Haskell.TH.Syntax.Exp
            @ Language.Haskell.TH.Syntax.Exp
            sat_sxPa
            sat_sxPf
          }
          } } in
    sat_sxPg

CLaSH.Sized.Fixed.$fLiftFixed_$clift
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed_$clift =
  (\ (@ (frac_auGO :: GHC.TypeLits.Nat))
     (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
     (@ (size_auGQ :: GHC.TypeLits.Nat))
     (eta_B5 [Occ=Once]
        :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
     (eta_B4 [Occ=Once] :: GHC.TypeLits.KnownNat frac_auGO)
     (eta_B3 [Occ=Once] :: GHC.TypeLits.KnownNat size_auGQ)
     (eta_B2 [Occ=Once] :: Data.Typeable.Internal.Typeable rep_auGP)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
     CLaSH.Sized.Fixed.$fLiftFixed1
       @ frac_auGO
       @ rep_auGP
       @ size_auGQ
       eta_B5
       eta_B4
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[GblId[DFunId(nt)], Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed =
  (\ (@ (frac_auGO :: GHC.TypeLits.Nat))
     (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
     (@ (size_auGQ :: GHC.TypeLits.Nat))
     (eta_B5 [Occ=Once]
        :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
     (eta_B4 [Occ=Once] :: GHC.TypeLits.KnownNat frac_auGO)
     (eta_B3 [Occ=Once] :: GHC.TypeLits.KnownNat size_auGQ)
     (eta_B2 [Occ=Once] :: Data.Typeable.Internal.Typeable rep_auGP)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
     CLaSH.Sized.Fixed.$fLiftFixed1
       @ frac_auGO
       @ rep_auGP
       @ size_auGQ
       eta_B5
       eta_B4
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))



*** Stg2Stg:
*** CodeOutput:
*** New CodeGen:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** Assembler:
*** CorePrep:

==================== CorePrep ====================
Result size of CorePrep
  = {terms: 2,838, types: 10,385, coercions: 947}

lvl_rxjb :: [GHC.Types.Char]
[GblId, Str=DmdType]
lvl_rxjb = GHC.CString.unpackCString# "Negative exponent"#

CLaSH.Sized.Fixed.$s^1 :: GHC.Types.Double
[GblId, Str=DmdType b]
CLaSH.Sized.Fixed.$s^1 = GHC.Err.error @ GHC.Types.Double lvl_rxjb

CLaSH.Sized.Fixed.$s^2 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$s^2 = GHC.Types.D# 1.0

CLaSH.Sized.Fixed.$fShowFixed4 :: GHC.Integer.Type.Integer
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed4 = GHC.Integer.Type.S# 1

CLaSH.Sized.Fixed.$fShowFixed5 :: GHC.Integer.Type.Integer
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed5 = GHC.Integer.Type.S# 2

Rec {
CLaSH.Sized.Fixed.$s^_g1 [Occ=LoopBreaker]
  :: GHC.Types.Double
     -> GHC.Integer.Type.Integer -> GHC.Types.Double -> GHC.Types.Double
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$s^_g1 =
  \ (x1_szif :: GHC.Types.Double)
    (y1_szig :: GHC.Integer.Type.Integer)
    (z_szih [Occ=Once*] :: GHC.Types.Double) ->
    case GHC.Integer.Type.remInteger y1_szig GHC.Real.even2
    of sat_szii { __DEFAULT ->
    case GHC.Integer.Type.eqInteger# sat_szii GHC.Real.even1
    of wild_szij { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_szij
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger#
               y1_szig CLaSH.Sized.Fixed.$fShowFixed4
        of wild1_szil { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1_szil
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              sat_sziq [Occ=Once] :: GHC.Types.Double
              [LclId, Str=DmdType]
              sat_sziq = GHC.Float.timesDouble x1_szif z_szih } in
            let {
              sat_szip [Occ=Once] :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              sat_szip =
                case GHC.Integer.Type.minusInteger
                       y1_szig CLaSH.Sized.Fixed.$fShowFixed4
                of sat_szio { __DEFAULT ->
                GHC.Integer.Type.quotInteger
                  sat_szio CLaSH.Sized.Fixed.$fShowFixed5
                } } in
            let {
              sat_szin [Occ=Once] :: GHC.Types.Double
              [LclId, Str=DmdType]
              sat_szin = GHC.Float.timesDouble x1_szif x1_szif } in
            CLaSH.Sized.Fixed.$s^_g1 sat_szin sat_szip sat_sziq;
          GHC.Types.True -> GHC.Float.timesDouble x1_szif z_szih
        }
        };
      GHC.Types.True ->
        let {
          sat_szis [Occ=Once] :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          sat_szis =
            GHC.Integer.Type.quotInteger
              y1_szig CLaSH.Sized.Fixed.$fShowFixed5 } in
        let {
          sat_szir [Occ=Once] :: GHC.Types.Double
          [LclId, Str=DmdType]
          sat_szir = GHC.Float.timesDouble x1_szif x1_szif } in
        CLaSH.Sized.Fixed.$s^_g1 sat_szir sat_szis z_szih
    }
    }
    }
end Rec }

Rec {
CLaSH.Sized.Fixed.$s^_f [Occ=LoopBreaker]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$s^_f =
  \ (x_szit :: GHC.Types.Double)
    (y_sziu :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.remInteger y_sziu GHC.Real.even2
    of sat_sziv { __DEFAULT ->
    case GHC.Integer.Type.eqInteger# sat_sziv GHC.Real.even1
    of wild_sziw { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_sziw
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger#
               y_sziu CLaSH.Sized.Fixed.$fShowFixed4
        of wild1_sziy { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1_sziy
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              sat_sziC [Occ=Once] :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              sat_sziC =
                case GHC.Integer.Type.minusInteger
                       y_sziu CLaSH.Sized.Fixed.$fShowFixed4
                of sat_sziB { __DEFAULT ->
                GHC.Integer.Type.quotInteger
                  sat_sziB CLaSH.Sized.Fixed.$fShowFixed5
                } } in
            let {
              sat_sziA [Occ=Once] :: GHC.Types.Double
              [LclId, Str=DmdType]
              sat_sziA = GHC.Float.timesDouble x_szit x_szit } in
            CLaSH.Sized.Fixed.$s^_g1 sat_sziA sat_sziC x_szit;
          GHC.Types.True -> x_szit
        }
        };
      GHC.Types.True ->
        let {
          sat_sziE [Occ=Once] :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          sat_sziE =
            GHC.Integer.Type.quotInteger
              y_sziu CLaSH.Sized.Fixed.$fShowFixed5 } in
        let {
          sat_sziD [Occ=Once] :: GHC.Types.Double
          [LclId, Str=DmdType]
          sat_sziD = GHC.Float.timesDouble x_szit x_szit } in
        CLaSH.Sized.Fixed.$s^_f sat_sziD sat_sziE
    }
    }
    }
end Rec }

CLaSH.Sized.Fixed.resizeF1 :: GHC.Integer.Type.Integer
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.resizeF1 = GHC.Integer.Type.S# 0

CLaSH.Sized.Fixed.$s^ [InlPrag=[1]]
  :: GHC.Types.Double -> GHC.Integer.Type.Integer -> GHC.Types.Double
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$s^ =
  \ (eta_sziF [Occ=Once] :: GHC.Types.Double)
    (eta1_sziG :: GHC.Integer.Type.Integer) ->
    case GHC.Integer.Type.ltInteger#
           eta1_sziG CLaSH.Sized.Fixed.resizeF1
    of wild_sziH { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_sziH
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case GHC.Integer.Type.eqInteger#
               eta1_sziG CLaSH.Sized.Fixed.resizeF1
        of wild2_sziJ { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2_sziJ
        of _ [Occ=Dead] {
          GHC.Types.False -> CLaSH.Sized.Fixed.$s^_f eta_sziF eta1_sziG;
          GHC.Types.True -> CLaSH.Sized.Fixed.$s^2
        }
        };
      GHC.Types.True -> CLaSH.Sized.Fixed.$s^1
    }
    }

CLaSH.Sized.Fixed.fLit8 :: GHC.Types.Double
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit8 = GHC.Types.D# 2.0

CLaSH.Sized.Fixed.$fLiftFixed7 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.$fLiftFixed7 =
  GHC.CString.unpackCString# "Fixed"#

CLaSH.Sized.Fixed.$fLiftFixed6 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.$fLiftFixed6 =
  GHC.CString.unpackCString# "clash-prelude-0.5"#

CLaSH.Sized.Fixed.$fLiftFixed5 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.$fLiftFixed5 =
  GHC.CString.unpackCString# "CLaSH.Sized.Fixed"#

CLaSH.Sized.Fixed.$fLiftFixed4
  :: Language.Haskell.TH.Syntax.NameFlavour
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed4 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.DataName
    (CLaSH.Sized.Fixed.$fLiftFixed6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (CLaSH.Sized.Fixed.$fLiftFixed5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

CLaSH.Sized.Fixed.$fLiftFixed3 :: Language.Haskell.TH.Syntax.Name
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed3 =
  Language.Haskell.TH.Syntax.Name
    (CLaSH.Sized.Fixed.$fLiftFixed7
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    CLaSH.Sized.Fixed.$fLiftFixed4

CLaSH.Sized.Fixed.fLit7 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.fLit7 = GHC.CString.unpackCString# "fromInteger"#

CLaSH.Sized.Fixed.fLit6 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.fLit6 = GHC.CString.unpackCString# "base"#

CLaSH.Sized.Fixed.fLit5 :: [GHC.Types.Char]
[GblId, Str=DmdType]
CLaSH.Sized.Fixed.fLit5 = GHC.CString.unpackCString# "GHC.Num"#

CLaSH.Sized.Fixed.fLit4 :: Language.Haskell.TH.Syntax.NameFlavour
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit4 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.VarName
    (CLaSH.Sized.Fixed.fLit6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (CLaSH.Sized.Fixed.fLit5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

CLaSH.Sized.Fixed.fLit3 :: Language.Haskell.TH.Syntax.Name
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit3 =
  Language.Haskell.TH.Syntax.Name
    (CLaSH.Sized.Fixed.fLit7
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    CLaSH.Sized.Fixed.fLit4

CLaSH.Sized.Fixed.$fLiftFixed2 :: Language.Haskell.TH.Syntax.Exp
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed2 =
  Language.Haskell.TH.Syntax.ConE CLaSH.Sized.Fixed.$fLiftFixed3

CLaSH.Sized.Fixed.fLit2 :: Language.Haskell.TH.Syntax.Exp
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit2 =
  Language.Haskell.TH.Syntax.VarE CLaSH.Sized.Fixed.fLit3

CLaSH.Sized.Fixed.fLit1
  :: forall (frac_avhM :: GHC.TypeLits.Nat)
            (rep_avhN :: GHC.TypeLits.Nat -> *)
            (size_avhO :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
      GHC.Enum.Bounded (rep_avhN size_avhO),
      GHC.Real.Integral (rep_avhN size_avhO)) =>
     GHC.Types.Double
     -> forall (m_aw9c :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_aw9c =>
        m_aw9c (Language.Haskell.TH.Syntax.TExp
                  (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit1 =
  \ (@ (frac_avhM :: GHC.TypeLits.Nat))
    (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
    (@ (size_avhO :: GHC.TypeLits.Nat))
    ($dKnownNat_sziL [Occ=Once] :: GHC.TypeLits.KnownNat frac_avhM)
    _ [Occ=Dead]
    ($dBounded_sziN :: GHC.Enum.Bounded (rep_avhN size_avhO))
    ($dIntegral_sziO :: GHC.Real.Integral (rep_avhN size_avhO))
    (a_sziP [Occ=Once!] :: GHC.Types.Double) ->
    let {
      x_sziQ :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      x_sziQ =
        let {
          truncated_sziR :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          truncated_sziR =
            case a_sziP of _ [Occ=Dead] { GHC.Types.D# x1_sziT [Occ=Once] ->
            case CLaSH.Sized.Fixed.$s^
                   CLaSH.Sized.Fixed.fLit8
                   ($dKnownNat_sziL
                    `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avhM>_N
                            ; GHC.TypeLits.NTCo:SNat[0] <frac_avhM>_P
                            :: GHC.TypeLits.KnownNat frac_avhM ~# GHC.Integer.Type.Integer))
            of _ [Occ=Dead] { GHC.Types.D# y_sziV [Occ=Once] ->
            case GHC.Prim.*## x1_sziT y_sziV of sat_sziW { __DEFAULT ->
            case GHC.Integer.Type.decodeDoubleInteger sat_sziW
            of _ [Occ=Dead] { (# ipv_sziY, ipv1_sziZ #) ->
            case GHC.Prim.<# ipv1_sziZ 0 of sat_szj0 { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_szj0
            of _ [Occ=Dead] {
              GHC.Types.False ->
                GHC.Integer.Type.shiftLInteger ipv_sziY ipv1_sziZ;
              GHC.Types.True ->
                case GHC.Prim.negateInt# ipv1_sziZ of s_szj2 { __DEFAULT ->
                case GHC.Prim.># s_szj2 52 of sat_szj3 { __DEFAULT ->
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_szj3
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    case GHC.Integer.Type.ltInteger#
                           ipv_sziY CLaSH.Sized.Fixed.resizeF1
                    of wild4_szj5 { __DEFAULT ->
                    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild4_szj5
                    of _ [Occ=Dead] {
                      GHC.Types.False ->
                        case GHC.Integer.Type.integerToInt ipv_sziY
                        of n_szj7 { __DEFAULT ->
                        case GHC.Prim.uncheckedIShiftRA# n_szj7 s_szj2
                        of sat_szj8 { __DEFAULT ->
                        GHC.Integer.Type.smallInteger sat_szj8
                        }
                        };
                      GHC.Types.True ->
                        case GHC.Integer.Type.negateInteger ipv_sziY
                        of sat_szj9 { __DEFAULT ->
                        case GHC.Integer.Type.integerToInt sat_szj9
                        of n_szja { __DEFAULT ->
                        case GHC.Prim.uncheckedIShiftRA# n_szja s_szj2
                        of sat_szjb { __DEFAULT ->
                        case GHC.Prim.negateInt# sat_szjb of sat_szjc { __DEFAULT ->
                        GHC.Integer.Type.smallInteger sat_szjc
                        }
                        }
                        }
                        }
                    }
                    };
                  GHC.Types.True -> CLaSH.Sized.Fixed.resizeF1
                }
                }
                }
            }
            }
            }
            }
            }
            } } in
        let {
          rMax_szjd :: GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          rMax_szjd =
            let {
              sat_szje [Occ=Once] :: rep_avhN size_avhO
              [LclId, Str=DmdType]
              sat_szje =
                GHC.Enum.maxBound @ (rep_avhN size_avhO) $dBounded_sziN } in
            GHC.Real.toInteger
              @ (rep_avhN size_avhO) $dIntegral_sziO sat_szje } in
        case GHC.Integer.Type.gtInteger# truncated_sziR rMax_szjd
        of wild_szjf { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_szjf
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              rMin_szjh :: GHC.Integer.Type.Integer
              [LclId, Str=DmdType]
              rMin_szjh =
                let {
                  sat_szji [Occ=Once] :: rep_avhN size_avhO
                  [LclId, Str=DmdType]
                  sat_szji =
                    GHC.Enum.minBound @ (rep_avhN size_avhO) $dBounded_sziN } in
                GHC.Real.toInteger
                  @ (rep_avhN size_avhO) $dIntegral_sziO sat_szji } in
            case GHC.Integer.Type.ltInteger# truncated_sziR rMin_szjh
            of wild2_szjj { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2_szjj
            of _ [Occ=Dead] {
              GHC.Types.False -> truncated_sziR;
              GHC.Types.True -> rMin_szjh
            }
            };
          GHC.Types.True -> rMax_szjd
        }
        } } in
    let {
      a1_szjl :: Language.Haskell.TH.Syntax.Lit
      [LclId, Str=DmdType, Unf=OtherCon []]
      a1_szjl = Language.Haskell.TH.Syntax.IntegerL x_sziQ } in
    let {
      lvl1_szjm [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp
      [LclId, Str=DmdType, Unf=OtherCon []]
      lvl1_szjm = Language.Haskell.TH.Syntax.LitE a1_szjl } in
    let {
      sat_szk3 [Occ=Once]
        :: forall (m_awx9 :: * -> *).
           Language.Haskell.TH.Syntax.Quasi m_awx9 =>
           m_awx9 (Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
      [LclId, Str=DmdType]
      sat_szk3 =
        \ (@ (m_awx9 :: * -> *))
          (w1_szjn [Occ=Once!] :: Language.Haskell.TH.Syntax.Quasi m_awx9) ->
          case w1_szjn
          of _ [Occ=Dead]
          { Language.Haskell.TH.Syntax.D:Quasi ww1_szjp [Occ=Once!]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] ->
          case ww1_szjp
          of _ [Occ=Dead]
          { GHC.Base.D:Monad ww20_szjI _ [Occ=Dead] ww22_szjK _ [Occ=Dead] ->
          let {
            sat_szk2 [Occ=Once]
              :: Language.Haskell.TH.Syntax.Exp
                 -> m_awx9 (Language.Haskell.TH.Syntax.TExp
                              (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
            [LclId, Str=DmdType]
            sat_szk2 =
              \ (x1_szk1 [Occ=Once] :: Language.Haskell.TH.Syntax.Exp) ->
                ww22_szjK
                  @ (Language.Haskell.TH.Syntax.TExp
                       (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
                  (x1_szk1
                   `cast` (Sym
                             (Language.Haskell.TH.Syntax.NTCo:TExp[0]
                                <CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO>_N)
                           :: Language.Haskell.TH.Syntax.Exp
                                ~#
                              Language.Haskell.TH.Syntax.TExp
                                (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))) } in
          let {
            sat_szk0 [Occ=Once] :: m_awx9 Language.Haskell.TH.Syntax.Exp
            [LclId, Str=DmdType]
            sat_szk0 =
              let {
                lvl2_szjM [Occ=OnceL] :: m_awx9 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                lvl2_szjM =
                  let {
                    lvl3_szjN [Occ=OnceL] :: m_awx9 Language.Haskell.TH.Syntax.Exp
                    [LclId, Str=DmdType]
                    lvl3_szjN =
                      ww22_szjK @ Language.Haskell.TH.Syntax.Exp lvl1_szjm } in
                  let {
                    sat_szjT [Occ=Once]
                      :: Language.Haskell.TH.Syntax.Exp
                         -> m_awx9 Language.Haskell.TH.Syntax.Exp
                    [LclId, Str=DmdType]
                    sat_szjT =
                      \ (x1_szjP [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp) ->
                        let {
                          sat_szjS [Occ=Once]
                            :: Language.Haskell.TH.Syntax.Exp
                               -> m_awx9 Language.Haskell.TH.Syntax.Exp
                          [LclId, Str=DmdType]
                          sat_szjS =
                            \ (x2_szjQ [Occ=Once] :: Language.Haskell.TH.Syntax.Exp) ->
                              let {
                                sat_szjR [Occ=Once] :: Language.Haskell.TH.Syntax.Exp
                                [LclId, Str=DmdType]
                                sat_szjR = Language.Haskell.TH.Syntax.AppE x1_szjP x2_szjQ } in
                              ww22_szjK @ Language.Haskell.TH.Syntax.Exp sat_szjR } in
                        ww20_szjI
                          @ Language.Haskell.TH.Syntax.Exp
                          @ Language.Haskell.TH.Syntax.Exp
                          lvl3_szjN
                          sat_szjS } in
                  let {
                    sat_szjO [Occ=Once] :: m_awx9 Language.Haskell.TH.Syntax.Exp
                    [LclId, Str=DmdType]
                    sat_szjO =
                      ww22_szjK
                        @ Language.Haskell.TH.Syntax.Exp CLaSH.Sized.Fixed.fLit2 } in
                  ww20_szjI
                    @ Language.Haskell.TH.Syntax.Exp
                    @ Language.Haskell.TH.Syntax.Exp
                    sat_szjO
                    sat_szjT } in
              let {
                sat_szjZ [Occ=Once]
                  :: Language.Haskell.TH.Syntax.Exp
                     -> m_awx9 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                sat_szjZ =
                  \ (x1_szjV [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp) ->
                    let {
                      sat_szjY [Occ=Once]
                        :: Language.Haskell.TH.Syntax.Exp
                           -> m_awx9 Language.Haskell.TH.Syntax.Exp
                      [LclId, Str=DmdType]
                      sat_szjY =
                        \ (x2_szjW [Occ=Once] :: Language.Haskell.TH.Syntax.Exp) ->
                          let {
                            sat_szjX [Occ=Once] :: Language.Haskell.TH.Syntax.Exp
                            [LclId, Str=DmdType]
                            sat_szjX = Language.Haskell.TH.Syntax.AppE x1_szjV x2_szjW } in
                          ww22_szjK @ Language.Haskell.TH.Syntax.Exp sat_szjX } in
                    ww20_szjI
                      @ Language.Haskell.TH.Syntax.Exp
                      @ Language.Haskell.TH.Syntax.Exp
                      lvl2_szjM
                      sat_szjY } in
              let {
                sat_szjU [Occ=Once] :: m_awx9 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                sat_szjU =
                  ww22_szjK
                    @ Language.Haskell.TH.Syntax.Exp
                    CLaSH.Sized.Fixed.$fLiftFixed2 } in
              ww20_szjI
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                sat_szjU
                sat_szjZ } in
          ww20_szjI
            @ Language.Haskell.TH.Syntax.Exp
            @ (Language.Haskell.TH.Syntax.TExp
                 (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))
            sat_szk0
            sat_szk2
          }
          } } in
    sat_szk3

CLaSH.Sized.Fixed.fLit
  :: forall (frac_auFI :: GHC.TypeLits.Nat)
            (rep_auFJ :: GHC.TypeLits.Nat -> *)
            (size_auFK :: GHC.TypeLits.Nat).
     (GHC.TypeLits.KnownNat frac_auFI, GHC.Num.Num (rep_auFJ size_auFK),
      GHC.Enum.Bounded (rep_auFJ size_auFK),
      GHC.Real.Integral (rep_auFJ size_auFK)) =>
     GHC.Types.Double
     -> Language.Haskell.TH.Syntax.Q
          (Language.Haskell.TH.Syntax.TExp
             (CLaSH.Sized.Fixed.Fixed frac_auFI rep_auFJ size_auFK))
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fLit =
  (\ (@ (frac_avhM :: GHC.TypeLits.Nat))
     (@ (rep_avhN :: GHC.TypeLits.Nat -> *))
     (@ (size_avhO :: GHC.TypeLits.Nat))
     (eta_B5 [Occ=Once] :: GHC.TypeLits.KnownNat frac_avhM)
     (eta_B4 [Occ=Once] :: GHC.Num.Num (rep_avhN size_avhO))
     (eta_B3 [Occ=Once] :: GHC.Enum.Bounded (rep_avhN size_avhO))
     (eta_B2 [Occ=Once] :: GHC.Real.Integral (rep_avhN size_avhO))
     (eta_B1 [Occ=Once] :: GHC.Types.Double) ->
     CLaSH.Sized.Fixed.fLit1
       @ frac_avhM
       @ rep_avhN
       @ size_avhO
       eta_B5
       eta_B4
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac_avhM :: GHC.TypeLits.Nat)
                 (rep_avhN :: GHC.TypeLits.Nat -> *)
                 (size_avhO :: GHC.TypeLits.Nat).
          <GHC.TypeLits.KnownNat frac_avhM>_R
          -> <GHC.Num.Num (rep_avhN size_avhO)>_R
          -> <GHC.Enum.Bounded (rep_avhN size_avhO)>_R
          -> <GHC.Real.Integral (rep_avhN size_avhO)>_R
          -> <GHC.Types.Double>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.TExp
                     (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)>_N)
          :: (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE (Language.Haskell.TH.Syntax.TExp
                           (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO)))
               ~#
             (forall (frac_avhM :: GHC.TypeLits.Nat)
                     (rep_avhN :: GHC.TypeLits.Nat -> *)
                     (size_avhO :: GHC.TypeLits.Nat).
              (GHC.TypeLits.KnownNat frac_avhM, GHC.Num.Num (rep_avhN size_avhO),
               GHC.Enum.Bounded (rep_avhN size_avhO),
               GHC.Real.Integral (rep_avhN size_avhO)) =>
              GHC.Types.Double
              -> Language.Haskell.TH.Syntax.Q
                   (Language.Haskell.TH.Syntax.TExp
                      (CLaSH.Sized.Fixed.Fixed frac_avhM rep_avhN size_avhO))))

CLaSH.Sized.Fixed.satN2
  :: forall (rep_auFL :: GHC.TypeLits.Nat -> *)
            (n_auFM :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.SatN2C rep_auFL n_auFM) =>
     rep_auFL (n_auFM GHC.TypeLits.+ 2) -> rep_auFL n_auFM
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.satN2 =
  \ (@ (rep_aviy :: GHC.TypeLits.Nat -> *))
    (@ (n_aviz :: GHC.TypeLits.Nat))
    (tup_szk4 [Occ=Once!] :: CLaSH.Sized.Fixed.SatN2C rep_aviy n_aviz)
    (eta_szk5 :: rep_aviy (n_aviz GHC.TypeLits.+ 2)) ->
    case tup_szk4
    of _ [Occ=Dead]
    { (tpl_szk7 [Occ=Once*], tpl1_szk8, tpl2_szk9 [Occ=Once*], tpl3_szka [Occ=Once], tpl4_szkb, tpl5_szkc [Occ=Once!], tpl6_szkd [Occ=Once*], tpl7_szke [Occ=Once], tpl8_szkf [Occ=Once*], tpl9_szkg [Occ=Once]) ->
    let {
      repBV_szkh
        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      repBV_szkh =
        case tpl5_szkc of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw6Z ->
        (CLaSH.Class.BitVector.toBV
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2))
           tpl3_szka
           (tpl7_szke
            `cast` ((GHC.TypeLits.KnownNat (Sym cobox1_dw6Z))_R
                    :: GHC.TypeLits.KnownNat (n_aviz GHC.TypeLits.+ 2)
                         ~#
                       GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize
                            (rep_aviy (n_aviz GHC.TypeLits.+ 2)))))
           eta_szk5)
        `cast` ((CLaSH.Sized.Vector.Vec cobox1_dw6Z <CLaSH.Bit.Bit>_R)_R
                :: CLaSH.Sized.Vector.Vec
                     (CLaSH.Class.BitVector.BitSize
                        (rep_aviy (n_aviz GHC.TypeLits.+ 2)))
                     CLaSH.Bit.Bit
                     ~#
                   CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit)
        } } in
    let {
      s_szkj :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      s_szkj =
        case tpl1_szk8 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw7d ->
        case CLaSH.Sized.Vector.vtail
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_szkh
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox1_dw7d) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of sat_szkl { __DEFAULT ->
        CLaSH.Sized.Vector.vtail @ n_aviz @ CLaSH.Bit.Bit sat_szkl
        }
        } } in
    case Data.Bits.isSigned
           @ (rep_aviy (n_aviz GHC.TypeLits.+ 2)) tpl9_szkg eta_szk5
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case tpl1_szk8 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_szkh
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vtail
                   @ (n_aviz GHC.TypeLits.+ 1)
                   @ CLaSH.Bit.Bit
                   (repBV_szkh
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
            of sat_szkp { __DEFAULT ->
            case CLaSH.Sized.Vector.vhead @ n_aviz @ CLaSH.Bit.Bit sat_szkp
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl8_szkf;
              CLaSH.Bit.L ->
                let {
                  sat_szku [Occ=Once]
                    :: CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit
                  [LclId, Str=DmdType]
                  sat_szku =
                    case tpl4_szkb of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7c ->
                    s_szkj
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox3_dw7c) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                    } } in
                let {
                  sat_szks [Occ=Once]
                    :: GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                  [LclId, Str=DmdType]
                  sat_szks =
                    case tpl4_szkb of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7b ->
                    tpl6_szkd
                    `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw7b))_R
                            :: GHC.TypeLits.KnownNat n_aviz
                                 ~#
                               GHC.TypeLits.KnownNat
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                    } } in
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz) tpl2_szk9 sat_szks sat_szku
            }
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vtail
                   @ (n_aviz GHC.TypeLits.+ 1)
                   @ CLaSH.Bit.Bit
                   (repBV_szkh
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
            of sat_szkv { __DEFAULT ->
            case CLaSH.Sized.Vector.vhead @ n_aviz @ CLaSH.Bit.Bit sat_szkv
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl8_szkf;
              CLaSH.Bit.L ->
                let {
                  sat_szkA [Occ=Once]
                    :: CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit
                  [LclId, Str=DmdType]
                  sat_szkA =
                    case tpl4_szkb of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7c ->
                    s_szkj
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox3_dw7c) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                    } } in
                let {
                  sat_szky [Occ=Once]
                    :: GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                  [LclId, Str=DmdType]
                  sat_szky =
                    case tpl4_szkb of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7b ->
                    tpl6_szkd
                    `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw7b))_R
                            :: GHC.TypeLits.KnownNat n_aviz
                                 ~#
                               GHC.TypeLits.KnownNat
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                    } } in
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz) tpl2_szk9 sat_szky sat_szkA
            }
            }
        }
        };
      GHC.Types.True ->
        case tpl1_szk8 of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw7j ->
        case CLaSH.Sized.Vector.vhead
               @ (n_aviz GHC.TypeLits.+ 1)
               @ CLaSH.Bit.Bit
               (repBV_szkh
                `cast` ((CLaSH.Sized.Vector.Vec
                           (Sym cobox1_dw7j) <CLaSH.Bit.Bit>_R)_R
                        :: CLaSH.Sized.Vector.Vec (n_aviz GHC.TypeLits.+ 2) CLaSH.Bit.Bit
                             ~#
                           CLaSH.Sized.Vector.Vec
                             ((n_aviz GHC.TypeLits.+ 1) GHC.TypeLits.+ 1) CLaSH.Bit.Bit))
        of _ [Occ=Dead] {
          CLaSH.Bit.H ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_szk7 s_szkj
            of _ [Occ=Dead] {
              CLaSH.Bit.H ->
                let {
                  sat_szkH [Occ=Once]
                    :: CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit
                  [LclId, Str=DmdType]
                  sat_szkH =
                    case tpl4_szkb of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7a ->
                    s_szkj
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox3_dw7a) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                    } } in
                let {
                  sat_szkF [Occ=Once]
                    :: GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                  [LclId, Str=DmdType]
                  sat_szkF =
                    case tpl4_szkb of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw79 ->
                    tpl6_szkd
                    `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw79))_R
                            :: GHC.TypeLits.KnownNat n_aviz
                                 ~#
                               GHC.TypeLits.KnownNat
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                    } } in
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz) tpl2_szk9 sat_szkF sat_szkH;
              CLaSH.Bit.L -> GHC.Enum.minBound @ (rep_aviy n_aviz) tpl8_szkf
            };
          CLaSH.Bit.L ->
            case CLaSH.Sized.Vector.vhead'
                   @ n_aviz @ CLaSH.Bit.Bit tpl_szk7 s_szkj
            of _ [Occ=Dead] {
              CLaSH.Bit.H -> GHC.Enum.maxBound @ (rep_aviy n_aviz) tpl8_szkf;
              CLaSH.Bit.L ->
                let {
                  sat_szkM [Occ=Once]
                    :: CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit
                  [LclId, Str=DmdType]
                  sat_szkM =
                    case tpl4_szkb of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw7a ->
                    s_szkj
                    `cast` ((CLaSH.Sized.Vector.Vec
                               (Sym cobox3_dw7a) <CLaSH.Bit.Bit>_R)_R
                            :: CLaSH.Sized.Vector.Vec n_aviz CLaSH.Bit.Bit
                                 ~#
                               CLaSH.Sized.Vector.Vec
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)) CLaSH.Bit.Bit)
                    } } in
                let {
                  sat_szkK [Occ=Once]
                    :: GHC.TypeLits.KnownNat
                         (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz))
                  [LclId, Str=DmdType]
                  sat_szkK =
                    case tpl4_szkb of _ [Occ=Dead] { GHC.Types.Eq# cobox3_dw79 ->
                    tpl6_szkd
                    `cast` ((GHC.TypeLits.KnownNat (Sym cobox3_dw79))_R
                            :: GHC.TypeLits.KnownNat n_aviz
                                 ~#
                               GHC.TypeLits.KnownNat
                                 (CLaSH.Class.BitVector.BitSize (rep_aviy n_aviz)))
                    } } in
                CLaSH.Class.BitVector.fromBV
                  @ (rep_aviy n_aviz) tpl2_szk9 sat_szkK sat_szkM
            }
        }
        }
    }
    }

CLaSH.Sized.Fixed.resizeF
  :: forall (frac1_auFN :: GHC.TypeLits.Nat)
            (frac2_auFO :: GHC.TypeLits.Nat)
            (rep_auFP :: GHC.TypeLits.Nat -> *)
            (size1_auFQ :: GHC.TypeLits.Nat)
            (size2_auFR :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.ResizeFC
        rep_auFP frac1_auFN frac2_auFO size1_auFQ size2_auFR) =>
     CLaSH.Sized.Fixed.Fixed frac1_auFN rep_auFP size1_auFQ
     -> CLaSH.Sized.Fixed.Fixed frac2_auFO rep_auFP size2_auFR
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.resizeF =
  \ (@ (frac1_avjq :: GHC.TypeLits.Nat))
    (@ (frac2_avjr :: GHC.TypeLits.Nat))
    (@ (rep_avjs :: GHC.TypeLits.Nat -> *))
    (@ (size1_avjt :: GHC.TypeLits.Nat))
    (@ (size2_avju :: GHC.TypeLits.Nat))
    (tup_szkN
       :: CLaSH.Sized.Fixed.ResizeFC
            rep_avjs frac1_avjq frac2_avjr size1_avjt size2_avju)
    (eta_szkO
       :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt) ->
    let {
      $dKnownNat_szkP :: GHC.TypeLits.KnownNat size1_avjt
      [LclId, Str=DmdType]
      $dKnownNat_szkP =
        case tup_szkN
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szkY [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_szkY
        } } in
    let {
      $dKnownNat1_szl3 :: GHC.TypeLits.KnownNat size2_avju
      [LclId, Str=DmdType]
      $dKnownNat1_szl3 =
        case tup_szkN
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szlb [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_szlb
        } } in
    case GHC.Integer.Type.leInteger#
           ($dKnownNat_szkP
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size1_avjt>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size1_avjt>_P
                    :: GHC.TypeLits.KnownNat size1_avjt ~# GHC.Integer.Type.Integer))
           ($dKnownNat1_szl3
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size2_avju>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <size2_avju>_P
                    :: GHC.TypeLits.KnownNat size2_avju ~# GHC.Integer.Type.Integer))
    of wild_szlh { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_szlh
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case tup_szkN
        of _ [Occ=Dead]
        { (tpl_szlk, _ [Occ=Dead], tpl2_szlm [Occ=Once*], tpl3_szln, tpl4_szlo, tpl5_szlp, _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_szlt [Occ=Once], tpl10_szlu [Occ=Once], _ [Occ=Dead]) ->
        case GHC.Integer.Type.integerToInt
               (tpl10_szlu
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild3_szlw { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl9_szlt
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild4_szlx { __DEFAULT ->
        let {
          fMax_szly :: rep_avjs size2_avju
          [LclId, Str=DmdType]
          fMax_szly = GHC.Enum.maxBound @ (rep_avjs size2_avju) tpl_szlk } in
        let {
          mask_szlz :: rep_avjs size1_avjt
          [LclId, Str=DmdType]
          mask_szlz =
            let {
              sat_szlA [Occ=Once] :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              sat_szlA =
                (tpl5_szlp
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size2_avju
                  @ size1_avjt
                  $dKnownNat1_szl3
                  $dKnownNat_szkP
                  fMax_szly } in
            Data.Bits.complement
              @ (rep_avjs size1_avjt) tpl4_szlo sat_szlA } in
        case GHC.Prim.<=# wild3_szlw wild4_szlx of sat_szlB { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_szlB
        of _ [Occ=Dead] {
          GHC.Types.False ->
            let {
              shiftedR_szlD :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedR_szlD =
                case GHC.Prim.-# wild3_szlw wild4_szlx of sat_szlE { __DEFAULT ->
                let {
                  sat_szlF [Occ=Once] :: GHC.Types.Int
                  [LclId, Str=DmdType]
                  sat_szlF = GHC.Types.I# sat_szlE } in
                Data.Bits.shiftR
                  @ (rep_avjs size1_avjt)
                  tpl4_szlo
                  (eta_szkO
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  sat_szlF
                } } in
            let {
              sat_szlG [Occ=Once] :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              sat_szlG =
                GHC.Num.fromInteger
                  @ (rep_avjs size1_avjt) tpl3_szln CLaSH.Sized.Fixed.resizeF1 } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl2_szlm
                   (eta_szkO
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   sat_szlG
            of _ [Occ=Dead] {
              GHC.Types.False ->
                let {
                  sat_szlJ [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_szlJ =
                    Data.Bits..&.
                      @ (rep_avjs size1_avjt) tpl4_szlo shiftedR_szlD mask_szlz } in
                case Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_szlo
                of sat_szlI { __DEFAULT ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt) sat_szlI sat_szlJ mask_szlz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) tpl_szlk)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_szlp
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_szkP
                       $dKnownNat1_szl3
                       shiftedR_szlD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
                };
              GHC.Types.True ->
                let {
                  sat_szlN [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_szlN =
                    GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) tpl3_szln CLaSH.Sized.Fixed.resizeF1 } in
                let {
                  sat_szlM [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_szlM =
                    Data.Bits..&.
                      @ (rep_avjs size1_avjt) tpl4_szlo shiftedR_szlD mask_szlz } in
                case Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_szlo
                of sat_szlL { __DEFAULT ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt) sat_szlL sat_szlM sat_szlN
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_szly
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_szlp
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_szkP
                       $dKnownNat1_szl3
                       shiftedR_szlD)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
                }
            };
          GHC.Types.True ->
            let {
              shiftedL_szlP :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              shiftedL_szlP =
                case GHC.Prim.-# wild4_szlx wild3_szlw of sat_szlQ { __DEFAULT ->
                let {
                  sat_szlR [Occ=Once] :: GHC.Types.Int
                  [LclId, Str=DmdType]
                  sat_szlR = GHC.Types.I# sat_szlQ } in
                Data.Bits.shiftL
                  @ (rep_avjs size1_avjt)
                  tpl4_szlo
                  (eta_szkO
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt))
                  sat_szlR
                } } in
            let {
              sat_szlS [Occ=Once] :: rep_avjs size1_avjt
              [LclId, Str=DmdType]
              sat_szlS =
                GHC.Num.fromInteger
                  @ (rep_avjs size1_avjt) tpl3_szln CLaSH.Sized.Fixed.resizeF1 } in
            case GHC.Classes.>=
                   @ (rep_avjs size1_avjt)
                   tpl2_szlm
                   (eta_szkO
                    `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                              <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                            :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                 ~#
                               rep_avjs size1_avjt))
                   sat_szlS
            of _ [Occ=Dead] {
              GHC.Types.False ->
                let {
                  sat_szlV [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_szlV =
                    Data.Bits..&.
                      @ (rep_avjs size1_avjt) tpl4_szlo shiftedL_szlP mask_szlz } in
                case Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_szlo
                of sat_szlU { __DEFAULT ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt) sat_szlU sat_szlV mask_szlz
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    (GHC.Enum.minBound @ (rep_avjs size2_avju) tpl_szlk)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_szlp
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_szkP
                       $dKnownNat1_szl3
                       shiftedL_szlP)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
                };
              GHC.Types.True ->
                let {
                  sat_szlZ [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_szlZ =
                    GHC.Num.fromInteger
                      @ (rep_avjs size1_avjt) tpl3_szln CLaSH.Sized.Fixed.resizeF1 } in
                let {
                  sat_szlY [Occ=Once] :: rep_avjs size1_avjt
                  [LclId, Str=DmdType]
                  sat_szlY =
                    Data.Bits..&.
                      @ (rep_avjs size1_avjt) tpl4_szlo shiftedL_szlP mask_szlz } in
                case Data.Bits.$p1Bits @ (rep_avjs size1_avjt) tpl4_szlo
                of sat_szlX { __DEFAULT ->
                case GHC.Classes.==
                       @ (rep_avjs size1_avjt) sat_szlX sat_szlY sat_szlZ
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    fMax_szly
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju);
                  GHC.Types.True ->
                    ((tpl5_szlp
                      `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                              :: CLaSH.Class.Num.Resize rep_avjs
                                   ~#
                                 (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                                  (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                                  rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                       @ size1_avjt
                       @ size2_avju
                       $dKnownNat_szkP
                       $dKnownNat1_szl3
                       shiftedL_szlP)
                    `cast` (Sym
                              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                                 <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                            :: rep_avjs size2_avju
                                 ~#
                               CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
                }
                }
            }
        }
        }
        }
        }
        };
      GHC.Types.True ->
        case tup_szkN
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_szm7 [Occ=Once*], _ [Occ=Dead], _ [Occ=Dead], tpl8_szma [Occ=Once*], tpl9_szmb [Occ=Once], tpl10_szmc [Occ=Once], _ [Occ=Dead]) ->
        case GHC.Integer.Type.integerToInt
               (tpl10_szmc
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac1_avjq>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac1_avjq>_P
                        :: GHC.TypeLits.KnownNat frac1_avjq ~# GHC.Integer.Type.Integer))
        of wild3_szme { __DEFAULT ->
        case GHC.Integer.Type.integerToInt
               (tpl9_szmb
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac2_avjr>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac2_avjr>_P
                        :: GHC.TypeLits.KnownNat frac2_avjr ~# GHC.Integer.Type.Integer))
        of wild4_szmf { __DEFAULT ->
        case GHC.Prim.<=# wild3_szme wild4_szmf of sat_szmg { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_szmg
        of _ [Occ=Dead] {
          GHC.Types.False ->
            case GHC.Prim.-# wild3_szme wild4_szmf of sat_szmj { __DEFAULT ->
            let {
              sat_szmk [Occ=Once] :: GHC.Types.Int
              [LclId, Str=DmdType]
              sat_szmk = GHC.Types.I# sat_szmj } in
            let {
              sat_szmi [Occ=Once] :: rep_avjs size2_avju
              [LclId, Str=DmdType]
              sat_szmi =
                (tpl5_szm7
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_szkP
                  $dKnownNat1_szl3
                  (eta_szkO
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)) } in
            (Data.Bits.shiftR
               @ (rep_avjs size2_avju) tpl8_szma sat_szmi sat_szmk)
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
            };
          GHC.Types.True ->
            case GHC.Prim.-# wild4_szmf wild3_szme of sat_szmm { __DEFAULT ->
            let {
              sat_szmn [Occ=Once] :: GHC.Types.Int
              [LclId, Str=DmdType]
              sat_szmn = GHC.Types.I# sat_szmm } in
            let {
              sat_szml [Occ=Once] :: rep_avjs size2_avju
              [LclId, Str=DmdType]
              sat_szml =
                (tpl5_szm7
                 `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_avjs>_N
                         :: CLaSH.Class.Num.Resize rep_avjs
                              ~#
                            (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                             (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                             rep_avjs a_ae8M -> rep_avjs b_ae8N)))
                  @ size1_avjt
                  @ size2_avju
                  $dKnownNat_szkP
                  $dKnownNat1_szl3
                  (eta_szkO
                   `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                             <frac1_avjq>_P <rep_avjs>_R <size1_avjt>_N
                           :: CLaSH.Sized.Fixed.Fixed frac1_avjq rep_avjs size1_avjt
                                ~#
                              rep_avjs size1_avjt)) } in
            (Data.Bits.shiftL
               @ (rep_avjs size2_avju) tpl8_szma sat_szml sat_szmn)
            `cast` (Sym
                      (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac2_avjr>_P <rep_avjs>_R) <size2_avju>_N
                    :: rep_avjs size2_avju
                         ~#
                       CLaSH.Sized.Fixed.Fixed frac2_avjr rep_avjs size2_avju)
            }
        }
        }
        }
        }
        }
    }
    }

CLaSH.Sized.Fixed.asRepProxy
  :: forall (frac_auFV :: GHC.TypeLits.Nat)
            (rep_auFW :: GHC.TypeLits.Nat -> *)
            (size_auFX :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFV rep_auFW size_auFX
     -> Data.Proxy.Proxy rep_auFW
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.asRepProxy =
  \ (@ (frac_avk6 :: GHC.TypeLits.Nat))
    (@ (rep_avk7 :: GHC.TypeLits.Nat -> *))
    (@ (size_avk8 :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ (GHC.TypeLits.Nat -> *) @ rep_avk7

CLaSH.Sized.Fixed.asFracProxy
  :: forall (frac_auFY :: GHC.TypeLits.Nat)
            (rep_auFZ :: GHC.TypeLits.Nat -> *)
            (size_auG0 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFY rep_auFZ size_auG0
     -> Data.Proxy.Proxy frac_auFY
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.asFracProxy =
  \ (@ (frac_avkp :: GHC.TypeLits.Nat))
    (@ (rep_avkq :: GHC.TypeLits.Nat -> *))
    (@ (size_avkr :: GHC.TypeLits.Nat))
    _ [Occ=Dead] ->
    Data.Proxy.Proxy @ GHC.TypeLits.Nat @ frac_avkp

CLaSH.Sized.Fixed.fracShift
  :: forall (frac_auFS :: GHC.TypeLits.Nat)
            (rep_auFT :: GHC.TypeLits.Nat -> *)
            (size_auFU :: GHC.TypeLits.Nat).
     GHC.TypeLits.KnownNat frac_auFS =>
     CLaSH.Sized.Fixed.Fixed frac_auFS rep_auFT size_auFU
     -> GHC.Types.Int
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.fracShift =
  \ (@ (frac_avjN :: GHC.TypeLits.Nat))
    (@ (rep_avjO :: GHC.TypeLits.Nat -> *))
    (@ (size_avjP :: GHC.TypeLits.Nat))
    ($dKnownNat_szmq [Occ=Once] :: GHC.TypeLits.KnownNat frac_avjN)
    _ [Occ=Dead] ->
    case GHC.Integer.Type.integerToInt
           ($dKnownNat_szmq
            `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_avjN>_N
                    ; GHC.TypeLits.NTCo:SNat[0] <frac_avjN>_P
                    :: GHC.TypeLits.KnownNat frac_avjN ~# GHC.Integer.Type.Integer))
    of wild_szms { __DEFAULT ->
    GHC.Types.I# wild_szms
    }

CLaSH.Sized.Fixed.unUF1
  :: forall (int_avkK :: GHC.TypeLits.Nat)
            (frac_avkL :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avkL
       CLaSH.Sized.Unsigned.Unsigned
       (int_avkK GHC.TypeLits.+ frac_avkL)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avkL
          CLaSH.Sized.Unsigned.Unsigned
          (int_avkK GHC.TypeLits.+ frac_avkL)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unUF1 =
  \ (@ (int_avkK :: GHC.TypeLits.Nat))
    (@ (frac_avkL :: GHC.TypeLits.Nat))
    (ds_szmt [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed
            frac_avkL
            CLaSH.Sized.Unsigned.Unsigned
            (int_avkK GHC.TypeLits.+ frac_avkL)) ->
    ds_szmt

CLaSH.Sized.Fixed.unUF
  :: forall (int_auG1 :: GHC.TypeLits.Nat)
            (frac_auG2 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.UFixed int_auG1 frac_auG2
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG1 GHC.TypeLits.+ frac_auG2)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unUF =
  (\ (@ (int_avkK :: GHC.TypeLits.Nat))
     (@ (frac_avkL :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)) ->
     CLaSH.Sized.Fixed.unUF1 @ int_avkK @ frac_avkL eta_B1)
  `cast` (forall (int_avkK :: GHC.TypeLits.Nat)
                 (frac_avkL :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avkL
             CLaSH.Sized.Unsigned.Unsigned
             (int_avkK GHC.TypeLits.+ frac_avkL)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avkL>_P <CLaSH.Sized.Unsigned.Unsigned>_R <int_avkK
                                                                GHC.TypeLits.+ frac_avkL>_N
          :: (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avkL
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL))
               ~#
             (forall (int_avkK :: GHC.TypeLits.Nat)
                     (frac_avkL :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avkL
                CLaSH.Sized.Unsigned.Unsigned
                (int_avkK GHC.TypeLits.+ frac_avkL)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avkK GHC.TypeLits.+ frac_avkL)))

CLaSH.Sized.Fixed.uf1
  :: forall (frac_avl5 :: GHC.TypeLits.Nat)
            (int_avl6 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avl5
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_avl6 GHC.TypeLits.+ frac_avl5)
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.uf1 =
  \ (@ (frac_avl5 :: GHC.TypeLits.Nat))
    (@ (int_avl6 :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_szmv [Occ=Once]
       :: CLaSH.Sized.Unsigned.Unsigned
            (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
    fRep_szmv

CLaSH.Sized.Fixed.uf
  :: forall (frac_auG3 :: GHC.TypeLits.Nat)
            (int_auG4 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG3
     -> CLaSH.Sized.Unsigned.Unsigned
          (int_auG4 GHC.TypeLits.+ frac_auG3)
     -> CLaSH.Sized.Fixed.UFixed int_auG4 frac_auG3
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.uf =
  (\ (@ (frac_avl5 :: GHC.TypeLits.Nat))
     (@ (int_avl6 :: GHC.TypeLits.Nat))
     (eta_B2 [Occ=Once] :: CLaSH.Promoted.Nat.SNat frac_avl5)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Unsigned.Unsigned
             (int_avl6 GHC.TypeLits.+ frac_avl5)) ->
     CLaSH.Sized.Fixed.uf1 @ frac_avl5 @ int_avl6 eta_B2 eta_B1)
  `cast` (forall (frac_avl5 :: GHC.TypeLits.Nat)
                 (int_avl6 :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avl5>_R
          -> <CLaSH.Sized.Unsigned.Unsigned
                (int_avl6 GHC.TypeLits.+ frac_avl5)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avl5>_P <CLaSH.Sized.Unsigned.Unsigned>_R) <int_avl6
                                                                    GHC.TypeLits.+ frac_avl5>_N
          :: (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5))
               ~#
             (forall (frac_avl5 :: GHC.TypeLits.Nat)
                     (int_avl6 :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avl5
              -> CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avl5
                   CLaSH.Sized.Unsigned.Unsigned
                   (int_avl6 GHC.TypeLits.+ frac_avl5)))

CLaSH.Sized.Fixed.unSF1
  :: forall (int_avlp :: GHC.TypeLits.Nat)
            (frac_avlq :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed
       frac_avlq
       CLaSH.Sized.Signed.Signed
       (int_avlp GHC.TypeLits.+ frac_avlq)
     -> CLaSH.Sized.Fixed.Fixed
          frac_avlq
          CLaSH.Sized.Signed.Signed
          (int_avlp GHC.TypeLits.+ frac_avlq)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unSF1 =
  \ (@ (int_avlp :: GHC.TypeLits.Nat))
    (@ (frac_avlq :: GHC.TypeLits.Nat))
    (ds_szmw [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed
            frac_avlq
            CLaSH.Sized.Signed.Signed
            (int_avlp GHC.TypeLits.+ frac_avlq)) ->
    ds_szmw

CLaSH.Sized.Fixed.unSF
  :: forall (int_auG5 :: GHC.TypeLits.Nat)
            (frac_auG6 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.SFixed int_auG5 frac_auG6
     -> CLaSH.Sized.Signed.Signed (int_auG5 GHC.TypeLits.+ frac_auG6)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unSF =
  (\ (@ (int_avlp :: GHC.TypeLits.Nat))
     (@ (frac_avlq :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)) ->
     CLaSH.Sized.Fixed.unSF1 @ int_avlp @ frac_avlq eta_B1)
  `cast` (forall (int_avlp :: GHC.TypeLits.Nat)
                 (frac_avlq :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed
             frac_avlq
             CLaSH.Sized.Signed.Signed
             (int_avlp GHC.TypeLits.+ frac_avlq)>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_avlq>_P <CLaSH.Sized.Signed.Signed>_R <int_avlp
                                                            GHC.TypeLits.+ frac_avlq>_N
          :: (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlq
                   CLaSH.Sized.Signed.Signed
                   (int_avlp GHC.TypeLits.+ frac_avlq))
               ~#
             (forall (int_avlp :: GHC.TypeLits.Nat)
                     (frac_avlq :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed
                frac_avlq
                CLaSH.Sized.Signed.Signed
                (int_avlp GHC.TypeLits.+ frac_avlq)
              -> CLaSH.Sized.Signed.Signed (int_avlp GHC.TypeLits.+ frac_avlq)))

CLaSH.Sized.Fixed.sf1
  :: forall (frac_avlK :: GHC.TypeLits.Nat)
            (int_avlL :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_avlK
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
     -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.sf1 =
  \ (@ (frac_avlK :: GHC.TypeLits.Nat))
    (@ (int_avlL :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    (fRep_szmy [Occ=Once]
       :: CLaSH.Sized.Signed.Signed
            (int_avlL GHC.TypeLits.+ frac_avlK)) ->
    fRep_szmy

CLaSH.Sized.Fixed.sf
  :: forall (frac_auG7 :: GHC.TypeLits.Nat)
            (int_auG8 :: GHC.TypeLits.Nat).
     CLaSH.Promoted.Nat.SNat frac_auG7
     -> CLaSH.Sized.Signed.Signed (int_auG8 GHC.TypeLits.+ frac_auG7)
     -> CLaSH.Sized.Fixed.SFixed int_auG8 frac_auG7
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.sf =
  (\ (@ (frac_avlK :: GHC.TypeLits.Nat))
     (@ (int_avlL :: GHC.TypeLits.Nat))
     (eta_B2 [Occ=Once] :: CLaSH.Promoted.Nat.SNat frac_avlK)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Signed.Signed
             (int_avlL GHC.TypeLits.+ frac_avlK)) ->
     CLaSH.Sized.Fixed.sf1 @ frac_avlK @ int_avlL eta_B2 eta_B1)
  `cast` (forall (frac_avlK :: GHC.TypeLits.Nat)
                 (int_avlL :: GHC.TypeLits.Nat).
          <CLaSH.Promoted.Nat.SNat frac_avlK>_R
          -> <CLaSH.Sized.Signed.Signed
                (int_avlL GHC.TypeLits.+ frac_avlK)>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac_avlK>_P <CLaSH.Sized.Signed.Signed>_R) <int_avlL
                                                                GHC.TypeLits.+ frac_avlK>_N
          :: (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK))
               ~#
             (forall (frac_avlK :: GHC.TypeLits.Nat)
                     (int_avlL :: GHC.TypeLits.Nat).
              CLaSH.Promoted.Nat.SNat frac_avlK
              -> CLaSH.Sized.Signed.Signed (int_avlL GHC.TypeLits.+ frac_avlK)
              -> CLaSH.Sized.Fixed.Fixed
                   frac_avlK
                   CLaSH.Sized.Signed.Signed
                   (int_avlL GHC.TypeLits.+ frac_avlK)))

CLaSH.Sized.Fixed.unFixed1
  :: forall (frac_auI2 :: GHC.TypeLits.Nat)
            (rep_auI3 :: GHC.TypeLits.Nat -> *)
            (size_auI4 :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
     -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.unFixed1 =
  \ (@ (frac_auI2 :: GHC.TypeLits.Nat))
    (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
    (@ (size_auI4 :: GHC.TypeLits.Nat))
    (ds_szmz [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
    ds_szmz

CLaSH.Sized.Fixed.unFixed
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH
     -> rep_auFG size_auFH
[GblId[[RecSel]],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.unFixed =
  (\ (@ (frac_auI2 :: GHC.TypeLits.Nat))
     (@ (rep_auI3 :: GHC.TypeLits.Nat -> *))
     (@ (size_auI4 :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4) ->
     CLaSH.Sized.Fixed.unFixed1
       @ frac_auI2 @ rep_auI3 @ size_auI4 eta_B1)
  `cast` (forall (frac_auI2 :: GHC.TypeLits.Nat)
                 (rep_auI3 :: GHC.TypeLits.Nat -> *)
                 (size_auI4 :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4>_R
          -> CLaSH.Sized.Fixed.NTCo:Fixed[0]
               <frac_auI2>_P <rep_auI3>_R <size_auI4>_N
          :: (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4)
               ~#
             (forall (frac_auI2 :: GHC.TypeLits.Nat)
                     (rep_auI3 :: GHC.TypeLits.Nat -> *)
                     (size_auI4 :: GHC.TypeLits.Nat).
              CLaSH.Sized.Fixed.Fixed frac_auI2 rep_auI3 size_auI4
              -> rep_auI3 size_auI4))

CLaSH.Sized.Fixed.$fShowFixed1 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed1 = GHC.Types.C# '-'

CLaSH.Sized.Fixed.$fShowFixed3 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed3 = GHC.Types.C# '0'

CLaSH.Sized.Fixed.$fShowFixed_dt :: GHC.Integer.Type.Integer
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed_dt = GHC.Integer.Type.S# 10

CLaSH.Sized.Fixed.$fShowFixed7
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
[GblId, Arity=1, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed7 =
  \ (ds_szmA
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)) ->
    let {
      sat_szmU [Occ=Once] :: GHC.Real.Ratio GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      sat_szmU =
        case ds_szmA
        of _ [Occ=Dead] { (_ [Occ=Dead], y_szmL [Occ=Once!]) ->
        case y_szmL
        of _ [Occ=Dead]
        { GHC.Real.:% ww1_szmN [Occ=Once] ww2_szmO [Occ=Once] ->
        case GHC.Integer.Type.timesInteger ww2_szmO GHC.Real.$fEnumRatio1
        of sat_szmQ { __DEFAULT ->
        case GHC.Integer.Type.timesInteger
               ww1_szmN CLaSH.Sized.Fixed.$fShowFixed_dt
        of sat_szmP { __DEFAULT ->
        case GHC.Real.$w$sreduce sat_szmP sat_szmQ
        of _ [Occ=Dead] { (# ww7_szmS [Occ=Once], ww8_szmT [Occ=Once] #) ->
        GHC.Real.:% @ GHC.Integer.Type.Integer ww7_szmS ww8_szmT
        }
        }
        }
        }
        } } in
    let {
      sat_szmI [Occ=Once] :: GHC.Types.Int
      [LclId, Str=DmdType]
      sat_szmI =
        case ds_szmA
        of _ [Occ=Dead] { (x_szmC [Occ=Once!], _ [Occ=Dead]) ->
        case x_szmC of _ [Occ=Dead] { GHC.Types.I# x1_szmF [Occ=Once!] ->
        case x1_szmF of wild2_szmG {
          __DEFAULT ->
            case GHC.Prim.+# wild2_szmG 1 of sat_szmH { __DEFAULT ->
            GHC.Types.I# sat_szmH
            };
          9223372036854775807 -> GHC.Enum.$fEnumInt2
        }
        }
        } } in
    (sat_szmI, sat_szmU)

CLaSH.Sized.Fixed.$fShowFixed6 :: GHC.Types.Int
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed6 = GHC.Types.I# 0

CLaSH.Sized.Fixed.$fShowFixed8
  :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
     -> [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed8 =
  \ (x_szmV [Occ=Once!]
       :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer))
    (r_szmW [Occ=Once*]
       :: [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]) ->
    case x_szmV of wild_szmX { (_ [Occ=Dead], y_szmZ [Occ=Once!]) ->
    case y_szmZ
    of _ [Occ=Dead] { GHC.Real.:% _ [Occ=Dead] y1_szn2 [Occ=Once] ->
    case GHC.Integer.Type.eqInteger#
           y1_szn2 CLaSH.Sized.Fixed.$fShowFixed4
    of wild2_szn3 { __DEFAULT ->
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild2_szn3
    of _ [Occ=Dead] {
      GHC.Types.False -> r_szmW;
      GHC.Types.True ->
        GHC.Types.:
          @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          wild_szmX
          r_szmW
    }
    }
    }
    }

CLaSH.Sized.Fixed.$fShowFixed2 :: GHC.Types.Char
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed2 = GHC.Types.C# '.'

CLaSH.Sized.Fixed.$fShowFixed_$cshow
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Base.String
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed_$cshow =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    _ [Occ=Dead]
    _ [Occ=Dead]
    ($dKnownNat_szn7 [Occ=Once] :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_szn8 [Occ=Once]
       :: GHC.Real.Integral (rep_auHy size_auHz))
    (f_szn9 [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
    let {
      fRepI_szna :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_szna =
        GHC.Real.toInteger
          @ (rep_auHy size_auHz)
          $dIntegral_szn8
          (f_szn9
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auHx>_P <rep_auHy>_R <size_auHz>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
                        ~#
                      rep_auHy size_auHz)) } in
    case GHC.Integer.Type.ltInteger#
           fRepI_szna CLaSH.Sized.Fixed.resizeF1
    of wild_sznb { __DEFAULT ->
    let {
      fRepI_abs_sznc :: GHC.Integer.Type.Integer
      [LclId, Str=DmdType]
      fRepI_abs_sznc = GHC.Integer.Type.absInteger fRepI_szna } in
    let {
      nF_sznd :: GHC.Types.Int
      [LclId, Str=DmdType]
      nF_sznd =
        case GHC.Integer.Type.integerToInt
               ($dKnownNat_szn7
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auHx>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auHx>_P
                        :: GHC.TypeLits.KnownNat frac_auHx ~# GHC.Integer.Type.Integer))
        of wild1_szne { __DEFAULT ->
        GHC.Types.I# wild1_szne
        } } in
    let {
      a_sznf [Occ=Once*] :: [GHC.Types.Char]
      [LclId, Str=DmdType]
      a_sznf =
        let {
          sat_szo4 :: GHC.Real.Ratio GHC.Integer.Type.Integer
          [LclId, Str=DmdType]
          sat_szo4 =
            case GHC.Integer.Type.ltInteger#
                   fRepI_szna CLaSH.Sized.Fixed.resizeF1
            of wild1_szng { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild1_szng
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case nF_sznd of _ [Occ=Dead] { GHC.Types.I# x_sznj ->
                case GHC.Prim.<# x_sznj 0 of sat_sznk { __DEFAULT ->
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sznk
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    let {
                      a1_sznm :: GHC.Integer.Type.Integer
                      [LclId, Str=DmdType]
                      a1_sznm =
                        case x_sznj of wild5_sznn {
                          __DEFAULT ->
                            GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_sznn;
                          0 -> GHC.Real.$fEnumRatio1
                        } } in
                    case x_sznj of wild5_szno {
                      __DEFAULT ->
                        case GHC.Integer.Type.absInteger a1_sznm of sat_sznu { __DEFAULT ->
                        case GHC.Integer.Type.signumInteger a1_sznm
                        of sat_szns { __DEFAULT ->
                        case GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_szno
                        of sat_sznp { __DEFAULT ->
                        case GHC.Integer.Type.minusInteger
                               sat_sznp CLaSH.Sized.Fixed.$fShowFixed4
                        of sat_sznq { __DEFAULT ->
                        case GHC.Integer.Type.andInteger fRepI_szna sat_sznq
                        of sat_sznr { __DEFAULT ->
                        case GHC.Integer.Type.timesInteger sat_sznr sat_szns
                        of sat_sznt { __DEFAULT ->
                        case GHC.Real.$w$sreduce sat_sznt sat_sznu
                        of _ [Occ=Dead] { (# ww1_sznw [Occ=Once], ww2_sznx [Occ=Once] #) ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1_sznw ww2_sznx
                        }
                        }
                        }
                        }
                        }
                        }
                        };
                      0 ->
                        case GHC.Integer.Type.absInteger a1_sznm of sat_sznB { __DEFAULT ->
                        case GHC.Integer.Type.signumInteger a1_sznm
                        of sat_sznz { __DEFAULT ->
                        case GHC.Integer.Type.andInteger
                               fRepI_szna CLaSH.Sized.Fixed.resizeF1
                        of sat_szny { __DEFAULT ->
                        case GHC.Integer.Type.timesInteger sat_szny sat_sznz
                        of sat_sznA { __DEFAULT ->
                        case GHC.Real.$w$sreduce sat_sznA sat_sznB
                        of _ [Occ=Dead] { (# ww1_sznD [Occ=Once], ww2_sznE [Occ=Once] #) ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1_sznD ww2_sznE
                        }
                        }
                        }
                        }
                        }
                    };
                  GHC.Types.True -> case GHC.Real.^3 of _ [Occ=Dead] { }
                }
                }
                };
              GHC.Types.True ->
                case nF_sznd of _ [Occ=Dead] { GHC.Types.I# x_sznH ->
                case GHC.Prim.<# x_sznH 0 of sat_sznI { __DEFAULT ->
                case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_sznI
                of _ [Occ=Dead] {
                  GHC.Types.False ->
                    let {
                      a1_sznK :: GHC.Integer.Type.Integer
                      [LclId, Str=DmdType]
                      a1_sznK =
                        case x_sznH of wild5_sznL {
                          __DEFAULT ->
                            GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_sznL;
                          0 -> GHC.Real.$fEnumRatio1
                        } } in
                    case x_sznH of wild5_sznM {
                      __DEFAULT ->
                        case GHC.Integer.Type.absInteger a1_sznK of sat_sznS { __DEFAULT ->
                        case GHC.Integer.Type.signumInteger a1_sznK
                        of sat_sznQ { __DEFAULT ->
                        case GHC.Real.$wf1 CLaSH.Sized.Fixed.$fShowFixed5 wild5_sznM
                        of sat_sznN { __DEFAULT ->
                        case GHC.Integer.Type.minusInteger
                               sat_sznN CLaSH.Sized.Fixed.$fShowFixed4
                        of sat_sznO { __DEFAULT ->
                        case GHC.Integer.Type.andInteger fRepI_abs_sznc sat_sznO
                        of sat_sznP { __DEFAULT ->
                        case GHC.Integer.Type.timesInteger sat_sznP sat_sznQ
                        of sat_sznR { __DEFAULT ->
                        case GHC.Real.$w$sreduce sat_sznR sat_sznS
                        of _ [Occ=Dead] { (# ww1_sznU [Occ=Once], ww2_sznV [Occ=Once] #) ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1_sznU ww2_sznV
                        }
                        }
                        }
                        }
                        }
                        }
                        };
                      0 ->
                        case GHC.Integer.Type.absInteger a1_sznK of sat_sznZ { __DEFAULT ->
                        case GHC.Integer.Type.signumInteger a1_sznK
                        of sat_sznX { __DEFAULT ->
                        case GHC.Integer.Type.andInteger
                               fRepI_abs_sznc CLaSH.Sized.Fixed.resizeF1
                        of sat_sznW { __DEFAULT ->
                        case GHC.Integer.Type.timesInteger sat_sznW sat_sznX
                        of sat_sznY { __DEFAULT ->
                        case GHC.Real.$w$sreduce sat_sznY sat_sznZ
                        of _ [Occ=Dead] { (# ww1_szo1 [Occ=Once], ww2_szo2 [Occ=Once] #) ->
                        GHC.Real.:% @ GHC.Integer.Type.Integer ww1_szo1 ww2_szo2
                        }
                        }
                        }
                        }
                        }
                    };
                  GHC.Types.True -> case GHC.Real.^3 of _ [Occ=Dead] { }
                }
                }
                }
            }
            } } in
        let {
          sat_szo5 [Occ=Once]
            :: (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
          [LclId, Str=DmdType]
          sat_szo5 = (CLaSH.Sized.Fixed.$fShowFixed6, sat_szo4) } in
        case GHC.List.iterateFB
               @ (GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)
               @ [(GHC.Types.Int, GHC.Real.Ratio GHC.Integer.Type.Integer)]
               CLaSH.Sized.Fixed.$fShowFixed8
               CLaSH.Sized.Fixed.$fShowFixed7
               sat_szo5
        of _ [Occ=Dead] {
          [] -> case Data.Maybe.fromJust1 of _ [Occ=Dead] { };
          : a1_szo8 [Occ=Once!] _ [Occ=Dead] ->
            case a1_szo8
            of _ [Occ=Dead] { (x_szob [Occ=Once!], y_szoc [Occ=Once!]) ->
            case x_szob of _ [Occ=Dead] { GHC.Types.I# x1_szoe [Occ=Once] ->
            let {
              str_szof :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              str_szof =
                case y_szoc
                of _ [Occ=Dead] { GHC.Real.:% x2_szoh [Occ=Once] _ [Occ=Dead] ->
                case GHC.Show.$w$cshowsPrec
                       0 x2_szoh (GHC.Types.[] @ GHC.Types.Char)
                of _ [Occ=Dead] { (# ww3_szok [Occ=Once], ww4_szol [Occ=Once] #) ->
                GHC.Types.: @ GHC.Types.Char ww3_szok ww4_szol
                }
                } } in
            case GHC.List.$wlenAcc @ GHC.Types.Char str_szof 0
            of ww_szom { __DEFAULT ->
            case GHC.Prim.-# x1_szoe ww_szom of n#_szon { __DEFAULT ->
            case GHC.Prim.<=# n#_szon 0 of sat_szoo { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_szoo
            of _ [Occ=Dead] {
              GHC.Types.False ->
                let {
                  lvl1_szoq [Occ=OnceL] :: [GHC.Types.Char]
                  [LclId, Str=DmdType, Unf=OtherCon []]
                  lvl1_szoq =
                    GHC.Types.:
                      @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed3 str_szof } in
                letrec {
                  xs_szor [Occ=LoopBreaker] :: GHC.Prim.Int# -> [GHC.Types.Char]
                  [LclId, Arity=1, Str=DmdType, Unf=OtherCon []]
                  xs_szor =
                    \ (m_szos :: GHC.Prim.Int#) ->
                      case GHC.Prim.<=# m_szos 1 of sat_szot { __DEFAULT ->
                      case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_szot
                      of _ [Occ=Dead] {
                        GHC.Types.False ->
                          let {
                            sat_szow [Occ=Once] :: [GHC.Types.Char]
                            [LclId, Str=DmdType]
                            sat_szow =
                              case GHC.Prim.-# m_szos 1 of sat_szov { __DEFAULT ->
                              xs_szor sat_szov
                              } } in
                          GHC.Types.:
                            @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed3 sat_szow;
                        GHC.Types.True -> lvl1_szoq
                      }
                      }; } in
                xs_szor n#_szon;
              GHC.Types.True -> str_szof
            }
            }
            }
            }
            }
            }
        } } in
    case GHC.Prim.tagToEnum# @ GHC.Types.Bool wild_sznb
    of _ [Occ=Dead] {
      GHC.Types.False ->
        case nF_sznd of _ [Occ=Dead] { GHC.Types.I# x_szoz [Occ=Once] ->
        case GHC.Prim.negateInt# x_szoz of ww_szoA { __DEFAULT ->
        case GHC.Prim.>=# ww_szoA 0 of sat_szoB { __DEFAULT ->
        case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_szoB
        of _ [Occ=Dead] {
          GHC.Types.False ->
            case GHC.Prim.negateInt# ww_szoA of sat_szoD { __DEFAULT ->
            case GHC.Integer.Type.shiftRInteger fRepI_szna sat_szoD
            of sat_szoE { __DEFAULT ->
            case GHC.Show.$w$cshowsPrec
                   0 sat_szoE (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_szoG [Occ=Once], ww4_szoH [Occ=Once] #) ->
            let {
              sat_szoJ [Occ=Once] :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              sat_szoJ =
                GHC.Types.:
                  @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed2 a_sznf } in
            let {
              sat_szoI [Occ=Once] :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              sat_szoI = GHC.Types.: @ GHC.Types.Char ww3_szoG ww4_szoH } in
            GHC.Base.++ @ GHC.Types.Char sat_szoI sat_szoJ
            }
            }
            };
          GHC.Types.True ->
            case GHC.Integer.Type.shiftLInteger fRepI_szna ww_szoA
            of sat_szoK { __DEFAULT ->
            case GHC.Show.$w$cshowsPrec
                   0 sat_szoK (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] { (# ww3_szoM [Occ=Once], ww4_szoN [Occ=Once] #) ->
            let {
              sat_szoP [Occ=Once] :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              sat_szoP =
                GHC.Types.:
                  @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed2 a_sznf } in
            let {
              sat_szoO [Occ=Once] :: [GHC.Types.Char]
              [LclId, Str=DmdType]
              sat_szoO = GHC.Types.: @ GHC.Types.Char ww3_szoM ww4_szoN } in
            GHC.Base.++ @ GHC.Types.Char sat_szoO sat_szoP
            }
            }
        }
        }
        }
        };
      GHC.Types.True ->
        let {
          sat_szp6 [Occ=Once] :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          sat_szp6 =
            GHC.Types.:
              @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed2 a_sznf } in
        let {
          sat_szp4 [Occ=Once] :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          sat_szp4 =
            case nF_sznd of _ [Occ=Dead] { GHC.Types.I# x_szoR [Occ=Once] ->
            case GHC.Prim.negateInt# x_szoR of ww_szoS { __DEFAULT ->
            case GHC.Prim.>=# ww_szoS 0 of sat_szoT { __DEFAULT ->
            case GHC.Prim.tagToEnum# @ GHC.Types.Bool sat_szoT
            of _ [Occ=Dead] {
              GHC.Types.False ->
                case GHC.Prim.negateInt# ww_szoS of sat_szoV { __DEFAULT ->
                case GHC.Integer.Type.shiftRInteger fRepI_abs_sznc sat_szoV
                of sat_szoW { __DEFAULT ->
                case GHC.Show.$w$cshowsPrec
                       0 sat_szoW (GHC.Types.[] @ GHC.Types.Char)
                of _ [Occ=Dead] { (# ww3_szoY [Occ=Once], ww4_szoZ [Occ=Once] #) ->
                GHC.Types.: @ GHC.Types.Char ww3_szoY ww4_szoZ
                }
                }
                };
              GHC.Types.True ->
                case GHC.Integer.Type.shiftLInteger fRepI_abs_sznc ww_szoS
                of sat_szp0 { __DEFAULT ->
                case GHC.Show.$w$cshowsPrec
                       0 sat_szp0 (GHC.Types.[] @ GHC.Types.Char)
                of _ [Occ=Dead] { (# ww3_szp2 [Occ=Once], ww4_szp3 [Occ=Once] #) ->
                GHC.Types.: @ GHC.Types.Char ww3_szp2 ww4_szp3
                }
                }
            }
            }
            }
            } } in
        let {
          sat_szp5 [Occ=Once] :: [GHC.Types.Char]
          [LclId, Str=DmdType]
          sat_szp5 =
            GHC.Types.:
              @ GHC.Types.Char CLaSH.Sized.Fixed.$fShowFixed1 sat_szp4 } in
        GHC.Base.++ @ GHC.Types.Char sat_szp5 sat_szp6
    }
    }

CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Types.Int
     -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
     -> GHC.Show.ShowS
[GblId, Arity=7, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_szp7 [Occ=Once] :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_szp8 [Occ=Once] :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_szp9 [Occ=Once] :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_szpa [Occ=Once]
       :: GHC.Real.Integral (rep_auHy size_auHz))
    _ [Occ=Dead]
    (x_szpc [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
    (s_szpd [Occ=Once] :: GHC.Base.String) ->
    case CLaSH.Sized.Fixed.$fShowFixed_$cshow
           @ frac_auHx
           @ rep_auHy
           @ size_auHz
           $dShow_szp7
           $dBits_szp8
           $dKnownNat_szp9
           $dIntegral_szpa
           x_szpc
    of sat_szpe { __DEFAULT ->
    GHC.Base.++ @ GHC.Types.Char sat_szpe s_szpd
    }

CLaSH.Sized.Fixed.$fShowFixed_$cshowList
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
     -> GHC.Show.ShowS
[GblId, Arity=6, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed_$cshowList =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_szpf [Occ=OnceL] :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_szpg [Occ=OnceL] :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_szph [Occ=OnceL] :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_szpi [Occ=OnceL]
       :: GHC.Real.Integral (rep_auHy size_auHz))
    (eta_szpj [Occ=Once]
       :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
    (eta1_szpk [Occ=Once] :: GHC.Base.String) ->
    let {
      sat_szpo [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
           -> GHC.Show.ShowS
      [LclId, Str=DmdType]
      sat_szpo =
        \ (x_szpl [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
          (s_szpm [Occ=Once] :: GHC.Base.String) ->
          case CLaSH.Sized.Fixed.$fShowFixed_$cshow
                 @ frac_auHx
                 @ rep_auHy
                 @ size_auHz
                 $dShow_szpf
                 $dBits_szpg
                 $dKnownNat_szph
                 $dIntegral_szpi
                 x_szpl
          of sat_szpn { __DEFAULT ->
          GHC.Base.++ @ GHC.Types.Char sat_szpn s_szpm
          } } in
    GHC.Show.showList__
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      sat_szpo
      eta_szpj
      eta1_szpk

CLaSH.Sized.Fixed.$fShowFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auHx :: GHC.TypeLits.Nat)
            (rep_auHy :: GHC.TypeLits.Nat -> *)
            (size_auHz :: GHC.TypeLits.Nat).
     (GHC.Show.Show (rep_auHy size_auHz),
      Data.Bits.Bits (rep_auHy size_auHz),
      GHC.TypeLits.KnownNat frac_auHx,
      GHC.Real.Integral (rep_auHy size_auHz)) =>
     GHC.Show.Show
       (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
[GblId[DFunId], Arity=4, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fShowFixed =
  \ (@ (frac_auHx :: GHC.TypeLits.Nat))
    (@ (rep_auHy :: GHC.TypeLits.Nat -> *))
    (@ (size_auHz :: GHC.TypeLits.Nat))
    ($dShow_szpp :: GHC.Show.Show (rep_auHy size_auHz))
    ($dBits_szpq :: Data.Bits.Bits (rep_auHy size_auHz))
    ($dKnownNat_szpr :: GHC.TypeLits.KnownNat frac_auHx)
    ($dIntegral_szps :: GHC.Real.Integral (rep_auHy size_auHz)) ->
    let {
      sat_szpv [Occ=Once]
        :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz]
           -> GHC.Show.ShowS
      [LclId, Str=DmdType]
      sat_szpv =
        \ (eta_B2 [Occ=Once]
             :: [CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz])
          (eta_B1 [Occ=Once] :: GHC.Base.String) ->
          CLaSH.Sized.Fixed.$fShowFixed_$cshowList
            @ frac_auHx
            @ rep_auHy
            @ size_auHz
            $dShow_szpp
            $dBits_szpq
            $dKnownNat_szpr
            $dIntegral_szps
            eta_B2
            eta_B1 } in
    let {
      sat_szpu [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
           -> GHC.Base.String
      [LclId, Str=DmdType]
      sat_szpu =
        \ (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz) ->
          CLaSH.Sized.Fixed.$fShowFixed_$cshow
            @ frac_auHx
            @ rep_auHy
            @ size_auHz
            $dShow_szpp
            $dBits_szpq
            $dKnownNat_szpr
            $dIntegral_szps
            eta_B1 } in
    let {
      sat_szpt [Occ=Once]
        :: GHC.Types.Int
           -> CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz
           -> GHC.Show.ShowS
      [LclId, Str=DmdType]
      sat_szpt =
        \ (eta_B3 [Occ=Once] :: GHC.Types.Int)
          (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
          (eta_B1 [Occ=Once] :: GHC.Base.String) ->
          CLaSH.Sized.Fixed.$fShowFixed_$cshowsPrec
            @ frac_auHx
            @ rep_auHy
            @ size_auHz
            $dShow_szpp
            $dBits_szpq
            $dKnownNat_szpr
            $dIntegral_szps
            eta_B3
            eta_B2
            eta_B1 } in
    GHC.Show.D:Show
      @ (CLaSH.Sized.Fixed.Fixed frac_auHx rep_auHy size_auHz)
      sat_szpt
      sat_szpu
      sat_szpv

CLaSH.Sized.Fixed.$fMultFixedFixed1
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu)
[GblId, Arity=3, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fMultFixedFixed1 =
  \ (@ (frac1_auHq :: GHC.TypeLits.Nat))
    (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHs :: GHC.TypeLits.Nat))
    (@ (frac2_auHt :: GHC.TypeLits.Nat))
    (@ (size2_auHu :: GHC.TypeLits.Nat))
    (tup_szpw [Occ=Once!]
       :: CLaSH.Sized.Fixed.MultFixed
            rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
    (eta_szpx [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
    (eta1_szpy [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
    case tup_szpw
    of _ [Occ=Dead] { (tpl_szpA [Occ=Once], tpl1_szpB [Occ=Once!]) ->
    case tpl1_szpB of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw3M ->
    ((tpl_szpA
      `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                <rep_auHr size1_auHs>_N <rep_auHr size2_auHu>_N
              :: CLaSH.Class.Num.Mult (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                   ~#
                 (rep_auHr size1_auHs
                  -> rep_auHr size2_auHu
                  -> CLaSH.Class.Num.MResult
                       (rep_auHr size1_auHs) (rep_auHr size2_auHu))))
       (eta_szpx
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq>_P <rep_auHr>_R <size1_auHs>_N
                :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
                     ~#
                   rep_auHr size1_auHs))
       (eta1_szpy
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac2_auHt>_P <rep_auHr>_R <size2_auHu>_N
                :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
                     ~#
                   rep_auHr size2_auHu)))
    `cast` (Sub cobox1_dw3M
            :: CLaSH.Class.Num.MResult
                 (rep_auHr size1_auHs) (rep_auHr size2_auHu)
                 ~#
               rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
    }
    }

CLaSH.Sized.Fixed.$fMultFixedFixed_$cmult
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
     -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
     -> CLaSH.Class.Num.MResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
          (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[GblId, Arity=3, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fMultFixedFixed_$cmult =
  (\ (@ (frac1_auHq :: GHC.TypeLits.Nat))
     (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
     (@ (size1_auHs :: GHC.TypeLits.Nat))
     (@ (frac2_auHt :: GHC.TypeLits.Nat))
     (@ (size2_auHu :: GHC.TypeLits.Nat))
     (eta_B3 [Occ=Once]
        :: CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
     (eta_B2 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
     CLaSH.Sized.Fixed.$fMultFixedFixed1
       @ frac1_auHq
       @ rep_auHr
       @ size1_auHs
       @ frac2_auHt
       @ size2_auHu
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
          -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
          -> Sym
               (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                          GHC.TypeLits.+ size2_auHu>_N
             ; Sub
                 (Sym
                    (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                       <frac1_auHq>_N
                       <rep_auHr>_N
                       <size1_auHs>_N
                       <frac2_auHt>_N
                       <size2_auHu>_N))
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> CLaSH.Class.Num.MResult
                   (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                   (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fMultFixedFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac1_auHq :: GHC.TypeLits.Nat)
            (rep_auHr :: GHC.TypeLits.Nat -> *)
            (size1_auHs :: GHC.TypeLits.Nat)
            (frac2_auHt :: GHC.TypeLits.Nat)
            (size2_auHu :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.MultFixed
        rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
     CLaSH.Class.Num.Mult
       (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
       (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)
[GblId[DFunId(nt)],
 Arity=3,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fMultFixedFixed =
  (\ (@ (frac1_auHq :: GHC.TypeLits.Nat))
     (@ (rep_auHr :: GHC.TypeLits.Nat -> *))
     (@ (size1_auHs :: GHC.TypeLits.Nat))
     (@ (frac2_auHt :: GHC.TypeLits.Nat))
     (@ (size2_auHu :: GHC.TypeLits.Nat))
     (eta_B3 [Occ=Once]
        :: CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu)
     (eta_B2 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu) ->
     CLaSH.Sized.Fixed.$fMultFixedFixed1
       @ frac1_auHq
       @ rep_auHr
       @ size1_auHs
       @ frac2_auHt
       @ size2_auHu
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac1_auHq :: GHC.TypeLits.Nat)
                 (rep_auHr :: GHC.TypeLits.Nat -> *)
                 (size1_auHs :: GHC.TypeLits.Nat)
                 (frac2_auHt :: GHC.TypeLits.Nat)
                 (size2_auHu :: GHC.TypeLits.Nat).
          <CLaSH.Sized.Fixed.MultFixed
             rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_R
              -> <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_R
              -> Sym
                   (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac1_auHq GHC.TypeLits.+ frac2_auHt>_P <rep_auHr>_R) <size1_auHs
                                                                              GHC.TypeLits.+ size2_auHu>_N
                 ; Sub
                     (Sym
                        (CLaSH.Sized.Fixed.TFCo:R:MResultFixedFixed[0]
                           <frac1_auHq>_N
                           <rep_auHr>_N
                           <size1_auHs>_N
                           <frac2_auHt>_N
                           <size2_auHu>_N)))
             ; Sym
                 (CLaSH.Class.Num.NTCo:Mult[0]
                    <CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs>_N
                    <CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu>_N)
          :: (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs
              -> CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu
              -> rep_auHr (size1_auHs GHC.TypeLits.+ size2_auHu))
               ~#
             (forall (frac1_auHq :: GHC.TypeLits.Nat)
                     (rep_auHr :: GHC.TypeLits.Nat -> *)
                     (size1_auHs :: GHC.TypeLits.Nat)
                     (frac2_auHt :: GHC.TypeLits.Nat)
                     (size2_auHu :: GHC.TypeLits.Nat).
              (CLaSH.Sized.Fixed.MultFixed
                 rep_auHr frac1_auHq frac2_auHt size1_auHs size2_auHu) =>
              CLaSH.Class.Num.Mult
                (CLaSH.Sized.Fixed.Fixed frac1_auHq rep_auHr size1_auHs)
                (CLaSH.Sized.Fixed.Fixed frac2_auHt rep_auHr size2_auHu)))

CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_szpD [Occ=Once!]
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_szpE [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta1_szpF [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_szpD
    of _ [Occ=Dead] { (tpl_szpH, tpl1_szpI, tpl2_szpJ [Occ=Once]) ->
    let {
      $dKnownNat_szpK
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_szpK =
        case tpl1_szpI
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl12_szpV [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl12_szpV
        } } in
    let {
      $dBits_szpY
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_szpY =
        case tpl1_szpI
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_szq8 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl11_szq8
        } } in
    let {
      $dKnownNat1_szqc
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat1_szqc =
        case tpl1_szpI
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_szqk [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl9_szqk
        } } in
    let {
      $dResize_szqq :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_szqq =
        case tpl1_szpI
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl8_szqx [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl8_szqx
        } } in
    let {
      $dBounded_szqE
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_szqE =
        case tpl1_szpI
        of _ [Occ=Dead]
        { (tpl3_szqG [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_szqG
        } } in
    let {
      sat_sztF [Occ=Once]
        :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                     GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      sat_sztF =
        let {
          $dBits1_szsh :: Data.Bits.Bits (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          $dBits1_szsh =
            case tpl1_szpI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szsn [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl7_szsn
            } } in
        let {
          sat_sztD [Occ=Once] :: GHC.Enum.Bounded (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_sztD =
            case tpl1_szpI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_sztC [Occ=Once]) ->
            tpl14_sztC
            } } in
        let {
          sat_sztp [Occ=Once] :: GHC.TypeLits.KnownNat frac2_auHg
          [LclId, Str=DmdType]
          sat_sztp =
            case tpl1_szpI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl13_sztn [Occ=Once], _ [Occ=Dead]) ->
            tpl13_sztn
            } } in
        let {
          sat_sztb [Occ=Once] :: GHC.TypeLits.KnownNat size2_auHh
          [LclId, Str=DmdType]
          sat_sztb =
            case tpl1_szpI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_szt6 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl10_szt6
            } } in
        let {
          sat_szsX [Occ=Once] :: GHC.Num.Num (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_szsX =
            case tpl1_szpI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szsO [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl6_szsO
            } } in
        let {
          sat_szsJ [Occ=Once] :: GHC.Classes.Ord (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_szsJ =
            case tpl1_szpI
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], tpl5_szsz [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl5_szsz
            } } in
        let {
          sat_szsv [Occ=Once] :: GHC.Classes.Eq (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_szsv =
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits1_szsh } in
        let {
          sat_sztE [Occ=Once]
            :: CLaSH.Sized.Fixed.ResizeFC
                 rep_auHe
                 frac2_auHg
                 (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                 size2_auHh
                 (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
          [LclId, Str=DmdType]
          sat_sztE =
            ($dBounded_szqE,
             sat_szsv,
             sat_szsJ,
             sat_szsX,
             $dBits1_szsh,
             $dResize_szqq,
             $dKnownNat1_szqc,
             sat_sztb,
             $dBits_szpY,
             $dKnownNat_szpK,
             sat_sztp,
             sat_sztD) } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           sat_sztE
           eta1_szpF)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)) } in
    let {
      sat_szsg [Occ=Once]
        :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                     GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      sat_szsg =
        let {
          $dBits1_szqS :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits1_szqS =
            case tpl_szpH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szqY [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl7_szqY
            } } in
        let {
          sat_szse [Occ=Once] :: GHC.Enum.Bounded (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_szse =
            case tpl_szpH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_szsd [Occ=Once]) ->
            tpl14_szsd
            } } in
        let {
          sat_szs0 [Occ=Once] :: GHC.TypeLits.KnownNat frac1_auHd
          [LclId, Str=DmdType]
          sat_szs0 =
            case tpl_szpH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl13_szrY [Occ=Once], _ [Occ=Dead]) ->
            tpl13_szrY
            } } in
        let {
          sat_szrM [Occ=Once] :: GHC.TypeLits.KnownNat size1_auHf
          [LclId, Str=DmdType]
          sat_szrM =
            case tpl_szpH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_szrH [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl10_szrH
            } } in
        let {
          sat_szry [Occ=Once] :: GHC.Num.Num (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_szry =
            case tpl_szpH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szrp [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl6_szrp
            } } in
        let {
          sat_szrk [Occ=Once] :: GHC.Classes.Ord (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_szrk =
            case tpl_szpH
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], tpl5_szra [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl5_szra
            } } in
        let {
          sat_szr6 [Occ=Once] :: GHC.Classes.Eq (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_szr6 =
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits1_szqS } in
        let {
          sat_szsf [Occ=Once]
            :: CLaSH.Sized.Fixed.ResizeFC
                 rep_auHe
                 frac1_auHd
                 (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                 size1_auHf
                 (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
          [LclId, Str=DmdType]
          sat_szsf =
            ($dBounded_szqE,
             sat_szr6,
             sat_szrk,
             sat_szry,
             $dBits1_szqS,
             $dResize_szqq,
             $dKnownNat1_szqc,
             sat_szrM,
             $dBits_szpY,
             $dKnownNat_szpK,
             sat_szs0,
             sat_szse) } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           sat_szsf
           eta_szpE)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)) } in
    (GHC.Num.-
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl2_szpJ
       sat_szsg
       sat_sztF)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
     -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
     -> CLaSH.Class.Num.AResult
          (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_sztG [Occ=Once!]
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh)
    (eta_sztH [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
    (eta1_sztI [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
    case tup_sztG
    of _ [Occ=Dead] { (tpl_sztK, tpl1_sztL, tpl2_sztM [Occ=Once]) ->
    let {
      $dKnownNat_sztN
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
      [LclId, Str=DmdType]
      $dKnownNat_sztN =
        case tpl1_sztL
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl12_sztY [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl12_sztY
        } } in
    let {
      $dBits_szu1
        :: Data.Bits.Bits
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBits_szu1 =
        case tpl1_sztL
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_szub [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl11_szub
        } } in
    let {
      $dKnownNat1_szuf
        :: GHC.TypeLits.KnownNat
             (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      $dKnownNat1_szuf =
        case tpl1_sztL
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_szun [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl9_szun
        } } in
    let {
      $dResize_szut :: CLaSH.Class.Num.Resize rep_auHe
      [LclId, Str=DmdType]
      $dResize_szut =
        case tpl1_sztL
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl8_szuA [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl8_szuA
        } } in
    let {
      $dBounded_szuH
        :: GHC.Enum.Bounded
             (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                        GHC.TypeLits.+ 1))
      [LclId, Str=DmdType]
      $dBounded_szuH =
        case tpl1_sztL
        of _ [Occ=Dead]
        { (tpl3_szuJ [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_szuJ
        } } in
    let {
      sat_szxI [Occ=Once]
        :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                     GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      sat_szxI =
        let {
          $dBits1_szwk :: Data.Bits.Bits (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          $dBits1_szwk =
            case tpl1_sztL
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szwq [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl7_szwq
            } } in
        let {
          sat_szxG [Occ=Once] :: GHC.Enum.Bounded (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_szxG =
            case tpl1_sztL
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_szxF [Occ=Once]) ->
            tpl14_szxF
            } } in
        let {
          sat_szxs [Occ=Once] :: GHC.TypeLits.KnownNat frac2_auHg
          [LclId, Str=DmdType]
          sat_szxs =
            case tpl1_sztL
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl13_szxq [Occ=Once], _ [Occ=Dead]) ->
            tpl13_szxq
            } } in
        let {
          sat_szxe [Occ=Once] :: GHC.TypeLits.KnownNat size2_auHh
          [LclId, Str=DmdType]
          sat_szxe =
            case tpl1_sztL
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_szx9 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl10_szx9
            } } in
        let {
          sat_szx0 [Occ=Once] :: GHC.Num.Num (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_szx0 =
            case tpl1_sztL
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szwR [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl6_szwR
            } } in
        let {
          sat_szwM [Occ=Once] :: GHC.Classes.Ord (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_szwM =
            case tpl1_sztL
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], tpl5_szwC [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl5_szwC
            } } in
        let {
          sat_szwy [Occ=Once] :: GHC.Classes.Eq (rep_auHe size2_auHh)
          [LclId, Str=DmdType]
          sat_szwy =
            Data.Bits.$p1Bits @ (rep_auHe size2_auHh) $dBits1_szwk } in
        let {
          sat_szxH [Occ=Once]
            :: CLaSH.Sized.Fixed.ResizeFC
                 rep_auHe
                 frac2_auHg
                 (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                 size2_auHh
                 (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
          [LclId, Str=DmdType]
          sat_szxH =
            ($dBounded_szuH,
             sat_szwy,
             sat_szwM,
             sat_szx0,
             $dBits1_szwk,
             $dResize_szut,
             $dKnownNat1_szuf,
             sat_szxe,
             $dBits_szu1,
             $dKnownNat_sztN,
             sat_szxs,
             sat_szxG) } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac2_auHg
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size2_auHh
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           sat_szxH
           eta1_sztI)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)) } in
    let {
      sat_szwj [Occ=Once]
        :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                     GHC.TypeLits.+ 1)
      [LclId, Str=DmdType]
      sat_szwj =
        let {
          $dBits1_szuV :: Data.Bits.Bits (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          $dBits1_szuV =
            case tpl_sztK
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szv1 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl7_szv1
            } } in
        let {
          sat_szwh [Occ=Once] :: GHC.Enum.Bounded (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_szwh =
            case tpl_sztK
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_szwg [Occ=Once]) ->
            tpl14_szwg
            } } in
        let {
          sat_szw3 [Occ=Once] :: GHC.TypeLits.KnownNat frac1_auHd
          [LclId, Str=DmdType]
          sat_szw3 =
            case tpl_sztK
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl13_szw1 [Occ=Once], _ [Occ=Dead]) ->
            tpl13_szw1
            } } in
        let {
          sat_szvP [Occ=Once] :: GHC.TypeLits.KnownNat size1_auHf
          [LclId, Str=DmdType]
          sat_szvP =
            case tpl_sztK
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_szvK [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl10_szvK
            } } in
        let {
          sat_szvB [Occ=Once] :: GHC.Num.Num (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_szvB =
            case tpl_sztK
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szvs [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl6_szvs
            } } in
        let {
          sat_szvn [Occ=Once] :: GHC.Classes.Ord (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_szvn =
            case tpl_sztK
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], tpl5_szvd [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            tpl5_szvd
            } } in
        let {
          sat_szv9 [Occ=Once] :: GHC.Classes.Eq (rep_auHe size1_auHf)
          [LclId, Str=DmdType]
          sat_szv9 =
            Data.Bits.$p1Bits @ (rep_auHe size1_auHf) $dBits1_szuV } in
        let {
          sat_szwi [Occ=Once]
            :: CLaSH.Sized.Fixed.ResizeFC
                 rep_auHe
                 frac1_auHd
                 (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                 size1_auHf
                 (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
          [LclId, Str=DmdType]
          sat_szwi =
            ($dBounded_szuH,
             sat_szv9,
             sat_szvn,
             sat_szvB,
             $dBits1_szuV,
             $dResize_szut,
             $dKnownNat1_szuf,
             sat_szvP,
             $dBits_szu1,
             $dKnownNat_sztN,
             sat_szw3,
             sat_szwh) } in
        (CLaSH.Sized.Fixed.resizeF
           @ frac1_auHd
           @ (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
           @ rep_auHe
           @ size1_auHf
           @ (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
           sat_szwi
           eta_sztH)
        `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                  <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                  <rep_auHe>_R <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
                :: CLaSH.Sized.Fixed.Fixed
                     (CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg)
                     rep_auHe
                     (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh GHC.TypeLits.+ 1)
                     ~#
                   rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                             GHC.TypeLits.+ 1)) } in
    (GHC.Num.+
       @ (rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                    GHC.TypeLits.+ 1))
       tpl2_sztM
       sat_szwj
       sat_szxI)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <CLaSH.Promoted.Ord.Max frac1_auHd frac2_auHg>_P
                 <rep_auHe>_R) <CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                                GHC.TypeLits.+ 1>_N
            ; Sub
                (Sym
                   (CLaSH.Sized.Fixed.TFCo:R:AResultFixedFixed[0]
                      <frac1_auHd>_N
                      <rep_auHe>_N
                      <size1_auHf>_N
                      <frac2_auHg>_N
                      <size2_auHh>_N))
            :: rep_auHe (CLaSH.Promoted.Ord.Max size1_auHf size2_auHh
                         GHC.TypeLits.+ 1)
                 ~#
               CLaSH.Class.Num.AResult
                 (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                 (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh))
    }

CLaSH.Sized.Fixed.$fAddFixedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac1_auHd :: GHC.TypeLits.Nat)
            (rep_auHe :: GHC.TypeLits.Nat -> *)
            (size1_auHf :: GHC.TypeLits.Nat)
            (frac2_auHg :: GHC.TypeLits.Nat)
            (size2_auHh :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.AddFixed
        rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) =>
     CLaSH.Class.Num.Add
       (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
       (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
[GblId[DFunId], Arity=1, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fAddFixedFixed =
  \ (@ (frac1_auHd :: GHC.TypeLits.Nat))
    (@ (rep_auHe :: GHC.TypeLits.Nat -> *))
    (@ (size1_auHf :: GHC.TypeLits.Nat))
    (@ (frac2_auHg :: GHC.TypeLits.Nat))
    (@ (size2_auHh :: GHC.TypeLits.Nat))
    (tup_szxJ
       :: CLaSH.Sized.Fixed.AddFixed
            rep_auHe frac1_auHd frac2_auHg size1_auHf size2_auHh) ->
    let {
      sat_szxL [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
           -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
           -> CLaSH.Class.Num.AResult
                (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      sat_szxL =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
          CLaSH.Sized.Fixed.$fAddFixedFixed_$cminus
            @ frac1_auHd
            @ rep_auHe
            @ size1_auHf
            @ frac2_auHg
            @ size2_auHh
            tup_szxJ
            eta_B2
            eta_B1 } in
    let {
      sat_szxK [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf
           -> CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh
           -> CLaSH.Class.Num.AResult
                (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
                (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      [LclId, Str=DmdType]
      sat_szxK =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh) ->
          CLaSH.Sized.Fixed.$fAddFixedFixed_$cplus
            @ frac1_auHd
            @ rep_auHe
            @ size1_auHf
            @ frac2_auHg
            @ size2_auHh
            tup_szxJ
            eta_B2
            eta_B1 } in
    CLaSH.Class.Num.D:Add
      @ (CLaSH.Sized.Fixed.Fixed frac1_auHd rep_auHe size1_auHf)
      @ (CLaSH.Sized.Fixed.Fixed frac2_auHg rep_auHe size2_auHh)
      sat_szxK
      sat_szxL

CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Integer.Type.Integer
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_szxM [Occ=Once!]
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_szxN [Occ=Once] :: GHC.Integer.Type.Integer) ->
    case tup_szxM
    of _ [Occ=Dead]
    { (_ [Occ=Dead], tpl1_szxQ [Occ=Once!], tpl2_szxR [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
    case tpl1_szxQ
    of _ [Occ=Dead]
    { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl14_szy4 [Occ=Once], tpl15_szy5 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
    let {
      sat_szya [Occ=Once] :: GHC.Types.Int
      [LclId, Str=DmdType]
      sat_szya =
        case GHC.Integer.Type.integerToInt
               (tpl15_szy5
                `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGY>_N
                        ; GHC.TypeLits.NTCo:SNat[0] <frac_auGY>_P
                        :: GHC.TypeLits.KnownNat frac_auGY ~# GHC.Integer.Type.Integer))
        of wild2_szy9 { __DEFAULT ->
        GHC.Types.I# wild2_szy9
        } } in
    let {
      sat_szy8 [Occ=Once] :: rep_auGZ size_auH0
      [LclId, Str=DmdType]
      sat_szy8 =
        GHC.Num.fromInteger @ (rep_auGZ size_auH0) tpl2_szxR eta_szxN } in
    (Data.Bits.shiftL
       @ (rep_auGZ size_auH0) tpl14_szy4 sat_szy8 sat_szya)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R) <size_auH0>_N
            :: rep_auGZ size_auH0
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
    }
    }

CLaSH.Sized.Fixed.$fNumFixed1
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> rep_auGZ size_auH0
[GblId, Arity=2, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed1 =
  \ (@ (frac_auGY :: GHC.TypeLits.Nat))
    (@ (rep_auGZ :: GHC.TypeLits.Nat -> *))
    (@ (size_auH0 :: GHC.TypeLits.Nat))
    (tup_szyb [Occ=Once!]
       :: CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0)
    (eta_szyc [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0) ->
    case tup_szyb
    of _ [Occ=Dead]
    { (_ [Occ=Dead], _ [Occ=Dead], tpl2_szyg [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
    GHC.Num.signum
      @ (rep_auGZ size_auH0)
      tpl2_szyg
      (eta_szyc
       `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_auGY>_P <rep_auGZ>_R <size_auH0>_N
               :: CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
                    ~#
                  rep_auGZ size_auH0))
    }

CLaSH.Sized.Fixed.$fNumFixed_$cabs
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$cabs =
  \ (@ (frac_XuIJ :: GHC.TypeLits.Nat))
    (@ (rep_XuIL :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIN :: GHC.TypeLits.Nat))
    (tup_szyk
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIJ rep_XuIL size_XuIN)
    (eta_szyl [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN) ->
    let {
      tup1_szym :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId, Str=DmdType]
      tup1_szym =
        case tup_szyk
        of _ [Occ=Dead]
        { (tpl_szyo [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szyo
        } } in
    let {
      $dKnownNat_szyu
        :: GHC.TypeLits.KnownNat (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_szyu =
        case tup1_szym
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szyD [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_szyD
        } } in
    let {
      tup2_szyG
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIL
             (frac_XuIJ GHC.TypeLits.+ frac_XuIJ)
             frac_XuIJ
             (size_XuIN GHC.TypeLits.+ size_XuIN)
             size_XuIN
      [LclId, Str=DmdType]
      tup2_szyG =
        case tup_szyk
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_szyJ [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_szyJ
        } } in
    let {
      $dKnownNat1_szyO :: GHC.TypeLits.KnownNat size_XuIN
      [LclId, Str=DmdType]
      $dKnownNat1_szyO =
        case tup2_szyG
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szyW [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_szyW
        } } in
    let {
      sat_szAY [Occ=Once] :: rep_XuIL (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szAY =
        case tup_szyk
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_szAH [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        let {
          sat_szAX [Occ=Once] :: rep_XuIL (size_XuIN GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_szAX =
            case tup2_szyG
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_szAQ [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_szAQ
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIL>_N
                     :: CLaSH.Class.Num.Resize rep_XuIL
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIL a_ae8M -> rep_XuIL b_ae8N)))
              @ size_XuIN
              @ (size_XuIN GHC.TypeLits.+ 2)
              $dKnownNat1_szyO
              $dKnownNat_szyu
              (eta_szyl
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIJ>_P <rep_XuIL>_R <size_XuIN>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN
                            ~#
                          rep_XuIL size_XuIN))
            } } in
        GHC.Num.abs
          @ (rep_XuIL (size_XuIN GHC.TypeLits.+ 2)) tpl3_szAH sat_szAX
        } } in
    let {
      sat_szAB [Occ=Once]
        :: Data.Bits.Bits (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_szAB =
        case tup1_szym
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_szAA [Occ=Once]) ->
        tpl9_szAA
        } } in
    let {
      sat_szAp [Occ=Once] :: GHC.Enum.Bounded (rep_XuIL size_XuIN)
      [LclId, Str=DmdType]
      sat_szAp =
        case tup2_szyG
        of _ [Occ=Dead]
        { (tpl_szAd [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szAd
        } } in
    let {
      sat_szAb [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize
             (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
           ~ (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szAb =
        case tup1_szym
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_szA6 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_szA6
        } } in
    let {
      sat_szzZ [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize (rep_XuIL size_XuIN) ~ size_XuIN
      [LclId, Str=DmdType]
      sat_szzZ =
        case tup1_szym
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_szzT [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_szzT
        } } in
    let {
      sat_szzN [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector
             (rep_XuIL (size_XuIN GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_szzN =
        case tup1_szym
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_szzG [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_szzG
        } } in
    let {
      sat_szzB [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector (rep_XuIL size_XuIN)
      [LclId, Str=DmdType]
      sat_szzB =
        case tup1_szym
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_szzt [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_szzt
        } } in
    let {
      sat_szzp [Occ=Once]
        :: ((size_XuIN GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_XuIN GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szzp =
        case tup1_szym
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_szzg [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_szzg
        } } in
    let {
      sat_szzd [Occ=Once] :: 1 GHC.TypeLits.<= size_XuIN
      [LclId, Str=DmdType]
      sat_szzd =
        case tup1_szym
        of _ [Occ=Dead]
        { (tpl_szz3 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szz3
        } } in
    let {
      sat_szAC [Occ=Once] :: CLaSH.Sized.Fixed.SatN2C rep_XuIL size_XuIN
      [LclId, Str=DmdType]
      sat_szAC =
        (sat_szzd,
         sat_szzp,
         sat_szzB,
         sat_szzN,
         sat_szzZ,
         sat_szAb,
         $dKnownNat1_szyO,
         $dKnownNat_szyu,
         sat_szAp,
         sat_szAB) } in
    (CLaSH.Sized.Fixed.satN2 @ rep_XuIL @ size_XuIN sat_szAC sat_szAY)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIJ>_P <rep_XuIL>_R) <size_XuIN>_N
            :: rep_XuIL size_XuIN
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIJ rep_XuIL size_XuIN)

CLaSH.Sized.Fixed.$fNumFixed_$cnegate
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$cnegate =
  \ (@ (frac_XuIK :: GHC.TypeLits.Nat))
    (@ (rep_XuIM :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIO :: GHC.TypeLits.Nat))
    (tup_szAZ
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIK rep_XuIM size_XuIO)
    (eta_szB0 [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO) ->
    let {
      tup1_szB1 :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId, Str=DmdType]
      tup1_szB1 =
        case tup_szAZ
        of _ [Occ=Dead]
        { (tpl_szB3 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szB3
        } } in
    let {
      $dKnownNat_szB9
        :: GHC.TypeLits.KnownNat (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_szB9 =
        case tup1_szB1
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szBi [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_szBi
        } } in
    let {
      tup2_szBl
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIM
             (frac_XuIK GHC.TypeLits.+ frac_XuIK)
             frac_XuIK
             (size_XuIO GHC.TypeLits.+ size_XuIO)
             size_XuIO
      [LclId, Str=DmdType]
      tup2_szBl =
        case tup_szAZ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_szBo [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_szBo
        } } in
    let {
      $dKnownNat1_szBt :: GHC.TypeLits.KnownNat size_XuIO
      [LclId, Str=DmdType]
      $dKnownNat1_szBt =
        case tup2_szBl
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szBB [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_szBB
        } } in
    let {
      sat_szDD [Occ=Once] :: rep_XuIM (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szDD =
        case tup_szAZ
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_szDm [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        let {
          sat_szDC [Occ=Once] :: rep_XuIM (size_XuIO GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_szDC =
            case tup2_szBl
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_szDv [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_szDv
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIM>_N
                     :: CLaSH.Class.Num.Resize rep_XuIM
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIM a_ae8M -> rep_XuIM b_ae8N)))
              @ size_XuIO
              @ (size_XuIO GHC.TypeLits.+ 2)
              $dKnownNat1_szBt
              $dKnownNat_szB9
              (eta_szB0
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIK>_P <rep_XuIM>_R <size_XuIO>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO
                            ~#
                          rep_XuIM size_XuIO))
            } } in
        GHC.Num.negate
          @ (rep_XuIM (size_XuIO GHC.TypeLits.+ 2)) tpl3_szDm sat_szDC
        } } in
    let {
      sat_szDg [Occ=Once]
        :: Data.Bits.Bits (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_szDg =
        case tup1_szB1
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_szDf [Occ=Once]) ->
        tpl9_szDf
        } } in
    let {
      sat_szD4 [Occ=Once] :: GHC.Enum.Bounded (rep_XuIM size_XuIO)
      [LclId, Str=DmdType]
      sat_szD4 =
        case tup2_szBl
        of _ [Occ=Dead]
        { (tpl_szCS [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szCS
        } } in
    let {
      sat_szCQ [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize
             (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
           ~ (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szCQ =
        case tup1_szB1
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_szCL [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_szCL
        } } in
    let {
      sat_szCE [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize (rep_XuIM size_XuIO) ~ size_XuIO
      [LclId, Str=DmdType]
      sat_szCE =
        case tup1_szB1
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_szCy [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_szCy
        } } in
    let {
      sat_szCs [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector
             (rep_XuIM (size_XuIO GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_szCs =
        case tup1_szB1
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_szCl [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_szCl
        } } in
    let {
      sat_szCg [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector (rep_XuIM size_XuIO)
      [LclId, Str=DmdType]
      sat_szCg =
        case tup1_szB1
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_szC8 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_szC8
        } } in
    let {
      sat_szC4 [Occ=Once]
        :: ((size_XuIO GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_XuIO GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szC4 =
        case tup1_szB1
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_szBV [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_szBV
        } } in
    let {
      sat_szBS [Occ=Once] :: 1 GHC.TypeLits.<= size_XuIO
      [LclId, Str=DmdType]
      sat_szBS =
        case tup1_szB1
        of _ [Occ=Dead]
        { (tpl_szBI [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szBI
        } } in
    let {
      sat_szDh [Occ=Once] :: CLaSH.Sized.Fixed.SatN2C rep_XuIM size_XuIO
      [LclId, Str=DmdType]
      sat_szDh =
        (sat_szBS,
         sat_szC4,
         sat_szCg,
         sat_szCs,
         sat_szCE,
         sat_szCQ,
         $dKnownNat1_szBt,
         $dKnownNat_szB9,
         sat_szD4,
         sat_szDg) } in
    (CLaSH.Sized.Fixed.satN2 @ rep_XuIM @ size_XuIO sat_szDh sat_szDD)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIK>_P <rep_XuIM>_R) <size_XuIO>_N
            :: rep_XuIM size_XuIO
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIK rep_XuIM size_XuIO)

CLaSH.Sized.Fixed.$fNumFixed_$c-
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$c- =
  \ (@ (frac_XuIL :: GHC.TypeLits.Nat))
    (@ (rep_XuIN :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIP :: GHC.TypeLits.Nat))
    (tup_szDE
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIL rep_XuIN size_XuIP)
    (eta_szDF [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)
    (eta1_szDG [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP) ->
    let {
      tup1_szDH :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId, Str=DmdType]
      tup1_szDH =
        case tup_szDE
        of _ [Occ=Dead]
        { (tpl_szDJ [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szDJ
        } } in
    let {
      $dKnownNat_szDP
        :: GHC.TypeLits.KnownNat (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_szDP =
        case tup1_szDH
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szDY [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_szDY
        } } in
    let {
      tup2_szE1
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIN
             (frac_XuIL GHC.TypeLits.+ frac_XuIL)
             frac_XuIL
             (size_XuIP GHC.TypeLits.+ size_XuIP)
             size_XuIP
      [LclId, Str=DmdType]
      tup2_szE1 =
        case tup_szDE
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_szE4 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_szE4
        } } in
    let {
      $dKnownNat1_szE9 :: GHC.TypeLits.KnownNat size_XuIP
      [LclId, Str=DmdType]
      $dKnownNat1_szE9 =
        case tup2_szE1
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szEh [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_szEh
        } } in
    let {
      sat_szGx [Occ=Once] :: rep_XuIN (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szGx =
        case tup_szDE
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_szG2 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        let {
          sat_szGw [Occ=Once] :: rep_XuIN (size_XuIP GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_szGw =
            case tup2_szE1
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_szGp [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_szGp
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                     :: CLaSH.Class.Num.Resize rep_XuIN
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
              @ size_XuIP
              @ (size_XuIP GHC.TypeLits.+ 2)
              $dKnownNat1_szE9
              $dKnownNat_szDP
              (eta1_szDG
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                            ~#
                          rep_XuIN size_XuIP))
            } } in
        let {
          sat_szGi [Occ=Once] :: rep_XuIN (size_XuIP GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_szGi =
            case tup2_szE1
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_szGb [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_szGb
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIN>_N
                     :: CLaSH.Class.Num.Resize rep_XuIN
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIN a_ae8M -> rep_XuIN b_ae8N)))
              @ size_XuIP
              @ (size_XuIP GHC.TypeLits.+ 2)
              $dKnownNat1_szE9
              $dKnownNat_szDP
              (eta_szDF
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIL>_P <rep_XuIN>_R <size_XuIP>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP
                            ~#
                          rep_XuIN size_XuIP))
            } } in
        GHC.Num.-
          @ (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
          tpl3_szG2
          sat_szGi
          sat_szGw
        } } in
    let {
      sat_szFW [Occ=Once]
        :: Data.Bits.Bits (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_szFW =
        case tup1_szDH
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_szFV [Occ=Once]) ->
        tpl9_szFV
        } } in
    let {
      sat_szFK [Occ=Once] :: GHC.Enum.Bounded (rep_XuIN size_XuIP)
      [LclId, Str=DmdType]
      sat_szFK =
        case tup2_szE1
        of _ [Occ=Dead]
        { (tpl_szFy [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szFy
        } } in
    let {
      sat_szFw [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize
             (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
           ~ (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szFw =
        case tup1_szDH
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_szFr [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_szFr
        } } in
    let {
      sat_szFk [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize (rep_XuIN size_XuIP) ~ size_XuIP
      [LclId, Str=DmdType]
      sat_szFk =
        case tup1_szDH
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_szFe [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_szFe
        } } in
    let {
      sat_szF8 [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector
             (rep_XuIN (size_XuIP GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_szF8 =
        case tup1_szDH
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_szF1 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_szF1
        } } in
    let {
      sat_szEW [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector (rep_XuIN size_XuIP)
      [LclId, Str=DmdType]
      sat_szEW =
        case tup1_szDH
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_szEO [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_szEO
        } } in
    let {
      sat_szEK [Occ=Once]
        :: ((size_XuIP GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_XuIP GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szEK =
        case tup1_szDH
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_szEB [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_szEB
        } } in
    let {
      sat_szEy [Occ=Once] :: 1 GHC.TypeLits.<= size_XuIP
      [LclId, Str=DmdType]
      sat_szEy =
        case tup1_szDH
        of _ [Occ=Dead]
        { (tpl_szEo [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szEo
        } } in
    let {
      sat_szFX [Occ=Once] :: CLaSH.Sized.Fixed.SatN2C rep_XuIN size_XuIP
      [LclId, Str=DmdType]
      sat_szFX =
        (sat_szEy,
         sat_szEK,
         sat_szEW,
         sat_szF8,
         sat_szFk,
         sat_szFw,
         $dKnownNat1_szE9,
         $dKnownNat_szDP,
         sat_szFK,
         sat_szFW) } in
    (CLaSH.Sized.Fixed.satN2 @ rep_XuIN @ size_XuIP sat_szFX sat_szGx)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIL>_P <rep_XuIN>_R) <size_XuIP>_N
            :: rep_XuIN size_XuIP
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIL rep_XuIN size_XuIP)

CLaSH.Sized.Fixed.$fNumFixed_$c*
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$c* =
  \ (@ (frac_XuIM :: GHC.TypeLits.Nat))
    (@ (rep_XuIO :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIQ :: GHC.TypeLits.Nat))
    (tup_szGy
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIM rep_XuIO size_XuIQ)
    (eta_szGz [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ)
    (eta1_szGA [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ) ->
    let {
      tup1_szGB
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId, Str=DmdType]
      tup1_szGB =
        case tup_szGy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_szGE [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_szGE
        } } in
    let {
      $dBits_szGJ
        :: Data.Bits.Bits (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      $dBits_szGJ =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_szGP [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_szGP
        } } in
    let {
      sat_szJn [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             rep_XuIO
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      [LclId, Str=DmdType]
      sat_szJn =
        case tup_szGy
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_szJk [Occ=Once], tpl5_szJl [Occ=Once!]) ->
        case tpl5_szJl of _ [Occ=Dead] { GHC.Types.Eq# cobox1_dw1a ->
        ((tpl4_szJk
          `cast` (CLaSH.Class.Num.NTCo:Mult[0]
                    <rep_XuIO size_XuIQ>_N <rep_XuIO size_XuIQ>_N
                  :: CLaSH.Class.Num.Mult (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                       ~#
                     (rep_XuIO size_XuIQ
                      -> rep_XuIO size_XuIQ
                      -> CLaSH.Class.Num.MResult
                           (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ))))
           (eta_szGz
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ))
           (eta1_szGA
            `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                      <frac_XuIM>_P <rep_XuIO>_R <size_XuIQ>_N
                    :: CLaSH.Sized.Fixed.Fixed frac_XuIM rep_XuIO size_XuIQ
                         ~#
                       rep_XuIO size_XuIQ)))
        `cast` (Sub cobox1_dw1a
                ; Sym
                    (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                       <frac_XuIM GHC.TypeLits.+ frac_XuIM>_P <rep_XuIO>_R) <size_XuIQ
                                                                             GHC.TypeLits.+ size_XuIQ>_N
                :: CLaSH.Class.Num.MResult
                     (rep_XuIO size_XuIQ) (rep_XuIO size_XuIQ)
                     ~#
                   CLaSH.Sized.Fixed.Fixed
                     (frac_XuIM GHC.TypeLits.+ frac_XuIM)
                     rep_XuIO
                     (size_XuIQ GHC.TypeLits.+ size_XuIQ))
        }
        } } in
    let {
      sat_szJd [Occ=Once]
        :: GHC.Enum.Bounded (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      sat_szJd =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_szJc [Occ=Once]) ->
        tpl11_szJc
        } } in
    let {
      sat_szIZ [Occ=Once]
        :: GHC.TypeLits.KnownNat (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      [LclId, Str=DmdType]
      sat_szIZ =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl10_szIX [Occ=Once], _ [Occ=Dead]) ->
        tpl10_szIX
        } } in
    let {
      sat_szIL [Occ=Once] :: GHC.TypeLits.KnownNat frac_XuIM
      [LclId, Str=DmdType]
      sat_szIL =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_szII [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl9_szII
        } } in
    let {
      sat_szIx [Occ=Once] :: Data.Bits.Bits (rep_XuIO size_XuIQ)
      [LclId, Str=DmdType]
      sat_szIx =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl8_szIt [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl8_szIt
        } } in
    let {
      sat_szIj [Occ=Once]
        :: GHC.TypeLits.KnownNat (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      [LclId, Str=DmdType]
      sat_szIj =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szIe [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_szIe
        } } in
    let {
      sat_szI5 [Occ=Once] :: GHC.TypeLits.KnownNat size_XuIQ
      [LclId, Str=DmdType]
      sat_szI5 =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szHZ [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_szHZ
        } } in
    let {
      sat_szHR [Occ=Once] :: CLaSH.Class.Num.Resize rep_XuIO
      [LclId, Str=DmdType]
      sat_szHR =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_szHK [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_szHK
        } } in
    let {
      sat_szHD [Occ=Once]
        :: GHC.Num.Num (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      sat_szHD =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_szHu [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_szHu
        } } in
    let {
      sat_szHp [Occ=Once]
        :: GHC.Classes.Ord (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      sat_szHp =
        case tup1_szGB
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_szHf [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_szHf
        } } in
    let {
      sat_szHb [Occ=Once]
        :: GHC.Classes.Eq (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ))
      [LclId, Str=DmdType]
      sat_szHb =
        Data.Bits.$p1Bits
          @ (rep_XuIO (size_XuIQ GHC.TypeLits.+ size_XuIQ)) $dBits_szGJ } in
    let {
      sat_szHa [Occ=Once] :: GHC.Enum.Bounded (rep_XuIO size_XuIQ)
      [LclId, Str=DmdType]
      sat_szHa =
        case tup1_szGB
        of _ [Occ=Dead]
        { (tpl_szGY [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szGY
        } } in
    let {
      sat_szJe [Occ=Once]
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIO
             (frac_XuIM GHC.TypeLits.+ frac_XuIM)
             frac_XuIM
             (size_XuIQ GHC.TypeLits.+ size_XuIQ)
             size_XuIQ
      [LclId, Str=DmdType]
      sat_szJe =
        (sat_szHa,
         sat_szHb,
         sat_szHp,
         sat_szHD,
         $dBits_szGJ,
         sat_szHR,
         sat_szI5,
         sat_szIj,
         sat_szIx,
         sat_szIL,
         sat_szIZ,
         sat_szJd) } in
    CLaSH.Sized.Fixed.resizeF
      @ (frac_XuIM GHC.TypeLits.+ frac_XuIM)
      @ frac_XuIM
      @ rep_XuIO
      @ (size_XuIQ GHC.TypeLits.+ size_XuIQ)
      @ size_XuIQ
      sat_szJe
      sat_szJn

CLaSH.Sized.Fixed.$fNumFixed_$c+
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
     -> CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0
[GblId, Arity=3, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed_$c+ =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    (tup_szJo
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIN rep_XuIP size_XuIR)
    (eta_szJp [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
    (eta1_szJq [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
    let {
      tup1_szJr :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      tup1_szJr =
        case tup_szJo
        of _ [Occ=Dead]
        { (tpl_szJt [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szJt
        } } in
    let {
      $dKnownNat_szJz
        :: GHC.TypeLits.KnownNat (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      $dKnownNat_szJz =
        case tup1_szJr
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl7_szJI [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl7_szJI
        } } in
    let {
      tup2_szJL
        :: CLaSH.Sized.Fixed.ResizeFC
             rep_XuIP
             (frac_XuIN GHC.TypeLits.+ frac_XuIN)
             frac_XuIN
             (size_XuIR GHC.TypeLits.+ size_XuIR)
             size_XuIR
      [LclId, Str=DmdType]
      tup2_szJL =
        case tup_szJo
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_szJO [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_szJO
        } } in
    let {
      $dKnownNat1_szJT :: GHC.TypeLits.KnownNat size_XuIR
      [LclId, Str=DmdType]
      $dKnownNat1_szJT =
        case tup2_szJL
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl6_szK1 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl6_szK1
        } } in
    let {
      sat_szMh [Occ=Once] :: rep_XuIP (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szMh =
        case tup_szJo
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_szLM [Occ=Once], _ [Occ=Dead], _ [Occ=Dead]) ->
        let {
          sat_szMg [Occ=Once] :: rep_XuIP (size_XuIR GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_szMg =
            case tup2_szJL
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_szM9 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_szM9
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                     :: CLaSH.Class.Num.Resize rep_XuIP
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
              @ size_XuIR
              @ (size_XuIR GHC.TypeLits.+ 2)
              $dKnownNat1_szJT
              $dKnownNat_szJz
              (eta1_szJq
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                            ~#
                          rep_XuIP size_XuIR))
            } } in
        let {
          sat_szM2 [Occ=Once] :: rep_XuIP (size_XuIR GHC.TypeLits.+ 2)
          [LclId, Str=DmdType]
          sat_szM2 =
            case tup2_szJL
            of _ [Occ=Dead]
            { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl11_szLV [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
            (tpl11_szLV
             `cast` (CLaSH.Class.Num.NTCo:Resize[0] <rep_XuIP>_N
                     :: CLaSH.Class.Num.Resize rep_XuIP
                          ~#
                        (forall (a_ae8M :: GHC.TypeLits.Nat) (b_ae8N :: GHC.TypeLits.Nat).
                         (GHC.TypeLits.KnownNat a_ae8M, GHC.TypeLits.KnownNat b_ae8N) =>
                         rep_XuIP a_ae8M -> rep_XuIP b_ae8N)))
              @ size_XuIR
              @ (size_XuIR GHC.TypeLits.+ 2)
              $dKnownNat1_szJT
              $dKnownNat_szJz
              (eta_szJp
               `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                         <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                       :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                            ~#
                          rep_XuIP size_XuIR))
            } } in
        GHC.Num.+
          @ (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
          tpl3_szLM
          sat_szM2
          sat_szMg
        } } in
    let {
      sat_szLG [Occ=Once]
        :: Data.Bits.Bits (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_szLG =
        case tup1_szJr
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl9_szLF [Occ=Once]) ->
        tpl9_szLF
        } } in
    let {
      sat_szLu [Occ=Once] :: GHC.Enum.Bounded (rep_XuIP size_XuIR)
      [LclId, Str=DmdType]
      sat_szLu =
        case tup2_szJL
        of _ [Occ=Dead]
        { (tpl_szLi [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szLi
        } } in
    let {
      sat_szLg [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize
             (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
           ~ (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szLg =
        case tup1_szJr
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl5_szLb [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl5_szLb
        } } in
    let {
      sat_szL4 [Occ=Once]
        :: CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR) ~ size_XuIR
      [LclId, Str=DmdType]
      sat_szL4 =
        case tup1_szJr
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl4_szKY [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl4_szKY
        } } in
    let {
      sat_szKS [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector
             (rep_XuIP (size_XuIR GHC.TypeLits.+ 2))
      [LclId, Str=DmdType]
      sat_szKS =
        case tup1_szJr
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], tpl3_szKL [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl3_szKL
        } } in
    let {
      sat_szKG [Occ=Once]
        :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)
      [LclId, Str=DmdType]
      sat_szKG =
        case tup1_szJr
        of _ [Occ=Dead]
        { (_ [Occ=Dead], _ [Occ=Dead], tpl2_szKy [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl2_szKy
        } } in
    let {
      sat_szKu [Occ=Once]
        :: ((size_XuIR GHC.TypeLits.+ 1) GHC.TypeLits.+ 1)
           ~ (size_XuIR GHC.TypeLits.+ 2)
      [LclId, Str=DmdType]
      sat_szKu =
        case tup1_szJr
        of _ [Occ=Dead]
        { (_ [Occ=Dead], tpl1_szKl [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl1_szKl
        } } in
    let {
      sat_szKi [Occ=Once] :: 1 GHC.TypeLits.<= size_XuIR
      [LclId, Str=DmdType]
      sat_szKi =
        case tup1_szJr
        of _ [Occ=Dead]
        { (tpl_szK8 [Occ=Once], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead], _ [Occ=Dead]) ->
        tpl_szK8
        } } in
    let {
      sat_szLH [Occ=Once] :: CLaSH.Sized.Fixed.SatN2C rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      sat_szLH =
        (sat_szKi,
         sat_szKu,
         sat_szKG,
         sat_szKS,
         sat_szL4,
         sat_szLg,
         $dKnownNat1_szJT,
         $dKnownNat_szJz,
         sat_szLu,
         sat_szLG) } in
    (CLaSH.Sized.Fixed.satN2 @ rep_XuIP @ size_XuIR sat_szLH sat_szMh)
    `cast` (Sym
              (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                 <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
            :: rep_XuIP size_XuIR
                 ~#
               CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)

CLaSH.Sized.Fixed.$fNumFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGY :: GHC.TypeLits.Nat)
            (rep_auGZ :: GHC.TypeLits.Nat -> *)
            (size_auH0 :: GHC.TypeLits.Nat).
     (CLaSH.Sized.Fixed.NumFixed frac_auGY rep_auGZ size_auH0) =>
     GHC.Num.Num (CLaSH.Sized.Fixed.Fixed frac_auGY rep_auGZ size_auH0)
[GblId[DFunId], Arity=1, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fNumFixed =
  \ (@ (frac_XuIO :: GHC.TypeLits.Nat))
    (@ (rep_XuIQ :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIS :: GHC.TypeLits.Nat))
    (tup_szMi
       :: CLaSH.Sized.Fixed.NumFixed frac_XuIO rep_XuIQ size_XuIS) ->
    let {
      sat_szMp [Occ=Once]
        :: GHC.Integer.Type.Integer
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_szMp =
        \ (eta_B1 [Occ=Once] :: GHC.Integer.Type.Integer) ->
          CLaSH.Sized.Fixed.$fNumFixed_$cfromInteger
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_szMi eta_B1 } in
    let {
      sat_szMo [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_szMo =
        (\ (eta_B1 [Occ=Once]
              :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
           CLaSH.Sized.Fixed.$fNumFixed1
             @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_szMi eta_B1)
        `cast` (<CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS>_R
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIO>_P <rep_XuIQ>_R) <size_XuIS>_N
                :: (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                    -> rep_XuIQ size_XuIS)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)) } in
    let {
      sat_szMn [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_szMn =
        \ (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$cabs
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_szMi eta_B1 } in
    let {
      sat_szMm [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_szMm =
        \ (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$cnegate
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_szMi eta_B1 } in
    let {
      sat_szMl [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_szMl =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$c-
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_szMi eta_B2 eta_B1 } in
    let {
      sat_szMk [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_szMk =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$c*
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_szMi eta_B2 eta_B1 } in
    let {
      sat_szMj [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
           -> CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS
      [LclId, Str=DmdType]
      sat_szMj =
        \ (eta_B2 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
          (eta_B1 [Occ=Once]
             :: CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS) ->
          CLaSH.Sized.Fixed.$fNumFixed_$c+
            @ frac_XuIO @ rep_XuIQ @ size_XuIS tup_szMi eta_B2 eta_B1 } in
    GHC.Num.D:Num
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIO rep_XuIQ size_XuIS)
      sat_szMj
      sat_szMk
      sat_szMl
      sat_szMm
      sat_szMn
      sat_szMo
      sat_szMp

CLaSH.Sized.Fixed.$fBitVectorFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGT :: GHC.TypeLits.Nat)
            (rep_auGU :: GHC.TypeLits.Nat -> *)
            (size_auGV :: GHC.TypeLits.Nat).
     CLaSH.Class.BitVector.BitVector (rep_auGU size_auGV) =>
     CLaSH.Class.BitVector.BitVector
       (CLaSH.Sized.Fixed.Fixed frac_auGT rep_auGU size_auGV)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fBitVectorFixed =
  \ (@ (frac_XuIN :: GHC.TypeLits.Nat))
    (@ (rep_XuIP :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIR :: GHC.TypeLits.Nat))
    ($dBitVector_szMq
       :: CLaSH.Class.BitVector.BitVector (rep_XuIP size_XuIR)) ->
    let {
      lvl1_szMr [Occ=OnceL!]
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
           -> rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      lvl1_szMr =
        CLaSH.Class.BitVector.fromBV
          @ (rep_XuIP size_XuIR) $dBitVector_szMq } in
    let {
      lvl2_szMs [Occ=OnceL!]
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) =>
           rep_XuIP size_XuIR
           -> CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      lvl2_szMs =
        CLaSH.Class.BitVector.toBV
          @ (rep_XuIP size_XuIR) $dBitVector_szMq } in
    let {
      sat_szMy [Occ=Once]
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize
                (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Vector.Vec
             (CLaSH.Class.BitVector.BitSize
                (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
             CLaSH.Bit.Bit
           -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
      [LclId, Str=DmdType]
      sat_szMy =
        (\ ($dKnownNat_szMw [Occ=Once]
              :: GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
           (bv_szMx [Occ=Once]
              :: CLaSH.Sized.Vector.Vec
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                   CLaSH.Bit.Bit) ->
           lvl1_szMr
             ($dKnownNat_szMw
              `cast` ((GHC.TypeLits.KnownNat
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                      :: GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize
                              (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                           ~#
                         GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
             (bv_szMx
              `cast` ((CLaSH.Sized.Vector.Vec
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N)
                         <CLaSH.Bit.Bit>_R)_R
                      :: CLaSH.Sized.Vector.Vec
                           (CLaSH.Class.BitVector.BitSize
                              (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                           CLaSH.Bit.Bit
                           ~#
                         CLaSH.Sized.Vector.Vec
                           (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))
                           CLaSH.Bit.Bit)))
        `cast` (<GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
                -> <CLaSH.Sized.Vector.Vec
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                      CLaSH.Bit.Bit>_R
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R) <size_XuIR>_N
                :: (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Vector.Vec
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                      CLaSH.Bit.Bit
                    -> rep_XuIP size_XuIR)
                     ~#
                   (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Vector.Vec
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                      CLaSH.Bit.Bit
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) } in
    let {
      sat_szMv [Occ=Once]
        :: GHC.TypeLits.KnownNat
             (CLaSH.Class.BitVector.BitSize
                (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
           CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
           -> CLaSH.Sized.Vector.Vec
                (CLaSH.Class.BitVector.BitSize
                   (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                CLaSH.Bit.Bit
      [LclId, Str=DmdType]
      sat_szMv =
        (\ ($dKnownNat_szMt [Occ=Once]
              :: GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)))
           (ds_szMu [Occ=Once]
              :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR) ->
           lvl2_szMs
             ($dKnownNat_szMt
              `cast` ((GHC.TypeLits.KnownNat
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))_R
                      :: GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize
                              (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                           ~#
                         GHC.TypeLits.KnownNat
                           (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR))))
             (ds_szMu
              `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIN>_P <rep_XuIP>_R <size_XuIR>_N
                      :: CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                           ~#
                         rep_XuIP size_XuIR)))
        `cast` (<GHC.TypeLits.KnownNat
                   (CLaSH.Class.BitVector.BitSize
                      (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))>_R
                -> <CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR>_R
                -> (CLaSH.Sized.Vector.Vec
                      (Sym
                         (CLaSH.Sized.Fixed.TFCo:R:BitSizeFixed[0]
                            <frac_XuIN>_N <rep_XuIP>_N <size_XuIR>_N))
                      <CLaSH.Bit.Bit>_R)_R
                :: (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                    -> CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize (rep_XuIP size_XuIR)) CLaSH.Bit.Bit)
                     ~#
                   (GHC.TypeLits.KnownNat
                      (CLaSH.Class.BitVector.BitSize
                         (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)) =>
                    CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR
                    -> CLaSH.Sized.Vector.Vec
                         (CLaSH.Class.BitVector.BitSize
                            (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR))
                         CLaSH.Bit.Bit)) } in
    CLaSH.Class.BitVector.D:BitVector
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIN rep_XuIP size_XuIR)
      sat_szMv
      sat_szMy

CLaSH.Sized.Fixed.$fDefaultFixed1
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default (rep_auGM size_auGN)
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fDefaultFixed1 =
  \ (@ (frac_auGL :: GHC.TypeLits.Nat))
    (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
    (@ (size_auGN :: GHC.TypeLits.Nat))
    ($dDefault_szMz [Occ=Once]
       :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
    $dDefault_szMz

CLaSH.Sized.Fixed.$fDefaultFixed_$cdef
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN
[GblId, Arity=1, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fDefaultFixed_$cdef =
  (\ (@ (frac_auGL :: GHC.TypeLits.Nat))
     (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
     (@ (size_auGN :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
     CLaSH.Sized.Fixed.$fDefaultFixed1
       @ frac_auGL @ rep_auGM @ size_auGN eta_B1)
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1))

CLaSH.Sized.Fixed.$fDefaultFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGL :: GHC.TypeLits.Nat)
            (rep_auGM :: GHC.TypeLits.Nat -> *)
            (size_auGN :: GHC.TypeLits.Nat).
     Data.Default.Class.Default (rep_auGM size_auGN) =>
     Data.Default.Class.Default
       (CLaSH.Sized.Fixed.Fixed frac_auGL rep_auGM size_auGN)
[GblId[DFunId(nt)],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fDefaultFixed =
  (\ (@ (frac_auGL :: GHC.TypeLits.Nat))
     (@ (rep_auGM :: GHC.TypeLits.Nat -> *))
     (@ (size_auGN :: GHC.TypeLits.Nat))
     (eta_B1 [Occ=Once]
        :: Data.Default.Class.Default (rep_auGM size_auGN)) ->
     CLaSH.Sized.Fixed.$fDefaultFixed1
       @ frac_auGL @ rep_auGM @ size_auGN eta_B1)
  `cast` (forall (frac_XuLX :: GHC.TypeLits.Nat)
                 (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                 (size_XuM1 :: GHC.TypeLits.Nat).
          <Data.Default.Class.Default (rep_XuLZ size_XuM1)>_R
          -> Data.Default.Class.NTCo:Default[0] <rep_XuLZ size_XuM1>_N
             ; Sym
                 (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                    <frac_XuLX>_P <rep_XuLZ>_R) <size_XuM1>_N
             ; Sym
                 (Data.Default.Class.NTCo:Default[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1>_N)
          :: (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default (rep_XuLZ size_XuM1))
               ~#
             (forall (frac_XuLX :: GHC.TypeLits.Nat)
                     (rep_XuLZ :: GHC.TypeLits.Nat -> *)
                     (size_XuM1 :: GHC.TypeLits.Nat).
              Data.Default.Class.Default (rep_XuLZ size_XuM1) =>
              Data.Default.Class.Default
                (CLaSH.Sized.Fixed.Fixed frac_XuLX rep_XuLZ size_XuM1)))

CLaSH.Sized.Fixed.$fBoundedFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auGI :: GHC.TypeLits.Nat)
            (rep_auGJ :: GHC.TypeLits.Nat -> *)
            (size_auGK :: GHC.TypeLits.Nat).
     GHC.Enum.Bounded (rep_auGJ size_auGK) =>
     GHC.Enum.Bounded
       (CLaSH.Sized.Fixed.Fixed frac_auGI rep_auGJ size_auGK)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fBoundedFixed =
  \ (@ (frac_XuIW :: GHC.TypeLits.Nat))
    (@ (rep_XuIY :: GHC.TypeLits.Nat -> *))
    (@ (size_XuJ0 :: GHC.TypeLits.Nat))
    ($dBounded_szMA :: GHC.Enum.Bounded (rep_XuIY size_XuJ0)) ->
    let {
      sat_szMC [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0
      [LclId, Str=DmdType]
      sat_szMC =
        (GHC.Enum.maxBound @ (rep_XuIY size_XuJ0) $dBounded_szMA)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                :: rep_XuIY size_XuJ0
                     ~#
                   CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0) } in
    let {
      sat_szMB [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0
      [LclId, Str=DmdType]
      sat_szMB =
        (GHC.Enum.minBound @ (rep_XuIY size_XuJ0) $dBounded_szMA)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIW>_P <rep_XuIY>_R) <size_XuJ0>_N
                :: rep_XuIY size_XuJ0
                     ~#
                   CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0) } in
    GHC.Enum.D:Bounded
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIW rep_XuIY size_XuJ0)
      sat_szMB
      sat_szMC

CLaSH.Sized.Fixed.$fOrdFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     (GHC.Classes.Eq
        (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH),
      GHC.Classes.Ord (rep_auFG size_auFH)) =>
     GHC.Classes.Ord
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[GblId[DFunId[1]],
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fOrdFixed =
  \ (@ (frac_XuIv :: GHC.TypeLits.Nat))
    (@ (rep_XuIx :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIz :: GHC.TypeLits.Nat))
    ($dEq_szMD [Occ=Once]
       :: GHC.Classes.Eq
            (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz))
    ($dOrd_szME :: GHC.Classes.Ord (rep_XuIx size_XuIz)) ->
    let {
      sat_szML [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
      [LclId, Str=DmdType]
      sat_szML =
        (GHC.Classes.min @ (rep_XuIx size_XuIz) $dOrd_szME)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)) } in
    let {
      sat_szMK [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
      [LclId, Str=DmdType]
      sat_szMK =
        (GHC.Classes.max @ (rep_XuIx size_XuIz) $dOrd_szME)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> rep_XuIx size_XuIz)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)) } in
    let {
      sat_szMJ [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_szMJ =
        (GHC.Classes.<= @ (rep_XuIx size_XuIz) $dOrd_szME)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Bool)) } in
    let {
      sat_szMI [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_szMI =
        (GHC.Classes.> @ (rep_XuIx size_XuIz) $dOrd_szME)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Bool)) } in
    let {
      sat_szMH [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_szMH =
        (GHC.Classes.>= @ (rep_XuIx size_XuIz) $dOrd_szME)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Bool)) } in
    let {
      sat_szMG [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_szMG =
        (GHC.Classes.< @ (rep_XuIx size_XuIz) $dOrd_szME)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Bool)) } in
    let {
      sat_szMF [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
           -> GHC.Types.Ordering
      [LclId, Str=DmdType]
      sat_szMF =
        (GHC.Classes.compare @ (rep_XuIx size_XuIz) $dOrd_szME)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuIv>_P <rep_XuIx>_R) <size_XuIz>_N
                -> <GHC.Types.Ordering>_R
                :: (rep_XuIx size_XuIz -> rep_XuIx size_XuIz -> GHC.Types.Ordering)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz
                    -> GHC.Types.Ordering)) } in
    GHC.Classes.D:Ord
      @ (CLaSH.Sized.Fixed.Fixed frac_XuIv rep_XuIx size_XuIz)
      $dEq_szMD
      sat_szMF
      sat_szMG
      sat_szMH
      sat_szMI
      sat_szMJ
      sat_szMK
      sat_szML

CLaSH.Sized.Fixed.$fEqFixed [InlPrag=[ALWAYS] CONLIKE]
  :: forall (frac_auFF :: GHC.TypeLits.Nat)
            (rep_auFG :: GHC.TypeLits.Nat -> *)
            (size_auFH :: GHC.TypeLits.Nat).
     GHC.Classes.Eq (rep_auFG size_auFH) =>
     GHC.Classes.Eq
       (CLaSH.Sized.Fixed.Fixed frac_auFF rep_auFG size_auFH)
[GblId[DFunId],
 Arity=1,
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fEqFixed =
  \ (@ (frac_XuII :: GHC.TypeLits.Nat))
    (@ (rep_XuIK :: GHC.TypeLits.Nat -> *))
    (@ (size_XuIM :: GHC.TypeLits.Nat))
    ($dEq_szMM :: GHC.Classes.Eq (rep_XuIK size_XuIM)) ->
    let {
      sat_szMO [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
           -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_szMO =
        (GHC.Classes./= @ (rep_XuIK size_XuIM) $dEq_szMM)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                    -> GHC.Types.Bool)) } in
    let {
      sat_szMN [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
           -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
           -> GHC.Types.Bool
      [LclId, Str=DmdType]
      sat_szMN =
        (GHC.Classes.== @ (rep_XuIK size_XuIM) $dEq_szMM)
        `cast` (Sym
                  (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                -> Sym
                     (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                        <frac_XuII>_P <rep_XuIK>_R) <size_XuIM>_N
                -> <GHC.Types.Bool>_R
                :: (rep_XuIK size_XuIM -> rep_XuIK size_XuIM -> GHC.Types.Bool)
                     ~#
                   (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                    -> CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM
                    -> GHC.Types.Bool)) } in
    GHC.Classes.D:Eq
      @ (CLaSH.Sized.Fixed.Fixed frac_XuII rep_XuIK size_XuIM)
      sat_szMN
      sat_szMO

CLaSH.Sized.Fixed.$fLiftFixed12
  :: Language.Haskell.TH.Syntax.NameFlavour
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed12 =
  Language.Haskell.TH.Syntax.NameG
    Language.Haskell.TH.Syntax.TcClsName
    (CLaSH.Sized.Fixed.$fLiftFixed6
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:PkgName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.PkgName))
    (CLaSH.Sized.Fixed.$fLiftFixed5
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:ModName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.ModName))

CLaSH.Sized.Fixed.$fLiftFixed11 :: Language.Haskell.TH.Syntax.Name
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed11 =
  Language.Haskell.TH.Syntax.Name
    (CLaSH.Sized.Fixed.$fLiftFixed7
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    CLaSH.Sized.Fixed.$fLiftFixed12

CLaSH.Sized.Fixed.$fLiftFixed10 :: Language.Haskell.TH.Syntax.Type
[GblId, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed10 =
  Language.Haskell.TH.Syntax.ConT CLaSH.Sized.Fixed.$fLiftFixed11

CLaSH.Sized.Fixed.$fLiftFixed9
  :: forall (m_a4Ni :: * -> *).
     Language.Haskell.TH.Syntax.Quasi m_a4Ni =>
     m_a4Ni Language.Haskell.TH.Syntax.Type
[GblId, Arity=1, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed9 =
  \ (@ (m_a4Ni :: * -> *))
    (eta_szMP [Occ=Once] :: Language.Haskell.TH.Syntax.Quasi m_a4Ni) ->
    case Language.Haskell.TH.Syntax.$p1Quasi @ m_a4Ni eta_szMP
    of sat_szMQ { __DEFAULT ->
    GHC.Base.return
      @ m_a4Ni
      sat_szMQ
      @ Language.Haskell.TH.Syntax.Type
      CLaSH.Sized.Fixed.$fLiftFixed10
    }

Rec {
CLaSH.Sized.Fixed.$fLiftFixed_lgo [Occ=LoopBreaker]
  :: Language.Haskell.TH.Lib.TypeQ
     -> [Language.Haskell.TH.Lib.TypeQ] -> Language.Haskell.TH.Lib.TypeQ
[GblId,
 Arity=2,
 Caf=NoCafRefs,
 Str=DmdType <L,U><S,1*U>,
 Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed_lgo =
  \ (z_szMR [Occ=OnceL*] :: Language.Haskell.TH.Lib.TypeQ)
    (ds_szMS [Occ=Once!] :: [Language.Haskell.TH.Lib.TypeQ]) ->
    case ds_szMS of _ [Occ=Dead] {
      [] -> z_szMR;
      : x_szMU [Occ=OnceL] xs_szMV [Occ=Once] ->
        let {
          sat_szMW [Occ=Once] :: Language.Haskell.TH.Lib.TypeQ
          [LclId, Str=DmdType]
          sat_szMW =
            (\ (@ (m_a4Jw :: * -> *))
               (eta_B1 [Occ=Once] :: Language.Haskell.TH.Syntax.Quasi m_a4Jw) ->
               Language.Haskell.TH.Lib.appT1 z_szMR x_szMU @ m_a4Jw eta_B1)
            `cast` (Sym
                      (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N)
                    :: (forall (m_a4LE :: * -> *).
                        Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                        m_a4LE Language.Haskell.TH.Syntax.Type)
                         ~#
                       Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type) } in
        CLaSH.Sized.Fixed.$fLiftFixed_lgo sat_szMW xs_szMV
    }
end Rec }

CLaSH.Sized.Fixed.$fLiftFixed8 :: Language.Haskell.TH.Syntax.Name
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed8 =
  Language.Haskell.TH.Syntax.Name
    ((GHC.Types.[] @ GHC.Types.Char)
     `cast` (Sym Language.Haskell.TH.Syntax.NTCo:OccName[0]
             :: GHC.Base.String ~# Language.Haskell.TH.Syntax.OccName))
    Language.Haskell.TH.Syntax.NameS

CLaSH.Sized.Fixed.$fLiftFixed1
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> forall (m_akMz :: * -> *).
        Language.Haskell.TH.Syntax.Quasi m_akMz =>
        m_akMz Language.Haskell.TH.Syntax.Exp
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed1 =
  \ (@ (frac_auGO :: GHC.TypeLits.Nat))
    (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
    (@ (size_auGQ :: GHC.TypeLits.Nat))
    ($dLift_szMX
       :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
    ($dKnownNat_szMY [Occ=Once] :: GHC.TypeLits.KnownNat frac_auGO)
    ($dKnownNat1_szMZ [Occ=Once] :: GHC.TypeLits.KnownNat size_auGQ)
    ($dTypeable_szN0 [Occ=Once]
       :: Data.Typeable.Internal.Typeable rep_auGP)
    (f_szN1 [Occ=Once]
       :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
    let {
      w1_szN2 :: Language.Haskell.TH.Lib.TypeQ
      [LclId, Str=DmdType]
      w1_szN2 =
        let {
          l_szNw :: Language.Haskell.TH.Lib.TyLitQ
          [LclId, Str=DmdType]
          l_szNw =
            Language.Haskell.TH.Lib.numTyLit
              ($dKnownNat1_szMZ
               `cast` (GHC.TypeLits.NTCo:KnownNat[0] <size_auGQ>_N
                       ; GHC.TypeLits.NTCo:SNat[0] <size_auGQ>_P
                       :: GHC.TypeLits.KnownNat size_auGQ
                            ~#
                          GHC.Integer.Type.Integer)) } in
        let {
          sat_szNB :: Language.Haskell.TH.Lib.TypeQ
          [LclId, Str=DmdType]
          sat_szNB =
            (\ (@ (m_a5E0 :: * -> *))
               (eta_szNx :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
               let {
                 sat_szNA [Occ=Once] :: m_a5E0 Language.Haskell.TH.Syntax.TyLit
                 [LclId, Str=DmdType]
                 sat_szNA =
                   (l_szNw
                    `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.TyLit>_N
                            :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                 ~#
                               (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                     @ m_a5E0 eta_szNx } in
               case Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_szNx
               of sat_szNy { __DEFAULT ->
               case Control.Applicative.$p1Applicative @ m_a5E0 sat_szNy
               of sat_szNz { __DEFAULT ->
               GHC.Base.fmap
                 @ m_a5E0
                 sat_szNz
                 @ Language.Haskell.TH.Syntax.TyLit
                 @ Language.Haskell.TH.Syntax.Type
                 Language.Haskell.TH.Syntax.LitT
                 sat_szNA
               }
               })
            `cast` (Sym
                      (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N)
                    :: (forall (m_a4LE :: * -> *).
                        Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                        m_a4LE Language.Haskell.TH.Syntax.Type)
                         ~#
                       Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type) } in
        let {
          sat_szNC :: [Language.Haskell.TH.Lib.TypeQ]
          [LclId, Str=DmdType]
          sat_szNC =
            GHC.Types.:
              @ Language.Haskell.TH.Lib.TypeQ
              sat_szNB
              (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ) } in
        let {
          x_szN9 :: Language.Haskell.TH.Syntax.Name
          [LclId, Str=DmdType]
          x_szN9 =
            case ($dTypeable_szN0
                  `cast` (Data.Typeable.Internal.NTCo:Typeable[0]
                            <GHC.TypeLits.Nat -> *>_N <rep_auGP>_N
                          :: Data.Typeable.Internal.Typeable rep_auGP
                               ~#
                             (GHC.Prim.Proxy# rep_auGP -> Data.Typeable.Internal.TypeRep)))
                   (GHC.Prim.proxy# @ (GHC.TypeLits.Nat -> *) @ rep_auGP)
            of _ [Occ=Dead]
            { Data.Typeable.Internal.TypeRep _ [Occ=Dead] _ [Occ=Dead]
                                             ww3_szNd [Occ=Once] ww4_szNe [Occ=Once] ->
            case Data.Typeable.Internal.$w$cshowsPrec
                   GHC.Show.shows27 ww3_szNd ww4_szNe (GHC.Types.[] @ GHC.Types.Char)
            of sat_szNf { __DEFAULT ->
            case GHC.List.reverse1
                   @ GHC.Types.Char sat_szNf (GHC.Types.[] @ GHC.Types.Char)
            of _ [Occ=Dead] {
              [] -> CLaSH.Sized.Fixed.$fLiftFixed8;
              : ds_szNh [Occ=Once!] rev_szNi [Occ=Once*] ->
                case ds_szNh of wild22_szNj { GHC.Types.C# ds1_szNk [Occ=Once!] ->
                case ds1_szNk of _ [Occ=Dead] {
                  __DEFAULT ->
                    case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                           wild22_szNj (GHC.Types.[] @ GHC.Types.Char) rev_szNi
                    of _ [Occ=Dead] { (# ww6_szNn [Occ=Once], ww7_szNo [Occ=Once] #) ->
                    Language.Haskell.TH.Syntax.Name ww6_szNn ww7_szNo
                    };
                  '.' ->
                    case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                           wild22_szNj (GHC.Types.[] @ GHC.Types.Char) rev_szNi
                    of _ [Occ=Dead] { (# ww6_szNq [Occ=Once], ww7_szNr [Occ=Once] #) ->
                    Language.Haskell.TH.Syntax.Name ww6_szNq ww7_szNr
                    }
                }
                }
            }
            }
            } } in
        let {
          lvl1_szNs :: Language.Haskell.TH.Syntax.Type
          [LclId, Str=DmdType, Unf=OtherCon []]
          lvl1_szNs = Language.Haskell.TH.Syntax.ConT x_szN9 } in
        let {
          sat_szNv :: Language.Haskell.TH.Lib.TypeQ
          [LclId, Str=DmdType]
          sat_szNv =
            (\ (@ (m_X4Tv :: * -> *))
               (eta_szNt [Occ=Once] :: Language.Haskell.TH.Syntax.Quasi m_X4Tv) ->
               case Language.Haskell.TH.Syntax.$p1Quasi @ m_X4Tv eta_szNt
               of sat_szNu { __DEFAULT ->
               GHC.Base.return
                 @ m_X4Tv sat_szNu @ Language.Haskell.TH.Syntax.Type lvl1_szNs
               })
            `cast` (Sym
                      (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N)
                    :: (forall (m_a4LE :: * -> *).
                        Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                        m_a4LE Language.Haskell.TH.Syntax.Type)
                         ~#
                       Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type) } in
        let {
          sat_szND :: [Language.Haskell.TH.Lib.TypeQ]
          [LclId, Str=DmdType]
          sat_szND =
            GHC.Types.: @ Language.Haskell.TH.Lib.TypeQ sat_szNv sat_szNC } in
        let {
          l_szN3 :: Language.Haskell.TH.Lib.TyLitQ
          [LclId, Str=DmdType]
          l_szN3 =
            Language.Haskell.TH.Lib.numTyLit
              ($dKnownNat_szMY
               `cast` (GHC.TypeLits.NTCo:KnownNat[0] <frac_auGO>_N
                       ; GHC.TypeLits.NTCo:SNat[0] <frac_auGO>_P
                       :: GHC.TypeLits.KnownNat frac_auGO
                            ~#
                          GHC.Integer.Type.Integer)) } in
        let {
          sat_szN8 :: Language.Haskell.TH.Lib.TypeQ
          [LclId, Str=DmdType]
          sat_szN8 =
            (\ (@ (m_a5E0 :: * -> *))
               (eta_szN4 :: Language.Haskell.TH.Syntax.Quasi m_a5E0) ->
               let {
                 sat_szN7 [Occ=Once] :: m_a5E0 Language.Haskell.TH.Syntax.TyLit
                 [LclId, Str=DmdType]
                 sat_szN7 =
                   (l_szN3
                    `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                              <Language.Haskell.TH.Syntax.TyLit>_N
                            :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.TyLit
                                 ~#
                               (forall (m_a4LE :: * -> *).
                                Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                                m_a4LE Language.Haskell.TH.Syntax.TyLit)))
                     @ m_a5E0 eta_szN4 } in
               case Language.Haskell.TH.Syntax.$p2Quasi @ m_a5E0 eta_szN4
               of sat_szN5 { __DEFAULT ->
               case Control.Applicative.$p1Applicative @ m_a5E0 sat_szN5
               of sat_szN6 { __DEFAULT ->
               GHC.Base.fmap
                 @ m_a5E0
                 sat_szN6
                 @ Language.Haskell.TH.Syntax.TyLit
                 @ Language.Haskell.TH.Syntax.Type
                 Language.Haskell.TH.Syntax.LitT
                 sat_szN7
               }
               })
            `cast` (Sym
                      (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N)
                    :: (forall (m_a4LE :: * -> *).
                        Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                        m_a4LE Language.Haskell.TH.Syntax.Type)
                         ~#
                       Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type) } in
        let {
          sat_szNE [Occ=Once] :: [Language.Haskell.TH.Lib.TypeQ]
          [LclId, Str=DmdType]
          sat_szNE =
            GHC.Types.: @ Language.Haskell.TH.Lib.TypeQ sat_szN8 sat_szND } in
        CLaSH.Sized.Fixed.$fLiftFixed_lgo
          (CLaSH.Sized.Fixed.$fLiftFixed9
           `cast` (Sym
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                        <Language.Haskell.TH.Syntax.Type>_N)
                   :: (forall (m_a4LE :: * -> *).
                       Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                       m_a4LE Language.Haskell.TH.Syntax.Type)
                        ~#
                      Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type))
          sat_szNE } in
    let {
      w2_szNF :: Language.Haskell.TH.Lib.ExpQ
      [LclId, Str=DmdType]
      w2_szNF =
        ($dLift_szMX
         `cast` (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                   <rep_auGP size_auGQ>_N
                 :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)
                      ~#
                    (rep_auGP size_auGQ
                     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)))
          (f_szN1
           `cast` (CLaSH.Sized.Fixed.NTCo:Fixed[0]
                     <frac_auGO>_P <rep_auGP>_R <size_auGQ>_N
                   :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
                        ~#
                      rep_auGP size_auGQ)) } in
    let {
      sat_szOj [Occ=Once]
        :: forall (m_akV3 :: * -> *).
           Language.Haskell.TH.Syntax.Quasi m_akV3 =>
           m_akV3 Language.Haskell.TH.Syntax.Exp
      [LclId, Str=DmdType]
      sat_szOj =
        \ (@ (m_akV3 :: * -> *))
          (w3_szNG [Occ=Once!] :: Language.Haskell.TH.Syntax.Quasi m_akV3) ->
          case w3_szNG
          of ww_szNH
          { Language.Haskell.TH.Syntax.D:Quasi ww1_szNI [Occ=Once!]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead] _ [Occ=Dead]
                                               _ [Occ=Dead] ->
          case ww1_szNI
          of _ [Occ=Dead]
          { GHC.Base.D:Monad ww20_szO1 _ [Occ=Dead] ww22_szO3 _ [Occ=Dead] ->
          let {
            lvl1_szO5 [Occ=OnceL] :: m_akV3 Language.Haskell.TH.Syntax.Type
            [LclId, Str=DmdType]
            lvl1_szO5 =
              (w1_szN2
               `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                         <Language.Haskell.TH.Syntax.Type>_N
                       :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Type
                            ~#
                          (forall (m_a4LE :: * -> *).
                           Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                           m_a4LE Language.Haskell.TH.Syntax.Type)))
                @ m_akV3 ww_szNH } in
          let {
            sat_szOi [Occ=Once]
              :: Language.Haskell.TH.Syntax.Exp
                 -> m_akV3 Language.Haskell.TH.Syntax.Exp
            [LclId, Str=DmdType]
            sat_szOi =
              \ (x_szOe [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp) ->
                let {
                  sat_szOh [Occ=Once]
                    :: Language.Haskell.TH.Syntax.Type
                       -> m_akV3 Language.Haskell.TH.Syntax.Exp
                  [LclId, Str=DmdType]
                  sat_szOh =
                    \ (x1_szOf [Occ=Once] :: Language.Haskell.TH.Syntax.Type) ->
                      let {
                        sat_szOg [Occ=Once] :: Language.Haskell.TH.Syntax.Exp
                        [LclId, Str=DmdType]
                        sat_szOg = Language.Haskell.TH.Syntax.SigE x_szOe x1_szOf } in
                      ww22_szO3 @ Language.Haskell.TH.Syntax.Exp sat_szOg } in
                ww20_szO1
                  @ Language.Haskell.TH.Syntax.Type
                  @ Language.Haskell.TH.Syntax.Exp
                  lvl1_szO5
                  sat_szOh } in
          let {
            sat_szOd [Occ=Once] :: m_akV3 Language.Haskell.TH.Syntax.Exp
            [LclId, Str=DmdType]
            sat_szOd =
              let {
                lvl2_szO6 [Occ=OnceL] :: m_akV3 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                lvl2_szO6 =
                  (w2_szNF
                   `cast` (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Exp>_N
                           :: Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
                                ~#
                              (forall (m_a4LE :: * -> *).
                               Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                               m_a4LE Language.Haskell.TH.Syntax.Exp)))
                    @ m_akV3 ww_szNH } in
              let {
                sat_szOc [Occ=Once]
                  :: Language.Haskell.TH.Syntax.Exp
                     -> m_akV3 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                sat_szOc =
                  \ (x_szO8 [Occ=OnceL] :: Language.Haskell.TH.Syntax.Exp) ->
                    let {
                      sat_szOb [Occ=Once]
                        :: Language.Haskell.TH.Syntax.Exp
                           -> m_akV3 Language.Haskell.TH.Syntax.Exp
                      [LclId, Str=DmdType]
                      sat_szOb =
                        \ (x1_szO9 [Occ=Once] :: Language.Haskell.TH.Syntax.Exp) ->
                          let {
                            sat_szOa [Occ=Once] :: Language.Haskell.TH.Syntax.Exp
                            [LclId, Str=DmdType]
                            sat_szOa = Language.Haskell.TH.Syntax.AppE x_szO8 x1_szO9 } in
                          ww22_szO3 @ Language.Haskell.TH.Syntax.Exp sat_szOa } in
                    ww20_szO1
                      @ Language.Haskell.TH.Syntax.Exp
                      @ Language.Haskell.TH.Syntax.Exp
                      lvl2_szO6
                      sat_szOb } in
              let {
                sat_szO7 [Occ=Once] :: m_akV3 Language.Haskell.TH.Syntax.Exp
                [LclId, Str=DmdType]
                sat_szO7 =
                  ww22_szO3
                    @ Language.Haskell.TH.Syntax.Exp
                    CLaSH.Sized.Fixed.$fLiftFixed2 } in
              ww20_szO1
                @ Language.Haskell.TH.Syntax.Exp
                @ Language.Haskell.TH.Syntax.Exp
                sat_szO7
                sat_szOc } in
          ww20_szO1
            @ Language.Haskell.TH.Syntax.Exp
            @ Language.Haskell.TH.Syntax.Exp
            sat_szOd
            sat_szOi
          }
          } } in
    sat_szOj

CLaSH.Sized.Fixed.$fLiftFixed_$clift
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
     -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed_$clift =
  (\ (@ (frac_auGO :: GHC.TypeLits.Nat))
     (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
     (@ (size_auGQ :: GHC.TypeLits.Nat))
     (eta_B5 [Occ=Once]
        :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
     (eta_B4 [Occ=Once] :: GHC.TypeLits.KnownNat frac_auGO)
     (eta_B3 [Occ=Once] :: GHC.TypeLits.KnownNat size_auGQ)
     (eta_B2 [Occ=Once] :: Data.Typeable.Internal.Typeable rep_auGP)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
     CLaSH.Sized.Fixed.$fLiftFixed1
       @ frac_auGO
       @ rep_auGP
       @ size_auGQ
       eta_B5
       eta_B4
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac_auGO :: GHC.TypeLits.Nat)
                 (rep_auGP :: GHC.TypeLits.Nat -> *)
                 (size_auGQ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ)>_R
          -> <GHC.TypeLits.KnownNat frac_auGO>_R
          -> <GHC.TypeLits.KnownNat size_auGQ>_R
          -> <Data.Typeable.Internal.Typeable rep_auGP>_R
          -> <CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ>_R
          -> Sym
               (Language.Haskell.TH.Syntax.NTCo:Q[0]
                  <Language.Haskell.TH.Syntax.Exp>_N)
          :: (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_auGO :: GHC.TypeLits.Nat)
                     (rep_auGP :: GHC.TypeLits.Nat -> *)
                     (size_auGQ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
               GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
               Data.Typeable.Internal.Typeable rep_auGP) =>
              CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ
              -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp))

CLaSH.Sized.Fixed.$fLiftFixed [InlPrag=INLINE (sat-args=0)]
  :: forall (frac_auGO :: GHC.TypeLits.Nat)
            (rep_auGP :: GHC.TypeLits.Nat -> *)
            (size_auGQ :: GHC.TypeLits.Nat).
     (Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ),
      GHC.TypeLits.KnownNat frac_auGO, GHC.TypeLits.KnownNat size_auGQ,
      Data.Typeable.Internal.Typeable rep_auGP) =>
     Language.Haskell.TH.Syntax.Lift
       (CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ)
[GblId[DFunId(nt)], Arity=5, Str=DmdType, Unf=OtherCon []]
CLaSH.Sized.Fixed.$fLiftFixed =
  (\ (@ (frac_auGO :: GHC.TypeLits.Nat))
     (@ (rep_auGP :: GHC.TypeLits.Nat -> *))
     (@ (size_auGQ :: GHC.TypeLits.Nat))
     (eta_B5 [Occ=Once]
        :: Language.Haskell.TH.Syntax.Lift (rep_auGP size_auGQ))
     (eta_B4 [Occ=Once] :: GHC.TypeLits.KnownNat frac_auGO)
     (eta_B3 [Occ=Once] :: GHC.TypeLits.KnownNat size_auGQ)
     (eta_B2 [Occ=Once] :: Data.Typeable.Internal.Typeable rep_auGP)
     (eta_B1 [Occ=Once]
        :: CLaSH.Sized.Fixed.Fixed frac_auGO rep_auGP size_auGQ) ->
     CLaSH.Sized.Fixed.$fLiftFixed1
       @ frac_auGO
       @ rep_auGP
       @ size_auGQ
       eta_B5
       eta_B4
       eta_B3
       eta_B2
       eta_B1)
  `cast` (forall (frac_XuMV :: GHC.TypeLits.Nat)
                 (rep_XuMX :: GHC.TypeLits.Nat -> *)
                 (size_XuMZ :: GHC.TypeLits.Nat).
          <Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ)>_R
          -> <GHC.TypeLits.KnownNat frac_XuMV>_R
          -> <GHC.TypeLits.KnownNat size_XuMZ>_R
          -> <Data.Typeable.Internal.Typeable rep_XuMX>_R
          -> (<CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_R
              -> Sym
                   (Language.Haskell.TH.Syntax.NTCo:Q[0]
                      <Language.Haskell.TH.Syntax.Exp>_N))
             ; Sym
                 (Language.Haskell.TH.Syntax.NTCo:Lift[0]
                    <CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ>_N)
          :: (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ
              -> forall (m_a4LE :: * -> *).
                 Language.Haskell.TH.Syntax.Quasi m_a4LE =>
                 m_a4LE Language.Haskell.TH.Syntax.Exp)
               ~#
             (forall (frac_XuMV :: GHC.TypeLits.Nat)
                     (rep_XuMX :: GHC.TypeLits.Nat -> *)
                     (size_XuMZ :: GHC.TypeLits.Nat).
              (Language.Haskell.TH.Syntax.Lift (rep_XuMX size_XuMZ),
               GHC.TypeLits.KnownNat frac_XuMV, GHC.TypeLits.KnownNat size_XuMZ,
               Data.Typeable.Internal.Typeable rep_XuMX) =>
              Language.Haskell.TH.Syntax.Lift
                (CLaSH.Sized.Fixed.Fixed frac_XuMV rep_XuMX size_XuMZ)))



*** Stg2Stg:
*** CodeOutput:
*** New CodeGen:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** CPSZ:
*** Assembler:
[14 of 16] Compiling CLaSH.Prelude    ( src/CLaSH/Prelude.hs, dist/build/CLaSH/Prelude.o )
[15 of 16] Compiling CLaSH.Signal.Explicit ( src/CLaSH/Signal/Explicit.hs, dist/build/CLaSH/Signal/Explicit.o )
[16 of 16] Compiling CLaSH.Prelude.Explicit ( src/CLaSH/Prelude/Explicit.hs, dist/build/CLaSH/Prelude/Explicit.o )
In-place registering clash-prelude-0.5...
